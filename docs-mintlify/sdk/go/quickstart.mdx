---
title: "Go SDK Quickstart"
description: "Build your first Tolstoy workflow using the Go SDK"
---

# Go SDK Quickstart

This quickstart guide will walk you through creating your first Tolstoy workflow using the Go SDK. We'll build a user notification system that processes signup events and sends welcome messages.

## Prerequisites

- Go 1.19 or higher installed
- Tolstoy API key and Organization ID
- Basic familiarity with Go and goroutines

## Step 1: Initialize Your Project

Create a new Go project and initialize modules:

```bash
mkdir tolstoy-quickstart
cd tolstoy-quickstart

# Initialize Go module
go mod init tolstoy-quickstart

# Add Tolstoy SDK
go get github.com/tolstoy/go-sdk@latest

# Add additional dependencies for this tutorial
go get github.com/joho/godotenv@latest
```

## Step 2: Set Up Environment

Create a `.env` file with your credentials:

```bash
# .env
TOLSTOY_API_KEY=your-api-key-here
TOLSTOY_ORGANIZATION_ID=your-org-id-here
TOLSTOY_BASE_URL=https://api.tolstoy.com
TOLSTOY_DEBUG=true
```

## Step 3: Create the Main Application

Create `main.go`:

```go
package main

import (
    "context"
    "fmt"
    "log"
    "os"
    "time"

    "github.com/joho/godotenv"
    "github.com/tolstoy/go-sdk/tolstoy"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Printf("Warning: .env file not loaded: %v", err)
    }

    fmt.Println("üöÄ Tolstoy Go SDK Quickstart")

    // Initialize the client
    client, err := tolstoy.NewClientFromEnv()
    if err != nil {
        log.Fatalf("Failed to create client: %v", err)
    }
    defer client.Close()

    ctx := context.Background()

    // Test connection
    user, err := client.Users.GetCurrent(ctx)
    if err != nil {
        log.Fatalf("‚ùå Connection failed: %v", err)
    }
    fmt.Printf("‚úÖ Connected as: %s\n", user.Email)

    // Run quickstart workflow
    if err := runQuickstart(ctx, client); err != nil {
        log.Fatalf("Quickstart failed: %v", err)
    }

    fmt.Println("üéâ Quickstart completed successfully!")
}

func runQuickstart(ctx context.Context, client *tolstoy.Client) error {
    // Step 1: Create a notification tool
    slackTool, err := createSlackTool(ctx, client)
    if err != nil {
        return fmt.Errorf("failed to create Slack tool: %w", err)
    }

    // Step 2: Create a notification action
    notificationAction, err := createNotificationAction(ctx, client, slackTool.ID)
    if err != nil {
        return fmt.Errorf("failed to create notification action: %w", err)
    }

    // Step 3: Create a complete workflow
    signupFlow, err := createSignupFlow(ctx, client, notificationAction.ID)
    if err != nil {
        return fmt.Errorf("failed to create signup flow: %w", err)
    }

    // Step 4: Test the workflow
    if err := testWorkflow(ctx, client, signupFlow.ID); err != nil {
        return fmt.Errorf("failed to test workflow: %w", err)
    }

    return nil
}
```

## Step 4: Create a Tool

Add the tool creation function:

```go
func createSlackTool(ctx context.Context, client *tolstoy.Client) (*tolstoy.Tool, error) {
    fmt.Println("\nüì° Creating Slack webhook tool...")

    tool, err := client.Tools.Create(ctx, &tolstoy.CreateToolRequest{
        Name:        "Slack Notifications",
        BaseURL:     "https://hooks.slack.com/services",
        Category:    "notification",
        AuthType:    tolstoy.AuthTypeNone, // Webhook URL includes auth
        Description: "Send notifications to Slack channel",
    })
    if err != nil {
        return nil, err
    }

    fmt.Printf("‚úÖ Created tool: %s (ID: %s)\n", tool.Name, tool.ID)
    return tool, nil
}
```

## Step 5: Create an Action

Add the action creation function:

```go
func createNotificationAction(ctx context.Context, client *tolstoy.Client, toolID string) (*tolstoy.Action, error) {
    fmt.Println("\n‚ö° Creating notification action...")

    action, err := client.Actions.Create(ctx, &tolstoy.CreateActionRequest{
        Name:        "Send Slack Notification",
        ToolID:      toolID,
        Method:      "POST",
        Endpoint:    "/YOUR_WORKSPACE/YOUR_CHANNEL/YOUR_WEBHOOK_TOKEN",
        Description: "Send a notification message to Slack",
        InputSchema: []tolstoy.InputField{
            {
                Name:        "text",
                Type:        "string",
                Required:    true,
                Description: "The message text to send",
            },
            {
                Name:        "username",
                Type:        "string",
                Required:    false,
                Description: "Bot username",
                Default:     "Tolstoy Bot",
            },
        },
        RequestTemplate: &tolstoy.RequestTemplate{
            Body: map[string]interface{}{
                "text":       "{{ input.text }}",
                "username":   "{{ input.username }}",
                "icon_emoji": ":robot_face:",
            },
        },
    })
    if err != nil {
        return nil, err
    }

    fmt.Printf("‚úÖ Created action: %s (ID: %s)\n", action.Name, action.ID)
    return action, nil
}
```

## Step 6: Create a Workflow

Add the workflow creation function:

```go
func createSignupFlow(ctx context.Context, client *tolstoy.Client, notificationActionID string) (*tolstoy.Flow, error) {
    fmt.Println("\nüîÑ Creating user signup workflow...")

    flow, err := client.Flows.Create(ctx, &tolstoy.CreateFlowRequest{
        Name:        "User Signup Notification Flow",
        Description: "Process new user signups and send notifications",
        Trigger: tolstoy.FlowTrigger{
            Type: tolstoy.TriggerTypeWebhook,
            Config: map[string]interface{}{
                "method": "POST",
                "path":   "/webhooks/user-signup",
                "authentication": map[string]interface{}{
                    "type":   "api_key",
                    "header": "X-API-Key",
                },
            },
        },
        Steps: []tolstoy.FlowStep{
            {
                ID:   "validate_input",
                Name: "Validate User Data",
                Type: tolstoy.StepTypeCondition,
                Condition: map[string]interface{}{
                    "and": []interface{}{
                        map[string]interface{}{
                            "!=": []interface{}{
                                map[string]string{"var": "trigger.email"},
                                nil,
                            },
                        },
                        map[string]interface{}{
                            "!=": []interface{}{
                                map[string]string{"var": "trigger.name"},
                                nil,
                            },
                        },
                        map[string]interface{}{
                            "regex": []interface{}{
                                map[string]string{"var": "trigger.email"},
                                "^[^@]+@[^@]+\\.[^@]+$",
                            },
                        },
                    },
                },
                OnFalse: &tolstoy.StepAction{
                    Action:  "terminate",
                    Message: "Invalid user data provided",
                },
            },
            {
                ID:       "send_notification",
                Name:     "Send Slack Notification",
                Type:     tolstoy.StepTypeAction,
                ActionID: notificationActionID,
                Input: map[string]interface{}{
                    "text":     "üéâ New user signup: {{ trigger.name }} ({{ trigger.email }})",
                    "username": "Signup Bot",
                },
                Dependencies: []string{"validate_input"},
            },
            {
                ID:   "log_success",
                Name: "Log Successful Processing",
                Type: tolstoy.StepTypeTransform,
                Output: map[string]interface{}{
                    "message":      "User signup processed successfully",
                    "user_email":   "{{ trigger.email }}",
                    "user_name":    "{{ trigger.name }}",
                    "processed_at": "{{ now }}",
                },
                Dependencies: []string{"send_notification"},
            },
        },
        Settings: &tolstoy.FlowSettings{
            Timeout: 60, // 1 minute timeout
            RetryPolicy: &tolstoy.RetryPolicy{
                MaxRetries:        3,
                BackoffMultiplier: 2.0,
            },
            ErrorHandling: &tolstoy.ErrorHandling{
                OnFailure: "log_and_continue",
            },
        },
    })
    if err != nil {
        return nil, err
    }

    fmt.Printf("‚úÖ Created flow: %s (ID: %s)\n", flow.Name, flow.ID)
    return flow, nil
}
```

## Step 7: Test the Workflow

Add the testing function:

```go
func testWorkflow(ctx context.Context, client *tolstoy.Client, flowID string) error {
    fmt.Println("\nüß™ Testing the workflow...")

    // Execute the flow with test data
    execution, err := client.Flows.Execute(ctx, flowID, map[string]interface{}{
        "email":         "john.doe@example.com",
        "name":          "John Doe",
        "signup_source": "website",
    })
    if err != nil {
        return err
    }

    fmt.Printf("‚úÖ Flow execution started (ID: %s)\n", execution.ID)

    // Wait for completion with timeout
    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()

    result, err := client.Executions.WaitForCompletion(ctx, execution.ID)
    if err != nil {
        return err
    }

    if result.Status == tolstoy.ExecutionStatusSuccess {
        fmt.Println("‚úÖ Workflow completed successfully!")
        fmt.Printf("üìä Output: %+v\n", result.Output)
    } else {
        fmt.Printf("‚ùå Workflow failed: %v\n", result.Error)
    }

    return nil
}
```

## Step 8: Add Error Handling

Enhance the main function with proper error handling:

```go
// Add these imports at the top
import (
    "errors"
    // ... other imports
)

// Enhanced error handling function
func handleError(err error) {
    var apiErr *tolstoy.APIError
    if errors.As(err, &apiErr) {
        switch apiErr.Code {
        case tolstoy.ErrorCodeAuth:
            log.Printf("‚ùå Authentication failed: %s", apiErr.Message)
            log.Printf("üí° Check your API key and organization ID")
        case tolstoy.ErrorCodeRateLimit:
            log.Printf("‚ùå Rate limit exceeded: %s", apiErr.Message)
            log.Printf("üí° Retry after: %v", apiErr.RetryAfter)
        case tolstoy.ErrorCodeValidation:
            log.Printf("‚ùå Validation failed: %s", apiErr.Message)
            log.Printf("üí° Errors: %v", apiErr.Errors)
        case tolstoy.ErrorCodeNotFound:
            log.Printf("‚ùå Resource not found: %s", apiErr.Message)
        default:
            log.Printf("‚ùå API error: %s", apiErr.Message)
        }
    } else {
        log.Printf("‚ùå Request failed: %v", err)
    }
}

// Update runQuickstart to use error handling
func runQuickstart(ctx context.Context, client *tolstoy.Client) error {
    // Step 1: Create a notification tool
    slackTool, err := createSlackTool(ctx, client)
    if err != nil {
        handleError(err)
        return fmt.Errorf("failed to create Slack tool: %w", err)
    }

    // ... rest of the function remains the same
}
```

## Step 9: Add Concurrent Operations

Demonstrate Go's concurrency features:

```go
// Add this function to show concurrent execution
func runConcurrentActions(ctx context.Context, client *tolstoy.Client, actionID string) error {
    fmt.Println("\nüöÄ Running concurrent action executions...")

    type Result struct {
        ID     int
        Result *tolstoy.ExecutionResult
        Error  error
    }

    const numExecutions = 5
    resultChan := make(chan Result, numExecutions)

    // Launch multiple goroutines
    for i := 0; i < numExecutions; i++ {
        go func(id int) {
            result, err := client.Actions.Execute(ctx, actionID, map[string]interface{}{
                "text":     fmt.Sprintf("Concurrent message %d", id),
                "username": "Concurrent Bot",
            })

            resultChan <- Result{
                ID:     id,
                Result: result,
                Error:  err,
            }
        }(i)
    }

    // Collect results
    successful := 0
    failed := 0

    for i := 0; i < numExecutions; i++ {
        result := <-resultChan
        if result.Error != nil {
            fmt.Printf("‚ùå Execution %d failed: %v\n", result.ID, result.Error)
            failed++
        } else {
            fmt.Printf("‚úÖ Execution %d completed: %s\n", result.ID, result.Result.ID)
            successful++
        }
    }

    fmt.Printf("üìä Results: %d successful, %d failed\n", successful, failed)
    return nil
}
```

## Step 10: Build and Run

Create a `Makefile` for easy building:

```makefile
# Makefile
.PHONY: build run clean test

# Build the application
build:
	go build -o bin/quickstart .

# Run the application
run:
	go run .

# Clean build artifacts
clean:
	rm -rf bin/

# Run tests
test:
	go test -v ./...

# Format code
fmt:
	gofmt -s -w .
	goimports -w .

# Install dependencies
deps:
	go mod download
	go mod tidy
```

Build and run your application:

```bash
# Build the application
make build

# Or run directly
make run

# Format code
make fmt
```

## Complete Example

<details>
<summary>Complete main.go file</summary>

```go
package main

import (
    "context"
    "errors"
    "fmt"
    "log"
    "os"
    "time"

    "github.com/joho/godotenv"
    "github.com/tolstoy/go-sdk/tolstoy"
)

func main() {
    // Load environment variables
    if err := godotenv.Load(); err != nil {
        log.Printf("Warning: .env file not loaded: %v", err)
    }

    fmt.Println("üöÄ Tolstoy Go SDK Quickstart")

    // Initialize the client
    client, err := tolstoy.NewClientFromEnv()
    if err != nil {
        log.Fatalf("Failed to create client: %v", err)
    }
    defer client.Close()

    ctx := context.Background()

    // Test connection
    user, err := client.Users.GetCurrent(ctx)
    if err != nil {
        handleError(err)
        log.Fatalf("‚ùå Connection failed: %v", err)
    }
    fmt.Printf("‚úÖ Connected as: %s\n", user.Email)

    // Run quickstart workflow
    if err := runQuickstart(ctx, client); err != nil {
        handleError(err)
        log.Fatalf("Quickstart failed: %v", err)
    }

    fmt.Println("üéâ Quickstart completed successfully!")
    fmt.Printf("üìù Visit https://app.tolstoy.com to view your workflows\n")
}

func runQuickstart(ctx context.Context, client *tolstoy.Client) error {
    // Step 1: Create a notification tool
    slackTool, err := createSlackTool(ctx, client)
    if err != nil {
        return fmt.Errorf("failed to create Slack tool: %w", err)
    }

    // Step 2: Create a notification action
    notificationAction, err := createNotificationAction(ctx, client, slackTool.ID)
    if err != nil {
        return fmt.Errorf("failed to create notification action: %w", err)
    }

    // Step 3: Create a complete workflow
    signupFlow, err := createSignupFlow(ctx, client, notificationAction.ID)
    if err != nil {
        return fmt.Errorf("failed to create signup flow: %w", err)
    }

    // Step 4: Test the workflow
    if err := testWorkflow(ctx, client, signupFlow.ID); err != nil {
        return fmt.Errorf("failed to test workflow: %w", err)
    }

    // Step 5: Demonstrate concurrent operations
    if err := runConcurrentActions(ctx, client, notificationAction.ID); err != nil {
        return fmt.Errorf("failed to run concurrent actions: %w", err)
    }

    return nil
}

func createSlackTool(ctx context.Context, client *tolstoy.Client) (*tolstoy.Tool, error) {
    fmt.Println("\nüì° Creating Slack webhook tool...")

    tool, err := client.Tools.Create(ctx, &tolstoy.CreateToolRequest{
        Name:        "Slack Notifications",
        BaseURL:     "https://hooks.slack.com/services",
        Category:    "notification",
        AuthType:    tolstoy.AuthTypeNone,
        Description: "Send notifications to Slack channel",
    })
    if err != nil {
        return nil, err
    }

    fmt.Printf("‚úÖ Created tool: %s (ID: %s)\n", tool.Name, tool.ID)
    return tool, nil
}

func createNotificationAction(ctx context.Context, client *tolstoy.Client, toolID string) (*tolstoy.Action, error) {
    fmt.Println("\n‚ö° Creating notification action...")

    action, err := client.Actions.Create(ctx, &tolstoy.CreateActionRequest{
        Name:        "Send Slack Notification",
        ToolID:      toolID,
        Method:      "POST",
        Endpoint:    "/YOUR_WORKSPACE/YOUR_CHANNEL/YOUR_WEBHOOK_TOKEN",
        Description: "Send a notification message to Slack",
        InputSchema: []tolstoy.InputField{
            {
                Name:        "text",
                Type:        "string",
                Required:    true,
                Description: "The message text to send",
            },
            {
                Name:        "username",
                Type:        "string",
                Required:    false,
                Description: "Bot username",
                Default:     "Tolstoy Bot",
            },
        },
        RequestTemplate: &tolstoy.RequestTemplate{
            Body: map[string]interface{}{
                "text":       "{{ input.text }}",
                "username":   "{{ input.username }}",
                "icon_emoji": ":robot_face:",
            },
        },
    })
    if err != nil {
        return nil, err
    }

    fmt.Printf("‚úÖ Created action: %s (ID: %s)\n", action.Name, action.ID)
    return action, nil
}

func createSignupFlow(ctx context.Context, client *tolstoy.Client, notificationActionID string) (*tolstoy.Flow, error) {
    fmt.Println("\nüîÑ Creating user signup workflow...")

    flow, err := client.Flows.Create(ctx, &tolstoy.CreateFlowRequest{
        Name:        "User Signup Notification Flow",
        Description: "Process new user signups and send notifications",
        Trigger: tolstoy.FlowTrigger{
            Type: tolstoy.TriggerTypeWebhook,
            Config: map[string]interface{}{
                "method": "POST",
                "path":   "/webhooks/user-signup",
                "authentication": map[string]interface{}{
                    "type":   "api_key",
                    "header": "X-API-Key",
                },
            },
        },
        Steps: []tolstoy.FlowStep{
            {
                ID:   "validate_input",
                Name: "Validate User Data",
                Type: tolstoy.StepTypeCondition,
                Condition: map[string]interface{}{
                    "and": []interface{}{
                        map[string]interface{}{
                            "!=": []interface{}{
                                map[string]string{"var": "trigger.email"},
                                nil,
                            },
                        },
                        map[string]interface{}{
                            "!=": []interface{}{
                                map[string]string{"var": "trigger.name"},
                                nil,
                            },
                        },
                        map[string]interface{}{
                            "regex": []interface{}{
                                map[string]string{"var": "trigger.email"},
                                "^[^@]+@[^@]+\\.[^@]+$",
                            },
                        },
                    },
                },
                OnFalse: &tolstoy.StepAction{
                    Action:  "terminate",
                    Message: "Invalid user data provided",
                },
            },
            {
                ID:       "send_notification",
                Name:     "Send Slack Notification",
                Type:     tolstoy.StepTypeAction,
                ActionID: notificationActionID,
                Input: map[string]interface{}{
                    "text":     "üéâ New user signup: {{ trigger.name }} ({{ trigger.email }})",
                    "username": "Signup Bot",
                },
                Dependencies: []string{"validate_input"},
            },
            {
                ID:   "log_success",
                Name: "Log Successful Processing",
                Type: tolstoy.StepTypeTransform,
                Output: map[string]interface{}{
                    "message":      "User signup processed successfully",
                    "user_email":   "{{ trigger.email }}",
                    "user_name":    "{{ trigger.name }}",
                    "processed_at": "{{ now }}",
                },
                Dependencies: []string{"send_notification"},
            },
        },
        Settings: &tolstoy.FlowSettings{
            Timeout: 60,
            RetryPolicy: &tolstoy.RetryPolicy{
                MaxRetries:        3,
                BackoffMultiplier: 2.0,
            },
            ErrorHandling: &tolstoy.ErrorHandling{
                OnFailure: "log_and_continue",
            },
        },
    })
    if err != nil {
        return nil, err
    }

    fmt.Printf("‚úÖ Created flow: %s (ID: %s)\n", flow.Name, flow.ID)
    return flow, nil
}

func testWorkflow(ctx context.Context, client *tolstoy.Client, flowID string) error {
    fmt.Println("\nüß™ Testing the workflow...")

    execution, err := client.Flows.Execute(ctx, flowID, map[string]interface{}{
        "email":         "john.doe@example.com",
        "name":          "John Doe",
        "signup_source": "website",
    })
    if err != nil {
        return err
    }

    fmt.Printf("‚úÖ Flow execution started (ID: %s)\n", execution.ID)

    ctx, cancel := context.WithTimeout(ctx, 30*time.Second)
    defer cancel()

    result, err := client.Executions.WaitForCompletion(ctx, execution.ID)
    if err != nil {
        return err
    }

    if result.Status == tolstoy.ExecutionStatusSuccess {
        fmt.Println("‚úÖ Workflow completed successfully!")
        fmt.Printf("üìä Output: %+v\n", result.Output)
    } else {
        fmt.Printf("‚ùå Workflow failed: %v\n", result.Error)
    }

    return nil
}

func runConcurrentActions(ctx context.Context, client *tolstoy.Client, actionID string) error {
    fmt.Println("\nüöÄ Running concurrent action executions...")

    type Result struct {
        ID     int
        Result *tolstoy.ExecutionResult
        Error  error
    }

    const numExecutions = 5
    resultChan := make(chan Result, numExecutions)

    for i := 0; i < numExecutions; i++ {
        go func(id int) {
            result, err := client.Actions.Execute(ctx, actionID, map[string]interface{}{
                "text":     fmt.Sprintf("Concurrent message %d", id),
                "username": "Concurrent Bot",
            })

            resultChan <- Result{
                ID:     id,
                Result: result,
                Error:  err,
            }
        }(i)
    }

    successful := 0
    failed := 0

    for i := 0; i < numExecutions; i++ {
        result := <-resultChan
        if result.Error != nil {
            fmt.Printf("‚ùå Execution %d failed: %v\n", result.ID, result.Error)
            failed++
        } else {
            fmt.Printf("‚úÖ Execution %d completed: %s\n", result.ID, result.Result.ID)
            successful++
        }
    }

    fmt.Printf("üìä Results: %d successful, %d failed\n", successful, failed)
    return nil
}

func handleError(err error) {
    var apiErr *tolstoy.APIError
    if errors.As(err, &apiErr) {
        switch apiErr.Code {
        case tolstoy.ErrorCodeAuth:
            log.Printf("‚ùå Authentication failed: %s", apiErr.Message)
            log.Printf("üí° Check your API key and organization ID")
        case tolstoy.ErrorCodeRateLimit:
            log.Printf("‚ùå Rate limit exceeded: %s", apiErr.Message)
            log.Printf("üí° Retry after: %v", apiErr.RetryAfter)
        case tolstoy.ErrorCodeValidation:
            log.Printf("‚ùå Validation failed: %s", apiErr.Message)
            log.Printf("üí° Errors: %v", apiErr.Errors)
        case tolstoy.ErrorCodeNotFound:
            log.Printf("‚ùå Resource not found: %s", apiErr.Message)
        default:
            log.Printf("‚ùå API error: %s", apiErr.Message)
        }
    } else {
        log.Printf("‚ùå Request failed: %v", err)
    }
}
```

</details>

## Step 11: Production Considerations

### Graceful Shutdown

Add signal handling for graceful shutdown:

```go
package main

import (
    "context"
    "os"
    "os/signal"
    "syscall"
    // ... other imports
)

func main() {
    // ... existing code ...

    // Set up signal handling
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()

    // Handle interrupts
    go func() {
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
        <-sigChan
        
        fmt.Println("\nüõë Shutting down gracefully...")
        cancel()
    }()

    // Run with cancellable context
    if err := runQuickstart(ctx, client); err != nil {
        if errors.Is(err, context.Canceled) {
            fmt.Println("‚úÖ Shutdown completed")
            return
        }
        handleError(err)
        log.Fatalf("Quickstart failed: %v", err)
    }

    fmt.Println("üéâ Quickstart completed successfully!")
}
```

### Configuration Management

Create a configuration struct:

```go
type Config struct {
    TolstoyAPIKey    string `env:"TOLSTOY_API_KEY,required"`
    TolstoyOrgID     string `env:"TOLSTOY_ORGANIZATION_ID,required"`
    TolstoyBaseURL   string `env:"TOLSTOY_BASE_URL" envDefault:"https://api.tolstoy.com"`
    TolstoyTimeout   string `env:"TOLSTOY_TIMEOUT" envDefault:"30s"`
    TolstoyDebug     bool   `env:"TOLSTOY_DEBUG" envDefault:"false"`
    SlackWebhookPath string `env:"SLACK_WEBHOOK_PATH,required"`
}

func loadConfig() (*Config, error) {
    var cfg Config
    if err := env.Parse(&cfg); err != nil {
        return nil, fmt.Errorf("failed to parse config: %w", err)
    }
    return &cfg, nil
}
```

## Next Steps

Congratulations! You've built your first Tolstoy workflow using the Go SDK. Here's what you can explore next:

<CardGroup cols={2}>
  <Card title="Advanced Examples" icon="code" href="/sdk/go/examples">
    Explore complex Go patterns and workflows
  </Card>
  <Card title="API Reference" icon="book" href="/api/index">
    Complete API documentation
  </Card>
  <Card title="Error Handling" icon="shield-alt" href="/public/product/troubleshooting/overview">
    Learn about error handling and debugging
  </Card>
  <Card title="Production Deployment" icon="rocket" href="/public/product/optimization/scaling">
    Scale your workflows for production
  </Card>
</CardGroup>

## Common Issues

### Slack Webhook Setup

To use the Slack integration, you'll need to:
1. Create a Slack app at https://api.slack.com/apps
2. Enable incoming webhooks
3. Add webhook to your workspace
4. Replace `YOUR_WORKSPACE/YOUR_CHANNEL/YOUR_WEBHOOK_TOKEN` with your actual webhook URL path

### Context Timeouts

Always use contexts with appropriate timeouts:

```go
// Set reasonable timeouts for different operations
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

result, err := client.Actions.Execute(ctx, actionID, inputData)
```

### Resource Management

Remember to always close the client:

```go
client, err := tolstoy.NewClient(config)
if err != nil {
    log.Fatal(err)
}
defer client.Close() // Important: always close the client
```