---
title: "Delete Tool Secret"
api: "DELETE /tools/secrets/{id}"
description: "Permanently remove a stored tool secret"
---

## Overview

The Delete Tool Secret endpoint permanently removes a stored secret from your organization's secure vault. This action cannot be undone and will immediately invalidate any workflows or processes that depend on this secret.

## Authentication

<ParamField header="x-org-id" type="string" required>
  Organization ID for multi-tenant access control
</ParamField>

<ParamField header="x-user-id" type="string" required>
  User ID of the requesting user for authorization
</ParamField>

<ParamField header="authorization" type="string" required>
  Bearer token for API authentication
</ParamField>

## Path Parameters

<ParamField path="id" type="string" required>
  The unique identifier of the tool secret to delete
</ParamField>

## Response

**Status Code:** `204 No Content`

Successfully deleted secret returns no content.

## Error Responses

<ResponseField name="404" type="object">
  Not Found - Secret does not exist
  
  <Expandable title="Error Schema">
    <ResponseField name="error" type="string">
      Error type identifier
    </ResponseField>
    <ResponseField name="message" type="string">
      Human-readable error description
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="403" type="object">
  Forbidden - Insufficient permissions to delete this secret
</ResponseField>

<ResponseField name="409" type="object">
  Conflict - Cannot delete secret that is actively being used
</ResponseField>

## Usage Examples

<CodeGroup>

```bash cURL
curl -X DELETE "https://api.tolstoy.com/v1/tools/secrets/secret_abc123" \
  -H "Authorization: Bearer $API_TOKEN" \
  -H "X-Org-ID: org_123456" \
  -H "X-User-ID: user_789012"
```

```javascript JavaScript
const deleteResponse = await fetch('/api/v1/tools/secrets/secret_abc123', {
  method: 'DELETE',
  headers: {
    'Authorization': `Bearer ${apiToken}`,
    'X-Org-ID': 'org_123456',
    'X-User-ID': 'user_789012'
  }
});

if (deleteResponse.ok) {
  console.log('Secret deleted successfully');
} else if (deleteResponse.status === 404) {
  console.error('Secret not found');
} else if (deleteResponse.status === 409) {
  console.error('Cannot delete: secret is actively being used');
} else {
  const error = await deleteResponse.json();
  console.error('Delete failed:', error.message);
}
```

```python Python
import requests

response = requests.delete(
    "https://api.tolstoy.com/v1/tools/secrets/secret_abc123",
    headers={
        "Authorization": f"Bearer {api_token}",
        "X-Org-ID": "org_123456",
        "X-User-ID": "user_789012"
    }
)

if response.status_code == 204:
    print("Secret deleted successfully")
elif response.status_code == 404:
    print("Secret not found")
elif response.status_code == 409:
    print("Cannot delete: secret is actively being used")
else:
    error = response.json()
    print(f"Delete failed: {error['message']}")
```

</CodeGroup>

## Safe Deletion Process

### Pre-deletion Impact Analysis
```javascript
async function analyzeSecretDeletionImpact(secretId, apiToken, orgId, userId) {
  const impact = {
    secretId: secretId,
    canSafelyDelete: false,
    affectedWorkflows: [],
    recentUsage: 0,
    warnings: [],
    recommendations: []
  };
  
  // Get secret details
  const secretResponse = await fetch(`/api/v1/tools/secrets/${secretId}?includeUsageHistory=true`, {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  if (!secretResponse.ok) {
    impact.warnings.push('Secret not found or access denied');
    return impact;
  }
  
  const secret = await secretResponse.json();
  
  // Check recent usage
  if (secret.usageHistory) {
    const last24Hours = new Date(Date.now() - 24 * 60 * 60 * 1000);
    const recentUsage = secret.usageHistory.filter(usage => 
      new Date(usage.timestamp) >= last24Hours
    );
    impact.recentUsage = recentUsage.length;
    
    if (impact.recentUsage > 0) {
      impact.warnings.push(`Secret was used ${impact.recentUsage} times in the last 24 hours`);
    }
  }
  
  // Check for workflows using this tool
  const workflowsResponse = await fetch(`/api/v1/flows?toolId=${secret.toolId}`, {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  if (workflowsResponse.ok) {
    const workflowsData = await workflowsResponse.json();
    const activeWorkflows = workflowsData.flows?.filter(flow => flow.status === 'active') || [];
    impact.affectedWorkflows = activeWorkflows.map(flow => ({
      id: flow.id,
      name: flow.name,
      status: flow.status
    }));
    
    if (impact.affectedWorkflows.length > 0) {
      impact.warnings.push(`${impact.affectedWorkflows.length} active workflows may be affected`);
    }
  }
  
  // Check if secret has expired (safer to delete)
  if (secret.status === 'expired') {
    impact.recommendations.push('Secret is expired - safe to delete');
  } else if (secret.status === 'active') {
    impact.warnings.push('Secret is still active and may be in use');
  }
  
  // Check last usage
  if (secret.lastUsed) {
    const lastUsed = new Date(secret.lastUsed);
    const daysSinceLastUse = (new Date() - lastUsed) / (1000 * 60 * 60 * 24);
    
    if (daysSinceLastUse > 90) {
      impact.recommendations.push('Secret has not been used in 90+ days - likely safe to delete');
    } else if (daysSinceLastUse < 7) {
      impact.warnings.push('Secret was used recently - deletion may cause immediate failures');
    }
  } else {
    impact.recommendations.push('Secret has never been used - safe to delete');
  }
  
  // Determine if safe to delete
  impact.canSafelyDelete = impact.warnings.length === 0 || 
    (secret.status === 'expired' && impact.recentUsage === 0);
  
  if (!impact.canSafelyDelete) {
    impact.recommendations.push('Review warnings before deletion');
    if (impact.affectedWorkflows.length > 0) {
      impact.recommendations.push('Update or disable affected workflows first');
    }
  }
  
  return impact;
}

// Usage
const impact = await analyzeSecretDeletionImpact('secret_abc123', apiToken, 'org_123456', 'user_789012');

console.log(`Can safely delete: ${impact.canSafelyDelete}`);
if (impact.warnings.length > 0) {
  console.log('Warnings:');
  impact.warnings.forEach(warning => console.log(`⚠️ ${warning}`));
}

if (!impact.canSafelyDelete) {
  const proceed = confirm('Secret deletion may cause issues. Continue anyway?');
  if (!proceed) {
    console.log('Deletion cancelled');
    return;
  }
}
```

### Backup Secret Metadata Before Deletion
```javascript
async function backupSecretMetadata(secretId, apiToken, orgId, userId) {
  const response = await fetch(`/api/v1/tools/secrets/${secretId}?includeMetadata=true`, {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  if (!response.ok) {
    throw new Error('Failed to retrieve secret for backup');
  }
  
  const secret = await response.json();
  
  // Create backup object (excluding the actual secret value)
  const backup = {
    id: secret.id,
    toolId: secret.toolId,
    toolName: secret.toolName,
    name: secret.name,
    description: secret.description,
    secretType: secret.secretType,
    keyHint: secret.keyHint,
    scope: secret.scope,
    metadata: secret.metadata,
    createdAt: secret.createdAt,
    updatedAt: secret.updatedAt,
    lastUsed: secret.lastUsed,
    usageCount: secret.usageCount,
    backedUpAt: new Date().toISOString(),
    backedUpBy: userId,
    deletionReason: 'user_initiated'
  };
  
  // Store backup (could be localStorage, external service, etc.)
  const backupKey = `secret_backup_${secretId}_${Date.now()}`;
  localStorage.setItem(backupKey, JSON.stringify(backup));
  
  console.log(`Secret metadata backed up with key: ${backupKey}`);
  return backup;
}
```

### Safe Deletion Workflow
```javascript
async function safeDeleteSecret(secretId, apiToken, orgId, userId) {
  try {
    // Step 1: Analyze impact
    console.log('Analyzing deletion impact...');
    const impact = await analyzeSecretDeletionImpact(secretId, apiToken, orgId, userId);
    
    if (!impact.canSafelyDelete && impact.warnings.length > 0) {
      console.warn('Deletion warnings detected:');
      impact.warnings.forEach(warning => console.warn(`- ${warning}`));
      
      // In a real application, you might show a confirmation dialog
      const confirmed = confirm('Proceed with deletion despite warnings?');
      if (!confirmed) {
        console.log('Deletion cancelled by user');
        return { success: false, reason: 'user_cancelled' };
      }
    }
    
    // Step 2: Create backup
    console.log('Creating metadata backup...');
    await backupSecretMetadata(secretId, apiToken, orgId, userId);
    
    // Step 3: Delete the secret
    console.log('Deleting secret...');
    const deleteResponse = await fetch(`/api/v1/tools/secrets/${secretId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${apiToken}`,
        'X-Org-ID': orgId,
        'X-User-ID': userId
      }
    });
    
    if (deleteResponse.ok) {
      console.log('Secret deleted successfully');
      return { success: true, warnings: impact.warnings };
    } else {
      const error = await deleteResponse.json();
      throw new Error(`Deletion failed: ${error.message}`);
    }
    
  } catch (error) {
    console.error('Safe deletion failed:', error.message);
    return { success: false, error: error.message };
  }
}

// Usage
const result = await safeDeleteSecret('secret_abc123', apiToken, 'org_123456', 'user_789012');
if (result.success) {
  console.log('✅ Secret safely deleted');
  if (result.warnings?.length > 0) {
    console.log('Note: There were warnings during deletion');
  }
} else {
  console.error('❌ Deletion failed:', result.error || result.reason);
}
```

## Bulk Deletion

### Delete Multiple Secrets
```javascript
async function bulkDeleteSecrets(secretIds, apiToken, orgId, userId, options = {}) {
  const results = [];
  const { skipValidation = false, createBackups = true } = options;
  
  for (const secretId of secretIds) {
    try {
      let canDelete = true;
      let warnings = [];
      
      if (!skipValidation) {
        const impact = await analyzeSecretDeletionImpact(secretId, apiToken, orgId, userId);
        canDelete = impact.canSafelyDelete;
        warnings = impact.warnings;
        
        if (!canDelete && !options.forceDelete) {
          results.push({
            secretId,
            success: false,
            skipped: true,
            reason: 'safety_check_failed',
            warnings
          });
          continue;
        }
      }
      
      // Create backup if requested
      if (createBackups) {
        await backupSecretMetadata(secretId, apiToken, orgId, userId);
      }
      
      // Delete the secret
      const response = await fetch(`/api/v1/tools/secrets/${secretId}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${apiToken}`,
          'X-Org-ID': orgId,
          'X-User-ID': userId
        }
      });
      
      results.push({
        secretId,
        success: response.ok,
        status: response.status,
        warnings: warnings
      });
      
      // Add delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 200));
      
    } catch (error) {
      results.push({
        secretId,
        success: false,
        error: error.message
      });
    }
  }
  
  return results;
}

// Usage
const secretIds = ['secret_123', 'secret_456', 'secret_789'];
const deletionResults = await bulkDeleteSecrets(secretIds, apiToken, 'org_123456', 'user_789012');

const successful = deletionResults.filter(r => r.success).length;
const skipped = deletionResults.filter(r => r.skipped).length;
const failed = deletionResults.filter(r => !r.success && !r.skipped).length;

console.log(`Deletion summary: ${successful} deleted, ${skipped} skipped, ${failed} failed`);

// Show detailed results
deletionResults.forEach(result => {
  if (result.success) {
    console.log(`✅ Deleted secret ${result.secretId}`);
  } else if (result.skipped) {
    console.log(`⏭️ Skipped secret ${result.secretId}: ${result.reason}`);
  } else {
    console.error(`❌ Failed to delete secret ${result.secretId}: ${result.error || result.status}`);
  }
});
```

## Cleanup Operations

### Delete Expired Secrets
```javascript
async function deleteExpiredSecrets(apiToken, orgId, userId) {
  // Get all expired secrets
  const response = await fetch('/api/v1/tools/secrets?status=expired', {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  if (!response.ok) {
    throw new Error('Failed to retrieve expired secrets');
  }
  
  const data = await response.json();
  const expiredSecrets = data.toolSecrets || [];
  
  if (expiredSecrets.length === 0) {
    console.log('No expired secrets found');
    return { deleted: 0, errors: [] };
  }
  
  console.log(`Found ${expiredSecrets.length} expired secrets`);
  
  // Delete each expired secret
  const results = await bulkDeleteSecrets(
    expiredSecrets.map(s => s.id),
    apiToken,
    orgId,
    userId,
    { skipValidation: true } // Skip validation for expired secrets
  );
  
  const deleted = results.filter(r => r.success).length;
  const errors = results.filter(r => !r.success);
  
  console.log(`Cleanup complete: ${deleted} expired secrets deleted`);
  if (errors.length > 0) {
    console.warn(`${errors.length} secrets could not be deleted`);
  }
  
  return { deleted, errors };
}
```

### Delete Unused Secrets
```javascript
async function deleteUnusedSecrets(daysThreshold = 90, apiToken, orgId, userId) {
  const response = await fetch('/api/v1/tools/secrets', {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  const data = await response.json();
  const allSecrets = data.toolSecrets || [];
  
  const thresholdDate = new Date(Date.now() - daysThreshold * 24 * 60 * 60 * 1000);
  
  const unusedSecrets = allSecrets.filter(secret => {
    // Never used
    if (!secret.lastUsed) return true;
    
    // Not used within threshold
    const lastUsed = new Date(secret.lastUsed);
    return lastUsed < thresholdDate;
  });
  
  if (unusedSecrets.length === 0) {
    console.log(`No secrets unused for ${daysThreshold}+ days`);
    return { deleted: 0, errors: [] };
  }
  
  console.log(`Found ${unusedSecrets.length} secrets unused for ${daysThreshold}+ days`);
  
  // Show what will be deleted
  unusedSecrets.forEach(secret => {
    const lastUsedText = secret.lastUsed 
      ? `last used ${Math.floor((new Date() - new Date(secret.lastUsed)) / (1000 * 60 * 60 * 24))} days ago`
      : 'never used';
    console.log(`- ${secret.toolName}: ${secret.name} (${lastUsedText})`);
  });
  
  const proceed = confirm(`Delete ${unusedSecrets.length} unused secrets?`);
  if (!proceed) {
    console.log('Cleanup cancelled');
    return { deleted: 0, errors: [] };
  }
  
  const results = await bulkDeleteSecrets(
    unusedSecrets.map(s => s.id),
    apiToken,
    orgId,
    userId
  );
  
  const deleted = results.filter(r => r.success).length;
  const errors = results.filter(r => !r.success);
  
  console.log(`Cleanup complete: ${deleted} unused secrets deleted`);
  return { deleted, errors };
}
```

## Recovery Options

### Restore From Backup
```javascript
async function listSecretBackups() {
  const backups = [];
  
  // Look through localStorage for backup keys
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key && key.startsWith('secret_backup_')) {
      try {
        const backupData = JSON.parse(localStorage.getItem(key));
        backups.push({
          backupKey: key,
          secretId: backupData.id,
          secretName: backupData.name,
          toolName: backupData.toolName,
          backedUpAt: backupData.backedUpAt,
          backedUpBy: backupData.backedUpBy
        });
      } catch (error) {
        console.warn(`Invalid backup data for key ${key}`);
      }
    }
  }
  
  return backups.sort((a, b) => new Date(b.backedUpAt) - new Date(a.backedUpAt));
}

async function restoreSecretFromBackup(backupKey, apiToken, orgId, userId) {
  const backupData = localStorage.getItem(backupKey);
  if (!backupData) {
    throw new Error('Backup not found');
  }
  
  const backup = JSON.parse(backupData);
  
  // Note: This creates a new secret entry since the original was deleted
  // The actual secret value would need to be provided separately
  console.warn('Note: Secret value must be provided separately - only metadata can be restored');
  
  const restoreData = {
    toolId: backup.toolId,
    name: backup.name + ' (Restored)',
    description: backup.description + ' - Restored from backup',
    secretType: backup.secretType,
    scope: backup.scope,
    metadata: {
      ...backup.metadata,
      restoredAt: new Date().toISOString(),
      restoredBy: userId,
      originalId: backup.id,
      restoredFromBackup: backupKey
    }
  };
  
  // This would create a new secret entry with the restored metadata
  console.log('Restore data prepared:', restoreData);
  return restoreData;
}
```

## Related Endpoints

- [Get Tool Secret](/api/endpoints/tools/secrets/get-tool-secret) - Retrieve secret details
- [List Tool Secrets](/api/endpoints/tools/secrets/list-tool-secrets) - View all stored secrets
- [Update Tool Secret](/api/endpoints/tools/secrets/update-tool-secret) - Update stored secret
- [List Tools](/api/endpoints/tools/list-tools) - View all tools