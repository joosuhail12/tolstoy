---
title: "List Tool Secrets"
api: "GET /tools/secrets"
description: "Retrieve stored credentials and secrets for all tools"
---

## Overview

The List Tool Secrets endpoint returns all stored credentials and secrets for tools within your organization. This endpoint provides visibility into which tools have stored credentials without exposing the sensitive values.

## Authentication

<ParamField header="x-org-id" type="string" required>
  Organization ID for multi-tenant access control
</ParamField>

<ParamField header="x-user-id" type="string" required>
  User ID of the requesting user for authorization
</ParamField>

<ParamField header="authorization" type="string" required>
  Bearer token for API authentication
</ParamField>

## Query Parameters

<ParamField query="toolId" type="string">
  Filter by specific tool ID
</ParamField>

<ParamField query="secretType" type="string">
  Filter by secret type: "api_key", "oauth_token", "database_url", "webhook_secret", "certificate"
</ParamField>

<ParamField query="status" type="string">
  Filter by secret status: "active", "expired", "revoked"
</ParamField>

<ParamField query="limit" type="number">
  Maximum number of secrets to return (1-100, defaults to 50)
</ParamField>

<ParamField query="offset" type="number">
  Number of secrets to skip for pagination (defaults to 0)
</ParamField>

## Response

**Status Code:** `200 OK`

<ResponseField name="toolSecrets" type="array">
  Array of tool secret objects (sensitive values are masked)
  
  <Expandable title="Tool Secret Object">
    <ResponseField name="id" type="string">
      Unique identifier for the secret
    </ResponseField>
    
    <ResponseField name="toolId" type="string">
      ID of the associated tool
    </ResponseField>
    
    <ResponseField name="toolName" type="string">
      Name of the tool
    </ResponseField>
    
    <ResponseField name="name" type="string">
      Human-readable name for the secret
    </ResponseField>
    
    <ResponseField name="secretType" type="string">
      Type of secret stored
    </ResponseField>
    
    <ResponseField name="status" type="string">
      Current status of the secret
    </ResponseField>
    
    <ResponseField name="keyHint" type="string">
      Masked version of the secret key/identifier (e.g., "sk_test_***...abc")
    </ResponseField>
    
    <ResponseField name="lastUsed" type="string">
      ISO timestamp when secret was last accessed
    </ResponseField>
    
    <ResponseField name="expiresAt" type="string">
      ISO timestamp when secret expires (null for non-expiring secrets)
    </ResponseField>
    
    <ResponseField name="createdAt" type="string">
      ISO timestamp when secret was stored
    </ResponseField>
    
    <ResponseField name="updatedAt" type="string">
      ISO timestamp when secret was last updated
    </ResponseField>
    
    <ResponseField name="metadata" type="object">
      Additional metadata about the secret (non-sensitive)
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="pagination" type="object">
  Pagination information
  
  <Expandable title="Pagination Object">
    <ResponseField name="total" type="number">
      Total number of tool secrets
    </ResponseField>
    
    <ResponseField name="count" type="number">
      Number of secrets returned in this response
    </ResponseField>
    
    <ResponseField name="offset" type="number">
      Current offset value
    </ResponseField>
    
    <ResponseField name="limit" type="number">
      Current limit value
    </ResponseField>
    
    <ResponseField name="hasMore" type="boolean">
      Whether there are more secrets to fetch
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="summary" type="object">
  Summary statistics
  
  <Expandable title="Summary Object">
    <ResponseField name="totalSecrets" type="number">
      Total number of secrets
    </ResponseField>
    
    <ResponseField name="activeSecrets" type="number">
      Number of active secrets
    </ResponseField>
    
    <ResponseField name="expiredSecrets" type="number">
      Number of expired secrets
    </ResponseField>
    
    <ResponseField name="expiringSecrets" type="number">
      Number of secrets expiring within 30 days
    </ResponseField>
  </Expandable>
</ResponseField>

## Error Responses

<ResponseField name="400" type="object">
  Bad Request - Invalid query parameters
</ResponseField>

## Usage Examples

<CodeGroup>

```bash cURL
curl -X GET "https://api.tolstoy.com/v1/tools/secrets" \
  -H "Authorization: Bearer $API_TOKEN" \
  -H "X-Org-ID: org_123456" \
  -H "X-User-ID: user_789012"
```

```bash cURL Filtered
curl -X GET "https://api.tolstoy.com/v1/tools/secrets?secretType=api_key&status=active" \
  -H "Authorization: Bearer $API_TOKEN" \
  -H "X-Org-ID: org_123456" \
  -H "X-User-ID: user_789012"
```

```javascript JavaScript
// List all tool secrets
const toolSecrets = await fetch('/api/v1/tools/secrets', {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${apiToken}`,
    'X-Org-ID': 'org_123456',
    'X-User-ID': 'user_789012'
  }
});

const secretsData = await toolSecrets.json();
console.log(`Found ${secretsData.summary.totalSecrets} total secrets`);
console.log(`Active: ${secretsData.summary.activeSecrets}, Expired: ${secretsData.summary.expiredSecrets}`);

secretsData.toolSecrets.forEach(secret => {
  const status = secret.status === 'active' ? '‚úÖ' : '‚ùå';
  console.log(`${status} ${secret.toolName}: ${secret.name} (${secret.secretType})`);
  console.log(`  Key hint: ${secret.keyHint}`);
  console.log(`  Last used: ${secret.lastUsed || 'Never'}`);
});

// Check for expiring secrets
const expiringSecrets = await fetch('/api/v1/tools/secrets', {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${apiToken}`,
    'X-Org-ID': 'org_123456',
    'X-User-ID': 'user_789012'
  }
});

const expiringData = await expiringSecrets.json();
const thirtyDaysFromNow = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);

const expiringSoon = expiringData.toolSecrets.filter(secret => {
  return secret.expiresAt && new Date(secret.expiresAt) <= thirtyDaysFromNow;
});

if (expiringSoon.length > 0) {
  console.log('Secrets expiring within 30 days:');
  expiringSoon.forEach(secret => {
    const daysUntilExpiry = Math.ceil((new Date(secret.expiresAt) - new Date()) / (1000 * 60 * 60 * 24));
    console.log(`‚ö†Ô∏è ${secret.toolName} - ${secret.name}: ${daysUntilExpiry} days`);
  });
}
```

```python Python
import requests
from datetime import datetime, timedelta

# List all tool secrets
response = requests.get(
    "https://api.tolstoy.com/v1/tools/secrets",
    headers={
        "Authorization": f"Bearer {api_token}",
        "X-Org-ID": "org_123456",
        "X-User-ID": "user_789012"
    }
)

if response.status_code == 200:
    data = response.json()
    print(f"Total secrets: {data['summary']['totalSecrets']}")
    print(f"Active: {data['summary']['activeSecrets']}")
    print(f"Expired: {data['summary']['expiredSecrets']}")
    print(f"Expiring soon: {data['summary']['expiringSecrets']}")
    
    for secret in data['toolSecrets']:
        status_emoji = "‚úÖ" if secret['status'] == 'active' else "‚ùå"
        print(f"{status_emoji} {secret['toolName']}: {secret['name']}")
        print(f"   Type: {secret['secretType']}")
        print(f"   Hint: {secret['keyHint']}")
        
        if secret.get('lastUsed'):
            last_used = datetime.fromisoformat(secret['lastUsed'].replace('Z', '+00:00'))
            days_since_used = (datetime.now(last_used.tzinfo) - last_used).days
            print(f"   Last used: {days_since_used} days ago")

# Filter by specific tool
tool_response = requests.get(
    "https://api.tolstoy.com/v1/tools/secrets",
    headers={
        "Authorization": f"Bearer {api_token}",
        "X-Org-ID": "org_123456",
        "X-User-ID": "user_789012"
    },
    params={
        "toolId": "tool_abc123",
        "status": "active"
    }
)

if tool_response.status_code == 200:
    tool_data = tool_response.json()
    print(f"Found {len(tool_data['toolSecrets'])} active secrets for tool")

# Check for unused secrets (not used in 90+ days)
all_secrets = data['toolSecrets']
unused_threshold = datetime.now() - timedelta(days=90)

unused_secrets = [
    secret for secret in all_secrets 
    if secret.get('lastUsed') and 
    datetime.fromisoformat(secret['lastUsed'].replace('Z', '+00:00')) < unused_threshold
]

if unused_secrets:
    print(f"Found {len(unused_secrets)} secrets unused for 90+ days:")
    for secret in unused_secrets:
        print(f"  - {secret['toolName']}: {secret['name']}")
```

</CodeGroup>

## Secret Management

### Security Audit
```javascript
async function performSecurityAudit(apiToken, orgId, userId) {
  const response = await fetch('/api/v1/tools/secrets', {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  const data = await response.json();
  const audit = {
    totalSecrets: data.summary.totalSecrets,
    securityIssues: [],
    recommendations: []
  };
  
  const now = new Date();
  const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
  const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
  const oneYearAgo = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
  
  data.toolSecrets.forEach(secret => {
    // Check for expired secrets
    if (secret.status === 'expired') {
      audit.securityIssues.push({
        type: 'expired_secret',
        secret: `${secret.toolName} - ${secret.name}`,
        severity: 'high',
        message: 'Secret has expired and may cause failures'
      });
    }
    
    // Check for secrets expiring soon
    if (secret.expiresAt) {
      const expiryDate = new Date(secret.expiresAt);
      const daysUntilExpiry = (expiryDate - now) / (1000 * 60 * 60 * 24);
      
      if (daysUntilExpiry <= 7 && daysUntilExpiry > 0) {
        audit.securityIssues.push({
          type: 'expiring_soon',
          secret: `${secret.toolName} - ${secret.name}`,
          severity: 'medium',
          message: `Secret expires in ${Math.ceil(daysUntilExpiry)} days`
        });
      }
    }
    
    // Check for unused secrets
    if (secret.lastUsed) {
      const lastUsedDate = new Date(secret.lastUsed);
      if (lastUsedDate < ninetyDaysAgo) {
        audit.securityIssues.push({
          type: 'unused_secret',
          secret: `${secret.toolName} - ${secret.name}`,
          severity: 'low',
          message: 'Secret has not been used in 90+ days'
        });
      }
    } else {
      audit.securityIssues.push({
        type: 'never_used',
        secret: `${secret.toolName} - ${secret.name}`,
        severity: 'low',
        message: 'Secret has never been used'
      });
    }
    
    // Check for old secrets
    const createdDate = new Date(secret.createdAt);
    if (createdDate < oneYearAgo) {
      audit.recommendations.push({
        type: 'rotate_old_secret',
        secret: `${secret.toolName} - ${secret.name}`,
        message: 'Consider rotating secret that is over 1 year old'
      });
    }
  });
  
  // Generate recommendations
  const highSeverityCount = audit.securityIssues.filter(issue => issue.severity === 'high').length;
  const mediumSeverityCount = audit.securityIssues.filter(issue => issue.severity === 'medium').length;
  
  if (highSeverityCount > 0) {
    audit.recommendations.push({
      type: 'urgent_action',
      message: `Address ${highSeverityCount} high-severity security issues immediately`
    });
  }
  
  if (mediumSeverityCount > 0) {
    audit.recommendations.push({
      type: 'scheduled_action',
      message: `Plan to address ${mediumSeverityCount} medium-severity issues within the next week`
    });
  }
  
  return audit;
}

// Usage
const audit = await performSecurityAudit(apiToken, 'org_123456', 'user_789012');
console.log('Security Audit Results:');
console.log(`Total secrets: ${audit.totalSecrets}`);
console.log(`Security issues: ${audit.securityIssues.length}`);

audit.securityIssues.forEach(issue => {
  const emoji = issue.severity === 'high' ? 'üî¥' : issue.severity === 'medium' ? 'üü°' : 'üîµ';
  console.log(`${emoji} ${issue.secret}: ${issue.message}`);
});
```

### Expiration Monitoring
```javascript
async function monitorSecretExpiration(apiToken, orgId, userId, daysThreshold = 30) {
  const response = await fetch('/api/v1/tools/secrets', {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  const data = await response.json();
  const threshold = new Date();
  threshold.setDate(threshold.getDate() + daysThreshold);
  
  const expiringSecrets = data.toolSecrets.filter(secret => {
    if (!secret.expiresAt) return false;
    const expiryDate = new Date(secret.expiresAt);
    return expiryDate <= threshold && expiryDate > new Date();
  });
  
  const expiredSecrets = data.toolSecrets.filter(secret => {
    if (!secret.expiresAt) return false;
    return new Date(secret.expiresAt) <= new Date();
  });
  
  return {
    expiringSoon: expiringSecrets.map(secret => ({
      id: secret.id,
      toolName: secret.toolName,
      secretName: secret.name,
      expiresAt: secret.expiresAt,
      daysUntilExpiry: Math.ceil((new Date(secret.expiresAt) - new Date()) / (1000 * 60 * 60 * 24))
    })),
    alreadyExpired: expiredSecrets.map(secret => ({
      id: secret.id,
      toolName: secret.toolName,
      secretName: secret.name,
      expiresAt: secret.expiresAt,
      daysExpired: Math.ceil((new Date() - new Date(secret.expiresAt)) / (1000 * 60 * 60 * 24))
    }))
  };
}
```

### Usage Analytics
```javascript
async function analyzeSecretUsage(apiToken, orgId, userId) {
  const response = await fetch('/api/v1/tools/secrets', {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  const data = await response.json();
  const analytics = {
    totalSecrets: data.summary.totalSecrets,
    byType: {},
    byStatus: {},
    usageStats: {
      neverUsed: 0,
      recentlyUsed: 0, // Last 7 days
      regularlyUsed: 0, // Used in last 30 days
      stale: 0 // Not used in 90+ days
    }
  };
  
  const now = new Date();
  const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
  const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
  const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);
  
  data.toolSecrets.forEach(secret => {
    // Count by type
    analytics.byType[secret.secretType] = (analytics.byType[secret.secretType] || 0) + 1;
    
    // Count by status
    analytics.byStatus[secret.status] = (analytics.byStatus[secret.status] || 0) + 1;
    
    // Analyze usage patterns
    if (!secret.lastUsed) {
      analytics.usageStats.neverUsed++;
    } else {
      const lastUsedDate = new Date(secret.lastUsed);
      if (lastUsedDate >= sevenDaysAgo) {
        analytics.usageStats.recentlyUsed++;
      } else if (lastUsedDate >= thirtyDaysAgo) {
        analytics.usageStats.regularlyUsed++;
      } else if (lastUsedDate < ninetyDaysAgo) {
        analytics.usageStats.stale++;
      }
    }
  });
  
  return analytics;
}
```

## Related Endpoints

- [Get Tool Secret](/api/endpoints/tools/secrets/get-tool-secret) - Retrieve specific secret details
- [Update Tool Secret](/api/endpoints/tools/secrets/update-tool-secret) - Update stored secret
- [Delete Tool Secret](/api/endpoints/tools/secrets/delete-tool-secret) - Remove stored secret
- [List Tools](/api/endpoints/tools/list-tools) - View all tools