---
title: "Get Tool Secret"
api: "GET /tools/secrets/{id}"
description: "Retrieve details about a specific stored tool secret"
---

## Overview

The Get Tool Secret endpoint retrieves detailed information about a specific stored tool secret. For security reasons, the actual secret values are masked, but metadata and usage information are provided.

## Authentication

<ParamField header="x-org-id" type="string" required>
  Organization ID for multi-tenant access control
</ParamField>

<ParamField header="x-user-id" type="string" required>
  User ID of the requesting user for authorization
</ParamField>

<ParamField header="authorization" type="string" required>
  Bearer token for API authentication
</ParamField>

## Path Parameters

<ParamField path="id" type="string" required>
  The unique identifier of the tool secret to retrieve
</ParamField>

## Query Parameters

<ParamField query="includeUsageHistory" type="boolean">
  Whether to include recent usage history (defaults to false)
</ParamField>

<ParamField query="includeMetadata" type="boolean">
  Whether to include extended metadata (defaults to true)
</ParamField>

## Response

**Status Code:** `200 OK`

<ResponseField name="id" type="string">
  Unique identifier for the secret
</ResponseField>

<ResponseField name="toolId" type="string">
  ID of the associated tool
</ResponseField>

<ResponseField name="toolName" type="string">
  Name of the associated tool
</ResponseField>

<ResponseField name="name" type="string">
  Human-readable name for the secret
</ResponseField>

<ResponseField name="description" type="string">
  Description of what this secret is used for
</ResponseField>

<ResponseField name="secretType" type="string">
  Type of secret: "api_key", "oauth_token", "database_url", "webhook_secret", "certificate"
</ResponseField>

<ResponseField name="status" type="string">
  Current status: "active", "expired", "revoked"
</ResponseField>

<ResponseField name="keyHint" type="string">
  Masked version of the secret key/identifier (e.g., "sk_test_***...abc")
</ResponseField>

<ResponseField name="scope" type="array">
  Permissions or scopes associated with this secret
</ResponseField>

<ResponseField name="lastUsed" type="string">
  ISO timestamp when secret was last accessed
</ResponseField>

<ResponseField name="usageCount" type="number">
  Total number of times this secret has been accessed
</ResponseField>

<ResponseField name="expiresAt" type="string">
  ISO timestamp when secret expires (null for non-expiring secrets)
</ResponseField>

<ResponseField name="createdAt" type="string">
  ISO timestamp when secret was stored
</ResponseField>

<ResponseField name="updatedAt" type="string">
  ISO timestamp when secret was last updated
</ResponseField>

<ResponseField name="createdBy" type="string">
  User ID who originally stored the secret
</ResponseField>

<ResponseField name="updatedBy" type="string">
  User ID who last updated the secret
</ResponseField>

<ResponseField name="metadata" type="object">
  Additional metadata about the secret
  
  <Expandable title="Metadata Object">
    <ResponseField name="environment" type="string">
      Environment this secret is used in (production, staging, development)
    </ResponseField>
    
    <ResponseField name="region" type="string">
      Geographic region or data center
    </ResponseField>
    
    <ResponseField name="tags" type="array">
      User-defined tags for organization
    </ResponseField>
    
    <ResponseField name="rotationSchedule" type="object">
      Automatic rotation configuration
    </ResponseField>
    
    <ResponseField name="alertSettings" type="object">
      Notification settings for this secret
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="usageHistory" type="array">
  Recent usage history (if includeUsageHistory=true)
  
  <Expandable title="Usage History Entry">
    <ResponseField name="timestamp" type="string">
      When the secret was accessed
    </ResponseField>
    
    <ResponseField name="context" type="string">
      Context of usage (workflow execution, API call, etc.)
    </ResponseField>
    
    <ResponseField name="success" type="boolean">
      Whether the secret was successfully used
    </ResponseField>
    
    <ResponseField name="source" type="string">
      Source of the access (workflow ID, user ID, etc.)
    </ResponseField>
  </Expandable>
</ResponseField>

## Error Responses

<ResponseField name="404" type="object">
  Not Found - Secret does not exist
</ResponseField>

<ResponseField name="403" type="object">
  Forbidden - Insufficient permissions to view this secret
</ResponseField>

## Usage Examples

<CodeGroup>

```bash cURL
curl -X GET "https://api.tolstoy.com/v1/tools/secrets/secret_abc123?includeUsageHistory=true" \
  -H "Authorization: Bearer $API_TOKEN" \
  -H "X-Org-ID: org_123456" \
  -H "X-User-ID: user_789012"
```

```javascript JavaScript
// Get basic secret details
const secret = await fetch('/api/v1/tools/secrets/secret_abc123', {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${apiToken}`,
    'X-Org-ID': 'org_123456',
    'X-User-ID': 'user_789012'
  }
});

const secretData = await secret.json();
console.log(`Secret: ${secretData.name} for ${secretData.toolName}`);
console.log(`Type: ${secretData.secretType}`);
console.log(`Status: ${secretData.status}`);
console.log(`Key hint: ${secretData.keyHint}`);
console.log(`Usage count: ${secretData.usageCount}`);

if (secretData.lastUsed) {
  const lastUsed = new Date(secretData.lastUsed);
  const daysAgo = Math.floor((new Date() - lastUsed) / (1000 * 60 * 60 * 24));
  console.log(`Last used: ${daysAgo} days ago`);
}

if (secretData.expiresAt) {
  const expiresAt = new Date(secretData.expiresAt);
  const daysUntilExpiry = Math.ceil((expiresAt - new Date()) / (1000 * 60 * 60 * 24));
  if (daysUntilExpiry > 0) {
    console.log(`Expires in: ${daysUntilExpiry} days`);
  } else {
    console.log(`Expired ${Math.abs(daysUntilExpiry)} days ago`);
  }
}

// Get secret with usage history
const secretWithHistory = await fetch('/api/v1/tools/secrets/secret_abc123?includeUsageHistory=true', {
  method: 'GET',
  headers: {
    'Authorization': `Bearer ${apiToken}`,
    'X-Org-ID': 'org_123456',
    'X-User-ID': 'user_789012'
  }
});

const historyData = await secretWithHistory.json();
if (historyData.usageHistory && historyData.usageHistory.length > 0) {
  console.log('Recent usage:');
  historyData.usageHistory.slice(0, 5).forEach(usage => {
    const status = usage.success ? '‚úÖ' : '‚ùå';
    console.log(`${status} ${usage.timestamp}: ${usage.context}`);
  });
}
```

```python Python
import requests
from datetime import datetime, timedelta

# Get secret details
response = requests.get(
    "https://api.tolstoy.com/v1/tools/secrets/secret_abc123",
    headers={
        "Authorization": f"Bearer {api_token}",
        "X-Org-ID": "org_123456",
        "X-User-ID": "user_789012"
    },
    params={
        "includeUsageHistory": True,
        "includeMetadata": True
    }
)

if response.status_code == 200:
    secret = response.json()
    print(f"Secret: {secret['name']}")
    print(f"Tool: {secret['toolName']}")
    print(f"Type: {secret['secretType']}")
    print(f"Status: {secret['status']}")
    print(f"Key hint: {secret['keyHint']}")
    print(f"Usage count: {secret['usageCount']}")
    
    # Check last usage
    if secret.get('lastUsed'):
        last_used = datetime.fromisoformat(secret['lastUsed'].replace('Z', '+00:00'))
        days_ago = (datetime.now(last_used.tzinfo) - last_used).days
        print(f"Last used: {days_ago} days ago")
    
    # Check expiration
    if secret.get('expiresAt'):
        expires_at = datetime.fromisoformat(secret['expiresAt'].replace('Z', '+00:00'))
        days_until_expiry = (expires_at - datetime.now(expires_at.tzinfo)).days
        
        if days_until_expiry > 0:
            print(f"Expires in: {days_until_expiry} days")
        else:
            print(f"Expired {abs(days_until_expiry)} days ago")
    
    # Show metadata
    if secret.get('metadata'):
        metadata = secret['metadata']
        print(f"Environment: {metadata.get('environment', 'N/A')}")
        if metadata.get('tags'):
            print(f"Tags: {', '.join(metadata['tags'])}")
    
    # Show recent usage history
    if secret.get('usageHistory'):
        print("\nRecent usage history:")
        for usage in secret['usageHistory'][:10]:  # Show last 10
            status_emoji = "‚úÖ" if usage['success'] else "‚ùå"
            timestamp = datetime.fromisoformat(usage['timestamp'].replace('Z', '+00:00'))
            print(f"  {status_emoji} {timestamp.strftime('%Y-%m-%d %H:%M')}: {usage['context']}")

else:
    print(f"Error: {response.status_code}")
    if response.status_code == 404:
        print("Secret not found")
    elif response.status_code == 403:
        print("Access denied")
```

</CodeGroup>

## Secret Analysis

### Health Check
```javascript
async function checkSecretHealth(secretId, apiToken, orgId, userId) {
  const response = await fetch(`/api/v1/tools/secrets/${secretId}?includeUsageHistory=true`, {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  if (!response.ok) {
    throw new Error('Failed to retrieve secret details');
  }
  
  const secret = await response.json();
  const health = {
    secretId: secret.id,
    secretName: secret.name,
    toolName: secret.toolName,
    status: secret.status,
    issues: [],
    recommendations: []
  };
  
  const now = new Date();
  
  // Check if secret is expired
  if (secret.status === 'expired') {
    health.issues.push({
      type: 'expired',
      severity: 'high',
      message: 'Secret has expired'
    });
  }
  
  // Check if secret is expiring soon
  if (secret.expiresAt) {
    const expiresAt = new Date(secret.expiresAt);
    const daysUntilExpiry = (expiresAt - now) / (1000 * 60 * 60 * 24);
    
    if (daysUntilExpiry <= 7 && daysUntilExpiry > 0) {
      health.issues.push({
        type: 'expiring_soon',
        severity: 'medium',
        message: `Secret expires in ${Math.ceil(daysUntilExpiry)} days`
      });
    }
  }
  
  // Check usage patterns
  if (!secret.lastUsed) {
    health.issues.push({
      type: 'never_used',
      severity: 'low',
      message: 'Secret has never been used'
    });
  } else {
    const lastUsed = new Date(secret.lastUsed);
    const daysSinceLastUse = (now - lastUsed) / (1000 * 60 * 60 * 24);
    
    if (daysSinceLastUse > 90) {
      health.issues.push({
        type: 'unused',
        severity: 'low',
        message: `Secret has not been used for ${Math.floor(daysSinceLastUse)} days`
      });
    }
  }
  
  // Check usage history for failures
  if (secret.usageHistory) {
    const recentFailures = secret.usageHistory
      .slice(0, 10) // Last 10 usages
      .filter(usage => !usage.success);
    
    if (recentFailures.length > 0) {
      health.issues.push({
        type: 'usage_failures',
        severity: 'medium',
        message: `${recentFailures.length} recent usage failures detected`
      });
    }
  }
  
  // Generate recommendations
  if (secret.status === 'expired' || (secret.expiresAt && new Date(secret.expiresAt) <= now)) {
    health.recommendations.push('Update or rotate the expired secret immediately');
  }
  
  if (secret.usageCount === 0) {
    health.recommendations.push('Consider removing unused secret to reduce security exposure');
  }
  
  const createdAt = new Date(secret.createdAt);
  const ageInDays = (now - createdAt) / (1000 * 60 * 60 * 24);
  
  if (ageInDays > 365) {
    health.recommendations.push('Consider rotating secret that is over 1 year old');
  }
  
  return health;
}

// Usage
const health = await checkSecretHealth('secret_abc123', apiToken, 'org_123456', 'user_789012');
console.log(`Health check for ${health.secretName}:`);
console.log(`Status: ${health.status}`);
console.log(`Issues: ${health.issues.length}`);
health.issues.forEach(issue => {
  const emoji = issue.severity === 'high' ? 'üî¥' : issue.severity === 'medium' ? 'üü°' : 'üîµ';
  console.log(`${emoji} ${issue.message}`);
});
```

### Usage Analytics
```javascript
async function analyzeSecretUsage(secretId, apiToken, orgId, userId) {
  const response = await fetch(`/api/v1/tools/secrets/${secretId}?includeUsageHistory=true`, {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  const secret = await response.json();
  const analytics = {
    secretId: secret.id,
    secretName: secret.name,
    totalUsage: secret.usageCount,
    usagePattern: {
      daily: 0,
      weekly: 0,
      monthly: 0,
      failures: 0,
      successRate: 0
    },
    trends: {
      increasingUsage: false,
      decreasingUsage: false,
      stable: false
    }
  };
  
  if (secret.usageHistory && secret.usageHistory.length > 0) {
    const now = new Date();
    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
    const oneWeekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
    const oneMonthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    
    // Count usage by time periods
    analytics.usagePattern.daily = secret.usageHistory.filter(usage => 
      new Date(usage.timestamp) >= oneDayAgo
    ).length;
    
    analytics.usagePattern.weekly = secret.usageHistory.filter(usage => 
      new Date(usage.timestamp) >= oneWeekAgo
    ).length;
    
    analytics.usagePattern.monthly = secret.usageHistory.filter(usage => 
      new Date(usage.timestamp) >= oneMonthAgo
    ).length;
    
    // Calculate success rate
    const totalRecent = secret.usageHistory.slice(0, 50); // Last 50 usages
    const failures = totalRecent.filter(usage => !usage.success).length;
    analytics.usagePattern.failures = failures;
    analytics.usagePattern.successRate = totalRecent.length > 0 
      ? ((totalRecent.length - failures) / totalRecent.length * 100).toFixed(1)
      : 0;
    
    // Analyze trends (compare first half vs second half of recent history)
    if (totalRecent.length >= 10) {
      const firstHalf = totalRecent.slice(Math.floor(totalRecent.length / 2));
      const secondHalf = totalRecent.slice(0, Math.floor(totalRecent.length / 2));
      
      const firstHalfAverage = firstHalf.length;
      const secondHalfAverage = secondHalf.length;
      
      if (secondHalfAverage > firstHalfAverage * 1.2) {
        analytics.trends.increasingUsage = true;
      } else if (secondHalfAverage < firstHalfAverage * 0.8) {
        analytics.trends.decreasingUsage = true;
      } else {
        analytics.trends.stable = true;
      }
    }
  }
  
  return analytics;
}
```

### Security Assessment
```javascript
async function assessSecretSecurity(secretId, apiToken, orgId, userId) {
  const response = await fetch(`/api/v1/tools/secrets/${secretId}?includeMetadata=true`, {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  const secret = await response.json();
  const assessment = {
    secretId: secret.id,
    riskLevel: 'low', // low, medium, high, critical
    securityScore: 100, // 0-100
    vulnerabilities: [],
    recommendations: []
  };
  
  let score = 100;
  
  // Check age of secret
  const createdAt = new Date(secret.createdAt);
  const ageInDays = (new Date() - createdAt) / (1000 * 60 * 60 * 24);
  
  if (ageInDays > 365) {
    assessment.vulnerabilities.push({
      type: 'old_secret',
      severity: 'medium',
      message: `Secret is ${Math.floor(ageInDays)} days old`
    });
    score -= 15;
  }
  
  // Check expiration status
  if (secret.status === 'expired') {
    assessment.vulnerabilities.push({
      type: 'expired',
      severity: 'critical',
      message: 'Secret has expired'
    });
    score -= 50;
  } else if (secret.expiresAt) {
    const daysUntilExpiry = (new Date(secret.expiresAt) - new Date()) / (1000 * 60 * 60 * 24);
    if (daysUntilExpiry <= 30) {
      assessment.vulnerabilities.push({
        type: 'expiring_soon',
        severity: 'high',
        message: `Secret expires in ${Math.ceil(daysUntilExpiry)} days`
      });
      score -= 25;
    }
  }
  
  // Check usage frequency
  if (secret.usageCount > 10000) {
    assessment.vulnerabilities.push({
      type: 'high_usage',
      severity: 'medium',
      message: 'Secret has very high usage count - consider rotation'
    });
    score -= 10;
  }
  
  // Check for rotation schedule
  const metadata = secret.metadata || {};
  if (!metadata.rotationSchedule) {
    assessment.vulnerabilities.push({
      type: 'no_rotation_schedule',
      severity: 'low',
      message: 'No automatic rotation schedule configured'
    });
    score -= 5;
  }
  
  // Determine risk level based on score
  assessment.securityScore = Math.max(0, score);
  
  if (score >= 80) {
    assessment.riskLevel = 'low';
  } else if (score >= 60) {
    assessment.riskLevel = 'medium';
  } else if (score >= 40) {
    assessment.riskLevel = 'high';
  } else {
    assessment.riskLevel = 'critical';
  }
  
  // Generate recommendations
  assessment.vulnerabilities.forEach(vuln => {
    switch (vuln.type) {
      case 'expired':
        assessment.recommendations.push('Replace expired secret immediately');
        break;
      case 'expiring_soon':
        assessment.recommendations.push('Schedule secret rotation before expiration');
        break;
      case 'old_secret':
        assessment.recommendations.push('Consider rotating old secret as security best practice');
        break;
      case 'high_usage':
        assessment.recommendations.push('Implement regular rotation for heavily used secrets');
        break;
      case 'no_rotation_schedule':
        assessment.recommendations.push('Configure automatic rotation schedule');
        break;
    }
  });
  
  return assessment;
}
```

## Related Endpoints

- [List Tool Secrets](/api/endpoints/tools/secrets/list-tool-secrets) - View all stored secrets
- [Update Tool Secret](/api/endpoints/tools/secrets/update-tool-secret) - Update stored secret
- [Delete Tool Secret](/api/endpoints/tools/secrets/delete-tool-secret) - Remove stored secret
- [List Tools](/api/endpoints/tools/list-tools) - View all tools