---
title: "Update Tool Secret"
api: "PUT /tools/secrets/{id}"
description: "Update a stored tool secret or its metadata"
---

## Overview

The Update Tool Secret endpoint allows you to modify stored credentials, update metadata, or rotate secrets while maintaining security best practices. This endpoint supports both complete secret replacement and metadata-only updates.

## Authentication

<ParamField header="x-org-id" type="string" required>
  Organization ID for multi-tenant access control
</ParamField>

<ParamField header="x-user-id" type="string" required>
  User ID of the requesting user for authorization
</ParamField>

<ParamField header="authorization" type="string" required>
  Bearer token for API authentication
</ParamField>

## Path Parameters

<ParamField path="id" type="string" required>
  The unique identifier of the tool secret to update
</ParamField>

## Request Body

<ParamField body="secretValue" type="string">
  The new secret value (will be encrypted and stored securely)
</ParamField>

<ParamField body="name" type="string">
  Human-readable name for the secret
</ParamField>

<ParamField body="description" type="string">
  Description of what this secret is used for
</ParamField>

<ParamField body="secretType" type="string">
  Type of secret: "api_key", "oauth_token", "database_url", "webhook_secret", "certificate"
</ParamField>

<ParamField body="scope" type="array">
  Permissions or scopes associated with this secret
</ParamField>

<ParamField body="expiresAt" type="string">
  ISO timestamp when secret should expire (null for non-expiring)
</ParamField>

<ParamField body="metadata" type="object">
  Additional metadata for the secret
  
  <Expandable title="Metadata Options">
    <ParamField body="environment" type="string">
      Environment this secret is used in (production, staging, development)
    </ParamField>
    
    <ParamField body="region" type="string">
      Geographic region or data center
    </ParamField>
    
    <ParamField body="tags" type="array">
      User-defined tags for organization and filtering
    </ParamField>
    
    <ParamField body="rotationSchedule" type="object">
      Automatic rotation configuration
    </ParamField>
    
    <ParamField body="alertSettings" type="object">
      Notification settings for expiration and usage alerts
    </ParamField>
    
    <ParamField body="customFields" type="object">
      Additional custom metadata fields
    </ParamField>
  </Expandable>
</ParamField>

## Response

**Status Code:** `200 OK`

<ResponseField name="id" type="string">
  Unique identifier for the secret
</ResponseField>

<ResponseField name="toolId" type="string">
  ID of the associated tool
</ResponseField>

<ResponseField name="name" type="string">
  Human-readable name for the secret
</ResponseField>

<ResponseField name="description" type="string">
  Description of the secret's purpose
</ResponseField>

<ResponseField name="secretType" type="string">
  Type of secret stored
</ResponseField>

<ResponseField name="status" type="string">
  Current status of the secret
</ResponseField>

<ResponseField name="keyHint" type="string">
  Masked version of the secret (e.g., "sk_***...abc")
</ResponseField>

<ResponseField name="scope" type="array">
  Permissions or scopes associated with this secret
</ResponseField>

<ResponseField name="expiresAt" type="string">
  ISO timestamp when secret expires
</ResponseField>

<ResponseField name="updatedAt" type="string">
  ISO timestamp when secret was last updated
</ResponseField>

<ResponseField name="updatedBy" type="string">
  User ID who updated the secret
</ResponseField>

<ResponseField name="metadata" type="object">
  Updated metadata for the secret
</ResponseField>

## Error Responses

<ResponseField name="400" type="object">
  Bad Request - Invalid secret data or validation failed
  
  <Expandable title="Error Schema">
    <ResponseField name="error" type="string">
      Error type identifier
    </ResponseField>
    <ResponseField name="message" type="string">
      Human-readable error description
    </ResponseField>
    <ResponseField name="details" type="object">
      Field-specific validation errors
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="404" type="object">
  Not Found - Secret does not exist
</ResponseField>

<ResponseField name="422" type="object">
  Unprocessable Entity - Secret validation failed
</ResponseField>

## Usage Examples

<CodeGroup>

```bash cURL Update Secret Value
curl -X PUT "https://api.tolstoy.com/v1/tools/secrets/secret_abc123" \
  -H "Authorization: Bearer $API_TOKEN" \
  -H "X-Org-ID: org_123456" \
  -H "X-User-ID: user_789012" \
  -H "Content-Type: application/json" \
  -d '{
    "secretValue": "new_api_key_value_12345",
    "metadata": {
      "rotatedAt": "2024-01-15T10:30:00Z",
      "rotationReason": "scheduled_rotation"
    }
  }'
```

```bash cURL Update Metadata Only
curl -X PUT "https://api.tolstoy.com/v1/tools/secrets/secret_abc123" \
  -H "Authorization: Bearer $API_TOKEN" \
  -H "X-Org-ID: org_123456" \
  -H "X-User-ID: user_789012" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Updated API Key Name",
    "description": "Updated description for the API key",
    "metadata": {
      "tags": ["production", "critical", "updated"],
      "environment": "production",
      "alertSettings": {
        "expirationWarningDays": 14
      }
    }
  }'
```

```javascript JavaScript
// Rotate secret with new value
const rotateSecret = await fetch('/api/v1/tools/secrets/secret_abc123', {
  method: 'PUT',
  headers: {
    'Authorization': `Bearer ${apiToken}`,
    'X-Org-ID': 'org_123456',
    'X-User-ID': 'user_789012',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    secretValue: 'rotated_secret_value_98765',
    expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(), // 1 year
    metadata: {
      rotatedAt: new Date().toISOString(),
      rotationType: 'manual',
      rotationReason: 'security_audit',
      previousKeyHash: 'sha256:abc123...' // For audit trail
    }
  })
});

if (rotateSecret.ok) {
  const updatedSecret = await rotateSecret.json();
  console.log('Secret rotated successfully:', updatedSecret.id);
  console.log('New key hint:', updatedSecret.keyHint);
} else {
  const error = await rotateSecret.json();
  console.error('Rotation failed:', error.message);
}

// Update only metadata and settings
const updateMetadata = await fetch('/api/v1/tools/secrets/secret_def456', {
  method: 'PUT',
  headers: {
    'Authorization': `Bearer ${apiToken}`,
    'X-Org-ID': 'org_123456',
    'X-User-ID': 'user_789012',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    name: 'Production Database Connection',
    description: 'Main production database credentials',
    metadata: {
      environment: 'production',
      region: 'us-east-1',
      tags: ['database', 'critical', 'production'],
      rotationSchedule: {
        enabled: true,
        intervalDays: 90,
        nextRotation: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString()
      },
      alertSettings: {
        expirationWarningDays: 30,
        unusedSecretWarningDays: 60,
        notificationChannels: ['email', 'slack']
      },
      customFields: {
        department: 'engineering',
        criticality: 'high',
        backupLocation: 'vault-backup-001'
      }
    }
  })
});

const metadataResult = await updateMetadata.json();
console.log('Metadata updated:', metadataResult.name);
```

```python Python
import requests
from datetime import datetime, timedelta

# Rotate secret with new value and expiration
new_expiration = datetime.now() + timedelta(days=365)
rotation_data = {
    "secretValue": "new_rotated_api_key_67890",
    "expiresAt": new_expiration.isoformat() + "Z",
    "metadata": {
        "rotatedAt": datetime.now().isoformat() + "Z",
        "rotationType": "scheduled",
        "rotationReason": "annual_security_rotation",
        "environment": "production",
        "tags": ["rotated", "2024", "production"]
    }
}

response = requests.put(
    "https://api.tolstoy.com/v1/tools/secrets/secret_abc123",
    headers={
        "Authorization": f"Bearer {api_token}",
        "X-Org-ID": "org_123456",
        "X-User-ID": "user_789012",
        "Content-Type": "application/json"
    },
    json=rotation_data
)

if response.status_code == 200:
    secret = response.json()
    print(f"Secret rotated: {secret['name']}")
    print(f"New key hint: {secret['keyHint']}")
    print(f"Expires: {secret['expiresAt']}")
else:
    error = response.json()
    print(f"Rotation failed: {error['message']}")

# Update secret scope and metadata
scope_update = {
    "scope": ["read", "write", "admin"],
    "name": "Enhanced Admin API Key",
    "description": "API key with enhanced permissions for admin operations",
    "metadata": {
        "permissionLevel": "admin",
        "grantedBy": "user_789012",
        "grantedAt": datetime.now().isoformat() + "Z",
        "reviewDate": (datetime.now() + timedelta(days=90)).isoformat() + "Z",
        "alertSettings": {
            "expirationWarningDays": 14,
            "unusedSecretWarningDays": 30
        }
    }
}

scope_response = requests.put(
    "https://api.tolstoy.com/v1/tools/secrets/secret_def456",
    headers={
        "Authorization": f"Bearer {api_token}",
        "X-Org-ID": "org_123456",
        "X-User-ID": "user_789012",
        "Content-Type": "application/json"
    },
    json=scope_update
)

if scope_response.status_code == 200:
    updated_secret = scope_response.json()
    print(f"Updated secret scope: {', '.join(updated_secret['scope'])}")
```

</CodeGroup>

## Update Scenarios

### Secret Rotation
```javascript
async function rotateSecret(secretId, newSecretValue, apiToken, orgId, userId) {
  // First get current secret details
  const currentResponse = await fetch(`/api/v1/tools/secrets/${secretId}`, {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  if (!currentResponse.ok) {
    throw new Error('Failed to retrieve current secret');
  }
  
  const currentSecret = await currentResponse.json();
  
  // Create backup of current secret info (without the actual value)
  const rotationMetadata = {
    ...currentSecret.metadata,
    rotationHistory: [
      ...(currentSecret.metadata?.rotationHistory || []),
      {
        rotatedAt: new Date().toISOString(),
        rotatedBy: userId,
        reason: 'manual_rotation',
        previousKeyHint: currentSecret.keyHint
      }
    ].slice(-10) // Keep only last 10 rotations
  };
  
  // Update with new secret value
  const rotationResponse = await fetch(`/api/v1/tools/secrets/${secretId}`, {
    method: 'PUT',
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      secretValue: newSecretValue,
      metadata: rotationMetadata
    })
  });
  
  if (!rotationResponse.ok) {
    const error = await rotationResponse.json();
    throw new Error(`Rotation failed: ${error.message}`);
  }
  
  return rotationResponse.json();
}
```

### Batch Update Multiple Secrets
```javascript
async function batchUpdateSecrets(updates, apiToken, orgId, userId) {
  const results = [];
  
  for (const update of updates) {
    try {
      const response = await fetch(`/api/v1/tools/secrets/${update.secretId}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${apiToken}`,
          'X-Org-ID': orgId,
          'X-User-ID': userId,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(update.data)
      });
      
      const result = await response.json();
      results.push({
        secretId: update.secretId,
        success: response.ok,
        data: result
      });
      
      // Rate limiting delay
      await new Promise(resolve => setTimeout(resolve, 100));
      
    } catch (error) {
      results.push({
        secretId: update.secretId,
        success: false,
        error: error.message
      });
    }
  }
  
  return results;
}

// Usage
const updates = [
  {
    secretId: 'secret_123',
    data: {
      metadata: {
        tags: ['production', 'rotated'],
        rotatedAt: new Date().toISOString()
      }
    }
  },
  {
    secretId: 'secret_456',
    data: {
      expiresAt: new Date(Date.now() + 180 * 24 * 60 * 60 * 1000).toISOString() // 6 months
    }
  }
];

const results = await batchUpdateSecrets(updates, apiToken, 'org_123456', 'user_789012');
console.log(`Updated ${results.filter(r => r.success).length}/${results.length} secrets`);
```

### Configure Automatic Rotation
```javascript
async function configureAutoRotation(secretId, intervalDays, apiToken, orgId, userId) {
  const nextRotation = new Date();
  nextRotation.setDate(nextRotation.getDate() + intervalDays);
  
  const response = await fetch(`/api/v1/tools/secrets/${secretId}`, {
    method: 'PUT',
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      metadata: {
        rotationSchedule: {
          enabled: true,
          intervalDays: intervalDays,
          nextRotation: nextRotation.toISOString(),
          autoRotate: true,
          notifyBeforeRotation: true,
          notificationDays: 7
        },
        alertSettings: {
          rotationStarted: true,
          rotationCompleted: true,
          rotationFailed: true,
          notificationChannels: ['email', 'webhook']
        }
      }
    })
  });
  
  return response.json();
}

// Configure 90-day rotation
await configureAutoRotation('secret_abc123', 90, apiToken, 'org_123456', 'user_789012');
```

## Validation and Security

### Pre-update Validation
```javascript
async function validateSecretUpdate(secretId, updateData, apiToken, orgId, userId) {
  const validationIssues = [];
  
  // Check if secret exists
  const currentResponse = await fetch(`/api/v1/tools/secrets/${secretId}`, {
    headers: {
      'Authorization': `Bearer ${apiToken}`,
      'X-Org-ID': orgId,
      'X-User-ID': userId
    }
  });
  
  if (!currentResponse.ok) {
    validationIssues.push('Secret not found or access denied');
    return validationIssues;
  }
  
  const currentSecret = await currentResponse.json();
  
  // Validate secret value if provided
  if (updateData.secretValue) {
    if (updateData.secretValue.length < 8) {
      validationIssues.push('Secret value must be at least 8 characters long');
    }
    
    if (updateData.secretValue === currentSecret.keyHint) {
      validationIssues.push('New secret value appears to match current value');
    }
  }
  
  // Validate expiration date
  if (updateData.expiresAt) {
    const expirationDate = new Date(updateData.expiresAt);
    if (expirationDate <= new Date()) {
      validationIssues.push('Expiration date must be in the future');
    }
    
    // Warn if expiration is too far in the future
    const maxFutureDate = new Date();
    maxFutureDate.setFullYear(maxFutureDate.getFullYear() + 2);
    if (expirationDate > maxFutureDate) {
      validationIssues.push('Warning: Expiration date is more than 2 years in the future');
    }
  }
  
  // Validate scope changes
  if (updateData.scope) {
    const validScopes = ['read', 'write', 'admin', 'delete'];
    const invalidScopes = updateData.scope.filter(scope => !validScopes.includes(scope));
    if (invalidScopes.length > 0) {
      validationIssues.push(`Invalid scopes: ${invalidScopes.join(', ')}`);
    }
  }
  
  return validationIssues;
}
```

### Audit Trail
```javascript
async function createAuditTrail(secretId, updateType, updateData, apiToken, orgId, userId) {
  const auditEntry = {
    timestamp: new Date().toISOString(),
    secretId: secretId,
    userId: userId,
    orgId: orgId,
    action: 'secret_updated',
    updateType: updateType, // 'value_rotation', 'metadata_update', 'expiration_change'
    changes: {
      // Only log non-sensitive changes
      nameChanged: updateData.name ? true : false,
      descriptionChanged: updateData.description ? true : false,
      expirationChanged: updateData.expiresAt ? true : false,
      scopeChanged: updateData.scope ? true : false,
      metadataChanged: updateData.metadata ? true : false,
      valueRotated: updateData.secretValue ? true : false
    },
    metadata: {
      userAgent: navigator.userAgent,
      ipAddress: 'client_ip_address', // Would be filled server-side
      sessionId: 'session_id'
    }
  };
  
  // Store audit entry (this would typically be handled server-side)
  console.log('Audit trail entry:', auditEntry);
  
  // You might also want to add this to the secret's metadata
  const currentMetadata = updateData.metadata || {};
  const auditHistory = currentMetadata.auditHistory || [];
  
  auditHistory.push(auditEntry);
  
  // Keep only last 50 audit entries
  if (auditHistory.length > 50) {
    auditHistory.splice(0, auditHistory.length - 50);
  }
  
  return {
    ...updateData,
    metadata: {
      ...currentMetadata,
      auditHistory: auditHistory
    }
  };
}
```

## Related Endpoints

- [Get Tool Secret](/api/endpoints/tools/secrets/get-tool-secret) - Retrieve secret details
- [List Tool Secrets](/api/endpoints/tools/secrets/list-tool-secrets) - View all stored secrets
- [Delete Tool Secret](/api/endpoints/tools/secrets/delete-tool-secret) - Remove stored secret
- [List Tools](/api/endpoints/tools/list-tools) - View all tools