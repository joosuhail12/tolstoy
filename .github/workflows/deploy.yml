name: Tolstoy CI/CD Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch: # Allow manual triggering

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîë Setup SSH key
        run: |
          echo "${{ secrets.EC2_KEY }}" | base64 -d > ssh_key.pem
          chmod 600 ssh_key.pem
          
      - name: üîç Debug secrets
        run: |
          echo "Checking secret availability..."
          echo "EC2_USER length: ${#EC2_USER}"
          echo "EC2_HOST length: ${#EC2_HOST}" 
          echo "EC2_PATH length: ${#EC2_PATH}"
          echo "EC2_KEY length: ${#EC2_KEY}"
          if [ -z "$EC2_USER" ] || [ -z "$EC2_HOST" ]; then
            echo "‚ùå Required secrets are missing!"
            echo "Please verify that EC2_USER, EC2_HOST, EC2_KEY, and EC2_PATH are set in GitHub repository secrets"
            exit 1
          fi
        env:
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          EC2_PATH: ${{ secrets.EC2_PATH }}
          EC2_KEY: ${{ secrets.EC2_KEY }}
          
      - name: ‚úÖ Test SSH connection
        run: |
          ssh -o StrictHostKeyChecking=no -i ssh_key.pem "${EC2_USER}@${EC2_HOST}" "echo 'SSH connection successful'"
        env:
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          
      - name: üöÄ Deploy application to EC2
        run: |
          ssh -o StrictHostKeyChecking=no -i ssh_key.pem "${EC2_USER}@${EC2_HOST}" << 'DEPLOY_SCRIPT'
            set -e
            
            echo "üîÑ Navigating to application directory..."
            cd /home/ubuntu/tolstoy
            
            echo "üì• Pulling latest code from GitHub..."
            # Stash any local changes to avoid merge conflicts
            git stash push -u -m "Auto-stash before deployment $(date)"
            git pull origin main
            # Note: We don't pop the stash as deployment should use the latest repo code
            
            echo "üì¶ Installing dependencies..."
            yarn install --production=false
            
            echo "üì¶ Installing missing peer dependencies..."
            yarn add rxjs@^7.1.0
            
            echo "‚öôÔ∏è Generating Prisma client..."
            yarn db:generate
            
            echo "üî® Building application..."
            yarn build
            
            echo "üîÑ Updating PM2 configuration..."
            # Ensure PM2 ecosystem file has correct environment
            echo 'module.exports = {' > ecosystem.config.js
            echo '  apps: [{' >> ecosystem.config.js
            echo '    name: "tolstoy-api",' >> ecosystem.config.js
            echo '    script: "dist/main.js",' >> ecosystem.config.js
            echo '    cwd: "/home/ubuntu/tolstoy",' >> ecosystem.config.js
            echo '    env: {' >> ecosystem.config.js
            echo '      NODE_ENV: "production",' >> ecosystem.config.js
            echo '      PORT: 3000,' >> ecosystem.config.js
            echo '      AWS_REGION: "us-east-1",' >> ecosystem.config.js
            echo '      AWS_SECRET_NAME: "conductor-db-secret",' >> ecosystem.config.js
            echo '      USE_AWS_SECRETS: "true"' >> ecosystem.config.js
            echo '    },' >> ecosystem.config.js
            echo '    instances: 1,' >> ecosystem.config.js
            echo '    autorestart: true,' >> ecosystem.config.js
            echo '    watch: false,' >> ecosystem.config.js
            echo '    max_memory_restart: "1G",' >> ecosystem.config.js
            echo '    error_file: "/home/ubuntu/logs/tolstoy-error.log",' >> ecosystem.config.js
            echo '    out_file: "/home/ubuntu/logs/tolstoy-out.log",' >> ecosystem.config.js
            echo '    log_file: "/home/ubuntu/logs/tolstoy-combined.log",' >> ecosystem.config.js
            echo '    time: true' >> ecosystem.config.js
            echo '  }]' >> ecosystem.config.js
            echo '};' >> ecosystem.config.js
            
            echo "üîÑ Restarting PM2 application..."
            # Aggressive cleanup - kill all Node processes and PM2
            pm2 kill 2>/dev/null || true
            pkill -9 -f "node" 2>/dev/null || true
            pkill -9 -f "tolstoy" 2>/dev/null || true
            pkill -9 -f "dist/main.js" 2>/dev/null || true
            sleep 3
            
            # Clear old logs
            rm -rf /home/ubuntu/logs/tolstoy-*
            mkdir -p /home/ubuntu/logs
            
            # Fresh PM2 start
            pm2 start ecosystem.config.js
            pm2 save
            
            echo "üìä PM2 status..."
            pm2 status
            
            echo "‚úÖ Deployment completed successfully!"
          DEPLOY_SCRIPT
        env:
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          
      - name: üóÉÔ∏è Run database migrations (optional)
        run: |
          ssh -o StrictHostKeyChecking=no -i ssh_key.pem "${EC2_USER}@${EC2_HOST}" << 'MIGRATION_SCRIPT'
            set -e
            cd /home/ubuntu/tolstoy
            
            echo "üóÉÔ∏è Running Prisma migrations..."
            # Fetch database URLs from AWS Secrets Manager for Prisma CLI
            SECRET_JSON=$(aws secretsmanager get-secret-value --secret-id conductor-db-secret --region us-east-1 --query 'SecretString' --output text)
            export DATABASE_URL=$(echo $SECRET_JSON | grep -o '"DATABASE_URL":"[^"]*' | cut -d'"' -f4)
            export DIRECT_URL=$(echo $SECRET_JSON | grep -o '"DIRECT_URL":"[^"]*' | cut -d'"' -f4 || echo $DATABASE_URL)
            
            echo "‚úÖ Database URLs configured for Prisma"
            timeout 30 yarn db:migrate:deploy || echo "‚ö†Ô∏è Migration completed or timed out (this is normal if no new migrations)"
            
            echo "‚úÖ Migration step completed!"
          MIGRATION_SCRIPT
        env:
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          
      - name: üîç Comprehensive deployment verification
        run: |
          echo "üîç Starting comprehensive deployment verification..."
          
          # Check PM2 status and logs
          echo "üìä Checking PM2 application status..."
          ssh -o StrictHostKeyChecking=no -i ssh_key.pem ${EC2_USER}@${EC2_HOST} "
            echo '=== PM2 Status ==='
            pm2 status
            echo ''
            echo '=== Recent Logs (last 20 lines) ==='
            pm2 logs tolstoy-api --lines 20 --raw
          " || echo "‚ö†Ô∏è PM2 status check completed with warnings"
          
          # Wait for application startup with progressive checks
          echo "‚è≥ Waiting for application to fully initialize..."
          for i in {1..12}; do
            echo "Startup check $i/12..."
            
            # Check if port is listening
            PORT_STATUS=$(ssh -o StrictHostKeyChecking=no -i ssh_key.pem ${EC2_USER}@${EC2_HOST} "ss -tlnp | grep :3000" || echo "not_listening")
            
            if [[ "$PORT_STATUS" != "not_listening" ]]; then
              echo "‚úÖ Port 3000 is listening"
              break
            fi
            
            if [ $i -eq 12 ]; then
              echo "‚ùå Application failed to start listening on port 3000 after 60 seconds"
              ssh -o StrictHostKeyChecking=no -i ssh_key.pem ${EC2_USER}@${EC2_HOST} "pm2 logs tolstoy-api --lines 50"
              exit 1
            fi
            
            sleep 5
          done
          
          # Progressive health checks
          echo "üè• Running progressive health checks..."
          
          # Basic health endpoint
          for i in {1..6}; do
            echo "Health check attempt $i/6..."
            HEALTH_CHECK=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 http://${EC2_HOST}/health)
            
            if [ "$HEALTH_CHECK" -eq 200 ]; then
              echo "‚úÖ Basic health check passed (HTTP $HEALTH_CHECK)"
              break
            elif [ $i -eq 6 ]; then
              echo "‚ùå Basic health check failed after 6 attempts (HTTP $HEALTH_CHECK)"
              echo "Application response:"
              curl -s --connect-timeout 10 --max-time 30 http://${EC2_HOST}/health || echo "No response"
              exit 1
            fi
            
            sleep 10
          done
          
          # Status endpoint check
          echo "üìä Testing comprehensive status endpoint..."
          STATUS_CHECK=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 http://${EC2_HOST}/status)
          
          if [ "$STATUS_CHECK" -eq 200 ]; then
            echo "‚úÖ Status endpoint check passed (HTTP $STATUS_CHECK)"
            
            # Get detailed status for verification
            STATUS_RESPONSE=$(curl -s --connect-timeout 10 --max-time 30 http://${EC2_HOST}/status)
            echo "Status response preview: $(echo "$STATUS_RESPONSE" | jq -c . 2>/dev/null || echo "$STATUS_RESPONSE" | head -c 200)"
          else
            echo "‚ùå Status endpoint check failed (HTTP $STATUS_CHECK)"
            curl -s --connect-timeout 10 --max-time 30 http://${EC2_HOST}/status || echo "No response from status endpoint"
            exit 1
          fi
          
          # Version endpoint check (new endpoint)
          echo "üîñ Testing version endpoint..."
          VERSION_CHECK=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 http://${EC2_HOST}/version)
          
          if [ "$VERSION_CHECK" -eq 200 ]; then
            echo "‚úÖ Version endpoint check passed (HTTP $VERSION_CHECK)"
            VERSION_RESPONSE=$(curl -s --connect-timeout 10 --max-time 30 http://${EC2_HOST}/version)
            echo "Version info: $(echo "$VERSION_RESPONSE" | jq -c . 2>/dev/null || echo "$VERSION_RESPONSE")"
          else
            echo "‚ö†Ô∏è Version endpoint check failed (HTTP $VERSION_CHECK) - this is non-critical"
          fi
          
          # Detailed health endpoint check
          echo "üîç Testing detailed health endpoint..."
          DETAILED_HEALTH_CHECK=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 http://${EC2_HOST}/status/detailed)
          
          if [ "$DETAILED_HEALTH_CHECK" -eq 200 ]; then
            echo "‚úÖ Detailed health check passed (HTTP $DETAILED_HEALTH_CHECK)"
            DETAILED_RESPONSE=$(curl -s --connect-timeout 10 --max-time 30 http://${EC2_HOST}/status/detailed)
            echo "Database status: $(echo "$DETAILED_RESPONSE" | jq -r '.database.status' 2>/dev/null || echo "unknown")"
            echo "Redis status: $(echo "$DETAILED_RESPONSE" | jq -r '.redis.status' 2>/dev/null || echo "unknown")"
          else
            echo "‚ö†Ô∏è Detailed health check failed (HTTP $DETAILED_HEALTH_CHECK) - this may indicate service issues"
          fi
          
          # API endpoints smoke test
          echo "üß™ Running API endpoints smoke test..."
          
          # Test a few key endpoints (should return 401 without auth, which is expected)
          for endpoint in "/flows" "/actions" "/organizations"; do
            ENDPOINT_CHECK=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 http://${EC2_HOST}${endpoint})
            if [ "$ENDPOINT_CHECK" -eq 401 ] || [ "$ENDPOINT_CHECK" -eq 400 ]; then
              echo "‚úÖ Endpoint ${endpoint} is responding correctly (HTTP $ENDPOINT_CHECK - auth required)"
            else
              echo "‚ö†Ô∏è Endpoint ${endpoint} returned unexpected status: HTTP $ENDPOINT_CHECK"
            fi
          done
          
          # Final verification summary
          echo ""
          echo "üéâ Comprehensive deployment verification completed!"
          echo "‚úÖ Application is running and responding to requests"
          echo "‚úÖ Core endpoints are accessible"
          echo "‚úÖ Health monitoring is functional"
        env:
          EC2_USER: ${{ secrets.EC2_USER }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          
      - name: üßπ Cleanup SSH key
        if: always()
        run: |
          rm -f ssh_key.pem
          echo "üßπ SSH key cleaned up"
          
      - name: üì¢ Deployment summary
        if: success()
        run: |
          echo "üéâ DEPLOYMENT SUCCESSFUL!"
          echo "üìä Summary:"
          echo "  ‚Ä¢ Repository: ${{ github.repository }}"
          echo "  ‚Ä¢ Branch: ${{ github.ref_name }}"
          echo "  ‚Ä¢ Commit: ${{ github.sha }}"
          echo "  ‚Ä¢ Target: ${EC2_HOST}"
          echo "  ‚Ä¢ Health: http://${EC2_HOST}/health"
          echo "  ‚Ä¢ Status: http://${EC2_HOST}/status"
        env:
          EC2_HOST: ${{ secrets.EC2_HOST }}