---
title: "GitHub to Slack Integration Tutorial"
description: "Build a comprehensive GitHub to Slack notification system that keeps your team informed about repository activity, pull requests, and deployments."
---

# GitHub to Slack Integration Tutorial

In this tutorial, you'll build a sophisticated GitHub to Slack integration that automatically notifies your team about important repository events. This workflow demonstrates conditional logic, data transformation, and multi-channel notifications.

## What You'll Build

A smart notification system that:

1. **Monitors GitHub events** (PRs, pushes, releases, issues)
2. **Filters relevant notifications** based on importance and team preferences
3. **Formats messages** with rich information and actionable links
4. **Routes notifications** to appropriate Slack channels
5. **Handles different event types** with customized messaging

```mermaid
graph LR
    A[GitHub Event] --> B[Parse Event Type]
    B --> C{High Priority?}
    C -->|Yes| D[Format Rich Message]
    C -->|No| E[Format Simple Message]
    D --> F[#dev-alerts Channel]
    E --> G[#dev-activity Channel]
    F --> H[Add Thread Context]
    G --> I[Log Activity]
```

## Prerequisites

Before starting this tutorial, ensure you have:

<CardGroup cols={2}>
  <Card title="Tolstoy Setup" icon="check">
    ‚úÖ Tolstoy account with API access  
    ‚úÖ Organization and user credentials configured  
    ‚úÖ Basic familiarity with workflow concepts
  </Card>
  <Card title="External Services" icon="plug">
    ‚úÖ GitHub repository with admin access  
    ‚úÖ Slack workspace with bot permissions  
    ‚úÖ Ability to configure webhooks
  </Card>
</CardGroup>

<Info>
**Estimated Time**: 30-45 minutes to complete the full tutorial
</Info>

## Step 1: Set Up GitHub Integration

First, we'll configure GitHub to send webhooks to Tolstoy.

### Create GitHub Webhook Tool

1. **Navigate to Tools** in your Tolstoy dashboard
2. **Click "Add Tool"** and select "Webhook Receiver"
3. **Configure the webhook tool**:

```json
{
  "name": "GitHub Repository Webhook",
  "type": "webhook",
  "description": "Receives events from GitHub repository",
  "config": {
    "method": "POST",
    "path": "/webhooks/github-events",
    "authentication": "secret",
    "secret_header": "X-Hub-Signature-256",
    "content_type": "application/json"
  },
  "settings": {
    "validate_signature": true,
    "allowed_origins": ["github.com"],
    "max_payload_size": "10MB"
  }
}
```

4. **Copy the webhook URL** - you'll need this for GitHub configuration

### Configure GitHub Repository

1. **Go to your GitHub repository** ‚Üí Settings ‚Üí Webhooks
2. **Click "Add webhook"**
3. **Configure the webhook**:

<CodeGroup>
```json Webhook Configuration
{
  "payload_url": "https://tolstoy.getpullse.com/webhooks/github-events",
  "content_type": "application/json",
  "secret": "your-webhook-secret-here",
  "events": [
    "pull_request",
    "push", 
    "release",
    "issues",
    "issue_comment",
    "pull_request_review"
  ]
}
```

```bash GitHub CLI Alternative
gh api repos/OWNER/REPO/hooks \
  --method POST \
  --field name=web \
  --field active=true \
  --field "events[]=pull_request" \
  --field "events[]=push" \
  --field "events[]=release" \
  --field "events[]=issues" \
  --field "config[url]=https://tolstoy.getpullse.com/webhooks/github-events" \
  --field "config[content_type]=json" \
  --field "config[secret]=your-webhook-secret-here"
```
</CodeGroup>

4. **Test the webhook** by creating a test issue or PR

## Step 2: Set Up Slack Integration

Now let's configure Slack to receive our formatted notifications.

### Create Slack Bot Application

1. **Go to [api.slack.com/apps](https://api.slack.com/apps)**
2. **Click "Create New App"** ‚Üí "From scratch"
3. **Name your app** "GitHub Notifications Bot"
4. **Add Bot Token Scopes**:
   - `chat:write` - Send messages to channels
   - `chat:write.public` - Send messages to channels bot isn't in
   - `channels:read` - List public channels
   - `groups:read` - List private channels

### Configure Slack Tool in Tolstoy

```json
{
  "name": "Team Slack Workspace", 
  "type": "slack",
  "description": "Main workspace for team communications",
  "config": {
    "base_url": "https://slack.com/api",
    "auth_type": "bearer",
    "timeout_ms": 15000
  },
  "credentials": {
    "bot_token": "xoxb-your-bot-token-here"
  },
  "settings": {
    "workspace": "your-team",
    "default_channel": "#dev-activity",
    "bot_name": "GitHub Bot",
    "bot_icon": ":github:"
  }
}
```

## Step 3: Create Processing Actions

Let's create reusable actions for processing GitHub events and formatting Slack messages.

### GitHub Event Parser Action

```json
{
  "key": "parse-github-event",
  "name": "Parse GitHub Event",
  "description": "Extracts and standardizes GitHub webhook event data",
  "inputSchema": [
    {
      "name": "event_type",
      "type": "string",
      "required": true,
      "description": "GitHub event type from X-GitHub-Event header"
    },
    {
      "name": "payload",
      "type": "object", 
      "required": true,
      "description": "GitHub webhook payload"
    }
  ],
  "logic": {
    "type": "javascript",
    "code": `
      function parseGitHubEvent(eventType, payload) {
        const common = {
          event_type: eventType,
          repository: payload.repository?.full_name,
          sender: payload.sender?.login,
          timestamp: new Date().toISOString()
        };

        switch (eventType) {
          case 'pull_request':
            return {
              ...common,
              action: payload.action,
              pr_number: payload.number,
              pr_title: payload.pull_request.title,
              pr_url: payload.pull_request.html_url,
              pr_state: payload.pull_request.state,
              author: payload.pull_request.user.login,
              base_branch: payload.pull_request.base.ref,
              head_branch: payload.pull_request.head.ref,
              is_draft: payload.pull_request.draft,
              priority: payload.pull_request.draft ? 'low' : 'medium'
            };

          case 'push':
            return {
              ...common,
              ref: payload.ref,
              branch: payload.ref.replace('refs/heads/', ''),
              commits: payload.commits.length,
              commit_messages: payload.commits.map(c => c.message),
              compare_url: payload.compare,
              is_main_branch: payload.ref.includes('main') || payload.ref.includes('master'),
              priority: payload.ref.includes('main') || payload.ref.includes('master') ? 'high' : 'low'
            };

          case 'release':
            return {
              ...common,
              action: payload.action,
              release_name: payload.release.name,
              release_tag: payload.release.tag_name,
              release_url: payload.release.html_url,
              is_prerelease: payload.release.prerelease,
              priority: payload.release.prerelease ? 'medium' : 'high'
            };

          case 'issues':
            return {
              ...common,
              action: payload.action,
              issue_number: payload.issue.number,
              issue_title: payload.issue.title,
              issue_url: payload.issue.html_url,
              labels: payload.issue.labels.map(l => l.name),
              has_urgent_label: payload.issue.labels.some(l => 
                ['urgent', 'critical', 'p0'].includes(l.name.toLowerCase())
              ),
              priority: payload.issue.labels.some(l => 
                ['urgent', 'critical', 'p0'].includes(l.name.toLowerCase())
              ) ? 'high' : 'low'
            };

          default:
            return {
              ...common,
              priority: 'low'
            };
        }
      }

      return parseGitHubEvent(inputs.event_type, inputs.payload);
    `
  }
}
```

### Slack Message Formatter Action

```json
{
  "key": "format-github-slack-message", 
  "name": "Format GitHub Slack Message",
  "description": "Creates rich Slack messages for GitHub events",
  "inputSchema": [
    {
      "name": "event_data",
      "type": "object",
      "required": true,
      "description": "Parsed GitHub event data"
    }
  ],
  "logic": {
    "type": "javascript", 
    "code": `
      function formatSlackMessage(eventData) {
        const { event_type, repository, sender } = eventData;
        
        let blocks = [];
        let text = '';
        let color = '#808080';
        let channel = '#dev-activity';

        switch (event_type) {
          case 'pull_request':
            const { action, pr_title, pr_url, pr_number, author, base_branch, is_draft } = eventData;
            color = is_draft ? '#yellow' : (action === 'opened' ? '#36a64f' : '#ff9500');
            channel = eventData.priority === 'high' ? '#dev-alerts' : '#dev-activity';
            
            text = \`PR \${action}: \${pr_title}\`;
            
            blocks = [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": \`üìã *Pull Request \${action}*\\n<\${pr_url}|#\${pr_number} \${pr_title}>\`
                }
              },
              {
                "type": "context",
                "elements": [
                  {
                    "type": "mrkdwn",
                    "text": \`üë§ *\${author}* ‚Ä¢ üìÅ *\${repository}* ‚Ä¢ üåø \${base_branch} ‚Üê \${eventData.head_branch}\`
                  }
                ]
              }
            ];

            if (is_draft) {
              blocks.push({
                "type": "context",
                "elements": [{"type": "mrkdwn", "text": "üìù *Draft PR*"}]
              });
            }
            break;

          case 'push':
            const { branch, commits, compare_url, is_main_branch } = eventData;
            color = is_main_branch ? '#ff0000' : '#36a64f';
            channel = is_main_branch ? '#dev-alerts' : '#dev-activity';
            
            text = \`\${commits} commit\${commits > 1 ? 's' : ''} pushed to \${branch}\`;
            
            blocks = [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": \`üöÄ *\${commits} commit\${commits > 1 ? 's' : ''} pushed to \\\`\${branch}\\\`*\\n<\${compare_url}|View changes>\`
                }
              },
              {
                "type": "context", 
                "elements": [
                  {
                    "type": "mrkdwn",
                    "text": \`üë§ *\${sender}* ‚Ä¢ üìÅ *\${repository}*\`
                  }
                ]
              }
            ];

            if (commits <= 3) {
              const commitsList = eventData.commit_messages.slice(0, 3)
                .map(msg => \`‚Ä¢ \${msg.split('\\n')[0]}\`)
                .join('\\n');
              
              blocks.push({
                "type": "section",
                "text": {
                  "type": "mrkdwn", 
                  "text": \`*Recent commits:*\\n\${commitsList}\`
                }
              });
            }
            break;

          case 'release':
            const { action: releaseAction, release_name, release_tag, release_url, is_prerelease } = eventData;
            color = is_prerelease ? '#ff9500' : '#36a64f';
            channel = '#dev-alerts';
            
            text = \`Release \${releaseAction}: \${release_name}\`;
            
            blocks = [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": \`üéâ *Release \${releaseAction}*\\n<\${release_url}|\${release_name} (\${release_tag})>\`
                }
              },
              {
                "type": "context",
                "elements": [
                  {
                    "type": "mrkdwn", 
                    "text": \`üë§ *\${sender}* ‚Ä¢ üìÅ *\${repository}*\${is_prerelease ? ' ‚Ä¢ ‚ö†Ô∏è *Pre-release*' : ''}\`
                  }
                ]
              }
            ];
            break;

          case 'issues':
            const { action: issueAction, issue_title, issue_url, issue_number, labels, has_urgent_label } = eventData;
            color = has_urgent_label ? '#ff0000' : '#36a64f';
            channel = has_urgent_label ? '#dev-alerts' : '#dev-activity';
            
            text = \`Issue \${issueAction}: \${issue_title}\`;
            
            blocks = [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": \`üêõ *Issue \${issueAction}*\\n<\${issue_url}|#\${issue_number} \${issue_title}>\`
                }
              },
              {
                "type": "context",
                "elements": [
                  {
                    "type": "mrkdwn",
                    "text": \`üë§ *\${sender}* ‚Ä¢ üìÅ *\${repository}*\`
                  }
                ]
              }
            ];

            if (labels.length > 0) {
              blocks.push({
                "type": "context",
                "elements": [
                  {
                    "type": "mrkdwn",
                    "text": \`üè∑Ô∏è \${labels.map(l => \\\`\${l}\\\`).join(', ')}\`
                  }
                ]
              });
            }
            break;
        }

        return {
          channel,
          text,
          blocks,
          color,
          unfurl_links: false,
          unfurl_media: false
        };
      }

      return formatSlackMessage(inputs.event_data);
    `
  }
}
```

## Step 4: Build the Main Workflow

Now let's create the main workflow that ties everything together.

### Create GitHub to Slack Workflow

```json
{
  "name": "GitHub to Slack Notifications",
  "description": "Intelligent GitHub event processing with contextual Slack notifications",
  "version": 1,
  "trigger": {
    "type": "webhook",
    "tool_id": "your-github-webhook-tool-id"
  },
  "inputs": [
    {
      "name": "event_type",
      "type": "string",
      "source": "headers.X-GitHub-Event",
      "required": true,
      "description": "GitHub event type"
    },
    {
      "name": "payload",
      "type": "object", 
      "source": "body",
      "required": true,
      "description": "GitHub webhook payload"
    }
  ],
  "steps": [
    {
      "key": "validate-webhook",
      "name": "Validate GitHub Webhook",
      "action": "validate-github-signature",
      "inputs": {
        "signature": "{{headers.X-Hub-Signature-256}}",
        "payload": "{{raw_body}}",
        "secret": "{{secrets.github_webhook_secret}}"
      },
      "onError": {
        "action": "log-security-alert",
        "inputs": {
          "message": "Invalid GitHub webhook signature",
          "source_ip": "{{headers.X-Forwarded-For}}",
          "severity": "high"
        }
      }
    },
    {
      "key": "parse-event",
      "name": "Parse GitHub Event",
      "action": "parse-github-event",
      "inputs": {
        "event_type": "{{workflow.inputs.event_type}}",
        "payload": "{{workflow.inputs.payload}}"
      },
      "executeIf": "{{steps.validate-webhook.output.valid}} == true"
    },
    {
      "key": "check-filters",
      "name": "Apply Event Filters", 
      "action": "evaluate-conditions",
      "inputs": {
        "conditions": [
          {
            "name": "skip_bot_events",
            "condition": "{{steps.parse-event.output.sender}} != 'dependabot[bot]'",
            "description": "Skip automated bot events"
          },
          {
            "name": "skip_draft_prs",
            "condition": "!({{workflow.inputs.event_type}} == 'pull_request' && {{steps.parse-event.output.is_draft}} == true && {{steps.parse-event.output.action}} == 'opened')",
            "description": "Skip draft PR creation notifications"  
          },
          {
            "name": "include_main_branch_only",
            "condition": "{{workflow.inputs.event_type}} != 'push' || {{steps.parse-event.output.is_main_branch}} == true",
            "description": "Only notify for pushes to main branch"
          }
        ]
      }
    },
    {
      "key": "format-message",
      "name": "Format Slack Message",
      "action": "format-github-slack-message", 
      "inputs": {
        "event_data": "{{steps.parse-event.output}}"
      },
      "executeIf": "{{steps.check-filters.output.all_conditions_passed}} == true"
    },
    {
      "key": "send-notification",
      "name": "Send Slack Notification",
      "tool": "your-slack-tool-id",
      "method": "POST",
      "endpoint": "/chat.postMessage",
      "inputs": {
        "channel": "{{steps.format-message.output.channel}}",
        "text": "{{steps.format-message.output.text}}",
        "blocks": "{{steps.format-message.output.blocks}}",
        "attachments": [
          {
            "color": "{{steps.format-message.output.color}}",
            "fallback": "{{steps.format-message.output.text}}"
          }
        ],
        "unfurl_links": false,
        "unfurl_media": false
      },
      "executeIf": "{{steps.format-message.output.channel}} != null",
      "onError": {
        "action": "log-notification-failure",
        "inputs": {
          "error": "{{error.message}}",
          "event_type": "{{workflow.inputs.event_type}}",
          "repository": "{{steps.parse-event.output.repository}}"
        }
      }
    },
    {
      "key": "add-thread-context",
      "name": "Add Thread Context for High Priority",
      "tool": "your-slack-tool-id", 
      "method": "POST",
      "endpoint": "/chat.postMessage",
      "inputs": {
        "channel": "{{steps.format-message.output.channel}}",
        "thread_ts": "{{steps.send-notification.output.ts}}",
        "text": "Priority: {{steps.parse-event.output.priority}} | Repository: {{steps.parse-event.output.repository}}"
      },
      "executeIf": "{{steps.parse-event.output.priority}} == 'high' && {{steps.send-notification.output.ok}} == true"
    },
    {
      "key": "log-activity",
      "name": "Log GitHub Activity",
      "action": "create-activity-log",
      "inputs": {
        "event_type": "{{workflow.inputs.event_type}}",
        "repository": "{{steps.parse-event.output.repository}}",
        "sender": "{{steps.parse-event.output.sender}}",
        "priority": "{{steps.parse-event.output.priority}}",
        "notification_sent": "{{steps.send-notification.output.ok}}",
        "channel": "{{steps.format-message.output.channel}}",
        "timestamp": "{{now}}"
      }
    }
  ],
  "settings": {
    "timeout": 30000,
    "retryPolicy": {
      "maxRetries": 2,
      "retryDelay": 1000
    },
    "errorHandling": "continue"
  }
}
```

## Step 5: Test Your Integration

Let's test the workflow with various GitHub events.

### Test Event Types

<CodeGroup>

```bash Test Pull Request
# Create a test PR in your repository
gh pr create \
  --title "Test PR for Tolstoy Integration" \
  --body "Testing our GitHub to Slack workflow" \
  --base main \
  --head test-branch
```

```bash Test Release
# Create a test release
gh release create v1.0.1 \
  --title "Test Release v1.0.1" \
  --notes "Testing release notifications"
```

```bash Test Issue
# Create a test issue with labels
gh issue create \
  --title "Test Issue for Integration" \
  --body "Testing issue notifications" \
  --label "bug,urgent"
```

</CodeGroup>

### Monitor Execution

1. **Check Tolstoy Dashboard** for workflow executions
2. **Verify Slack Notifications** in appropriate channels
3. **Review Execution Logs** for any errors or improvements

Expected results:
- ‚úÖ Pull requests appear in #dev-activity with formatted messages
- ‚úÖ Main branch pushes appear in #dev-alerts with commit details  
- ‚úÖ Releases appear in #dev-alerts with proper formatting
- ‚úÖ Urgent issues appear in #dev-alerts with label context

## Step 6: Advanced Enhancements

### Add Team Mentions for Critical Events

```yaml
# Add this step after format-message
- key: "add-team-mentions"
  name: "Add Team Mentions for Critical Events"
  action: "format-team-mentions"
  inputs:
    priority: "{{steps.parse-event.output.priority}}"
    event_type: "{{workflow.inputs.event_type}}"
    labels: "{{steps.parse-event.output.labels}}"
  executeIf: "{{steps.parse-event.output.priority}} == 'high'"
```

### Create Event Summary Dashboard

```yaml
# Add this step to track metrics
- key: "update-metrics"
  name: "Update GitHub Activity Metrics"
  action: "increment-counter"
  inputs:
    metric: "github_events_total"
    labels:
      event_type: "{{workflow.inputs.event_type}}"
      repository: "{{steps.parse-event.output.repository}}"
      priority: "{{steps.parse-event.output.priority}}"
```

### Add Smart Filtering Based on Time

```yaml
# Add business hours filtering
- key: "check-business-hours"
  name: "Check Business Hours"
  action: "evaluate-business-hours"
  inputs:
    timezone: "America/New_York"
    business_hours: "9:00-17:00"
    business_days: ["monday", "tuesday", "wednesday", "thursday", "friday"]
  executeIf: "{{steps.parse-event.output.priority}} == 'low'"
```

## Troubleshooting

### Common Issues

<Accordion title="Slack notifications not appearing">
**Check these items:**
1. Verify Slack bot token has correct permissions
2. Ensure bot is added to target channels
3. Check channel names are correct (include # prefix)
4. Verify workspace URL is correct

**Debug step:**
```bash
tolstoy actions execute send-slack-message '{
  "channel": "#dev-activity",
  "text": "Test message",
  "blocks": []
}'
```
</Accordion>

<Accordion title="GitHub webhook not triggering workflow">
**Possible causes:**
1. Webhook URL is incorrect or not accessible
2. Webhook secret doesn't match configuration
3. GitHub event types not properly configured

**Verify webhook:**
```bash
# Check recent webhook deliveries in GitHub
curl -H "Authorization: token YOUR_TOKEN" \
  https://api.github.com/repos/OWNER/REPO/hooks/HOOK_ID/deliveries
```
</Accordion>

<Accordion title="Event parsing errors">
**Common mistakes:**
1. GitHub event structure changes
2. Missing null checks in parsing logic
3. Incorrect property access

**Test parsing:**
```bash
tolstoy actions execute parse-github-event '{
  "event_type": "pull_request",
  "payload": {...}
}'
```
</Accordion>

## Next Steps: Extend Your Integration

### Additional GitHub Events

Add support for more GitHub events:

- **Deployment status** - Track deployment success/failure
- **Check runs** - Monitor CI/CD pipeline status  
- **Review comments** - Notify on code review feedback
- **Branch protection** - Alert on protection rule changes

### Advanced Slack Features

Enhance your Slack integration:

- **Interactive buttons** - Add "Approve PR" or "Deploy" buttons
- **Scheduled summaries** - Daily/weekly activity digests
- **Thread management** - Group related notifications
- **User mentions** - Notify specific team members based on PR reviewers

### Integration with Other Tools

Extend the workflow to other platforms:

- **Jira Integration** - Create tickets for urgent issues
- **PagerDuty** - Escalate critical production releases
- **Email Notifications** - Backup notifications for critical events
- **Microsoft Teams** - Alternative notification channel

## Best Practices Learned

Through building this integration, you've learned:

1. **Event-driven architecture** - How to build reactive workflows
2. **Conditional logic** - Smart filtering and routing based on context
3. **Data transformation** - Converting between different API formats
4. **Error handling** - Graceful failure management
5. **Security practices** - Webhook signature validation
6. **Monitoring** - Activity logging and metrics tracking

<CardGroup cols={2}>
  <Card title="Build Another Integration" icon="plus" href="/product/tutorials/database-report-automation">
    Try a data processing workflow next
  </Card>
  <Card title="Explore Advanced Patterns" icon="graduation-cap" href="/product/workflows/advanced-patterns">
    Learn complex workflow techniques
  </Card>
</CardGroup>

---

<Info>
**Congratulations!** You've built a production-ready GitHub to Slack integration. This workflow can handle hundreds of events per day and provides a solid foundation for team communication automation.
</Info>