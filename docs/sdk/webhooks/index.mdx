---
title: Webhooks
sidebar_position: 8
---

# Webhooks

Manage webhook integrations for event-driven automation in your Tolstoy platform. Webhooks enable real-time communication between your workflows and external systems.

## Overview

Webhook management enables you to:
- **Create event-driven workflows** that trigger on external events
- **Implement real-time integrations** with third-party services
- **Handle webhook security** with signature verification and authentication
- **Monitor webhook reliability** with delivery tracking and retry mechanisms
- **Build scalable event architectures** with proper error handling

## Webhook Methods

### Discovery & Management
- **[listWebhooks()](list-webhooks)** - List all webhooks with delivery statistics and configuration details
- **[createWebhook()](create-webhook)** - Create new webhooks with event filtering and security configuration

## Quick Examples

### List Active Webhooks
```typescript
const webhooks = await client.listWebhooks();

webhooks.data.forEach(webhook => {
  console.log(`${webhook.name} - ${webhook.status}`);
  console.log(`URL: ${webhook.url}`);
  console.log(`Events: ${webhook.events.join(', ')}`);
  console.log(`Success Rate: ${webhook.metrics.successRate}%`);
});
```

### Create Event Webhook
```typescript
const orderWebhook = await client.createWebhook({
  name: 'Order Processing Webhook',
  url: 'https://api.company.com/webhooks/orders',
  events: ['order.created', 'order.updated', 'order.cancelled'],
  description: 'Process order events in real-time',
  headers: {
    'Content-Type': 'application/json',
    'X-Source': 'Tolstoy'
  },
  security: {
    method: 'signature',
    secret: '{{secret:webhook-secret}}',
    algorithm: 'sha256'
  },
  retryPolicy: {
    maxRetries: 3,
    backoffMultiplier: 2,
    initialDelay: 1000
  }
});

console.log(`Created webhook: ${orderWebhook.data.name}`);
```

### Create Workflow Trigger Webhook
```typescript
const triggerWebhook = await client.createWebhook({
  name: 'Customer Onboarding Trigger',
  url: 'https://internal.company.com/trigger-workflow',
  events: ['user.created'],
  filters: {
    'user.plan': ['pro', 'enterprise'],
    'user.status': 'active'
  },
  transformation: {
    template: {
      customerId: '{{event.user.id}}',
      plan: '{{event.user.plan}}',
      timestamp: '{{event.timestamp}}'
    }
  },
  timeout: 30000
});
```

## Common Use Cases

### Real-time Order Processing
Handle e-commerce order events:

```typescript
async function setupOrderProcessing() {
  const orderWebhook = await client.createWebhook({
    name: 'E-commerce Order Handler',
    url: 'https://fulfillment.company.com/webhook',
    events: [
      'order.created',
      'order.paid',
      'order.shipped',
      'order.delivered',
      'order.cancelled',
      'order.refunded'
    ],
    filters: {
      'order.status': ['paid', 'processing'],
      'order.total': { gte: 0 }
    },
    transformation: {
      template: {
        orderId: '{{event.order.id}}',
        customerEmail: '{{event.order.customer.email}}',
        items: '{{event.order.items}}',
        total: '{{event.order.total}}',
        timestamp: '{{event.timestamp}}'
      }
    },
    security: {
      method: 'bearer',
      token: '{{secret:fulfillment-token}}'
    }
  });
  
  return orderWebhook;
}
```

### Customer Lifecycle Automation
Trigger workflows based on customer actions:

```typescript
async function setupCustomerLifecycle() {
  const lifecycleWebhook = await client.createWebhook({
    name: 'Customer Lifecycle Automation',
    url: 'https://automation.company.com/customer-events',
    events: [
      'customer.registered',
      'customer.verified',
      'customer.subscription_started',
      'customer.subscription_cancelled',
      'customer.support_ticket_created'
    ],
    filters: {
      'customer.segment': ['high_value', 'enterprise']
    },
    transformation: {
      template: {
        customerId: '{{event.customer.id}}',
        eventType: '{{event.type}}',
        segment: '{{event.customer.segment}}',
        metadata: {
          plan: '{{event.customer.plan}}',
          mrr: '{{event.customer.mrr}}',
          lastActivity: '{{event.customer.lastActivity}}'
        }
      }
    },
    retryPolicy: {
      maxRetries: 5,
      backoffMultiplier: 1.5,
      initialDelay: 2000,
      maxDelay: 30000
    }
  });
  
  return lifecycleWebhook;
}
```

### System Integration Events
Connect different systems through webhooks:

```typescript
async function setupSystemIntegration() {
  const integrationWebhook = await client.createWebhook({
    name: 'CRM-ERP Integration',
    url: 'https://integration-hub.company.com/sync',
    events: [
      'contact.created',
      'contact.updated',
      'deal.won',
      'deal.lost',
      'invoice.generated'
    ],
    transformation: {
      template: {
        sourceSystem: 'tolstoy',
        targetSystem: 'erp',
        entityType: '{{event.entity}}',
        entityId: '{{event.id}}',
        changes: '{{event.changes}}',
        timestamp: '{{event.timestamp}}'
      }
    },
    headers: {
      'X-Integration-Source': 'Tolstoy',
      'X-Integration-Target': 'ERP',
      'Content-Type': 'application/json'
    }
  });
  
  return integrationWebhook;
}
```

## Integration Patterns

### Webhook Router
Route events to different endpoints based on content:

```typescript
class WebhookRouter {
  async createRoutingWebhook() {
    return await client.createWebhook({
      name: 'Event Router',
      url: 'https://router.company.com/events',
      events: ['*'], // All events
      transformation: {
        code: `
          function transform(event) {
            const routes = {
              'order.*': 'https://fulfillment.company.com/webhook',
              'customer.*': 'https://crm.company.com/webhook',
              'payment.*': 'https://billing.company.com/webhook'
            };
            
            for (const [pattern, url] of Object.entries(routes)) {
              if (event.type.match(pattern.replace('*', '.*'))) {
                return {
                  ...event,
                  routeTo: url
                };
              }
            }
            
            return event;
          }
        `
      }
    });
  }
}
```

### Webhook Aggregator
Batch multiple events before sending:

```typescript
async function createBatchingWebhook() {
  return await client.createWebhook({
    name: 'Event Batcher',
    url: 'https://analytics.company.com/batch-events',
    events: ['user.action', 'page.view', 'button.click'],
    batching: {
      enabled: true,
      maxEvents: 100,
      maxWaitTime: 30000, // 30 seconds
      flushOnShutdown: true
    },
    transformation: {
      template: {
        batch: '{{events}}',
        batchSize: '{{events.length}}',
        firstEvent: '{{events[0].timestamp}}',
        lastEvent: '{{events[-1].timestamp}}'
      }
    }
  });
}
```

### Webhook Filter Pipeline
Apply complex filtering logic:

```typescript
async function createFilteredWebhook() {
  return await client.createWebhook({
    name: 'High Value Customer Events',
    url: 'https://vip.company.com/webhook',
    events: ['customer.*', 'order.*'],
    filters: {
      code: `
        function filter(event) {
          // Only process high-value customers
          if (event.customer && event.customer.ltv < 10000) {
            return false;
          }
          
          // Only process large orders
          if (event.order && event.order.total < 1000) {
            return false;
          }
          
          // Skip test events
          if (event.customer && event.customer.email.includes('@test.')) {
            return false;
          }
          
          return true;
        }
      `
    }
  });
}
```

## Advanced Features

### Webhook Security Implementation
```typescript
async function createSecureWebhook() {
  const secureWebhook = await client.createWebhook({
    name: 'Secure Payment Webhook',
    url: 'https://secure-payments.company.com/webhook',
    events: ['payment.*'],
    security: {
      method: 'hmac',
      secret: '{{secret:payment-webhook-secret}}',
      algorithm: 'sha256',
      headers: {
        signature: 'X-Tolstoy-Signature',
        timestamp: 'X-Tolstoy-Timestamp'
      }
    },
    verification: {
      enabled: true,
      toleranceSeconds: 300, // 5 minutes
      rejectOldEvents: true
    }
  });
  
  return secureWebhook;
}
```

### Webhook Monitoring Dashboard
```typescript
async function monitorWebhooks() {
  const webhooks = await client.listWebhooks();
  const dashboard = {
    total: webhooks.data.length,
    active: 0,
    failing: [],
    metrics: {
      totalDeliveries: 0,
      successfulDeliveries: 0,
      failedDeliveries: 0
    }
  };
  
  webhooks.data.forEach(webhook => {
    if (webhook.status === 'active') {
      dashboard.active++;
    }
    
    const metrics = webhook.metrics;
    dashboard.metrics.totalDeliveries += metrics.totalDeliveries;
    dashboard.metrics.successfulDeliveries += metrics.successfulDeliveries;
    dashboard.metrics.failedDeliveries += metrics.failedDeliveries;
    
    if (metrics.successRate < 95) {
      dashboard.failing.push({
        name: webhook.name,
        successRate: metrics.successRate,
        lastFailure: metrics.lastFailure
      });
    }
  });
  
  dashboard.metrics.overallSuccessRate = 
    (dashboard.metrics.successfulDeliveries / dashboard.metrics.totalDeliveries) * 100;
  
  return dashboard;
}
```

### Webhook Testing Framework
```typescript
class WebhookTester {
  async testWebhookDelivery(webhookId: string) {
    const testEvent = {
      type: 'test.event',
      timestamp: new Date().toISOString(),
      data: {
        test: true,
        message: 'Test webhook delivery'
      }
    };
    
    try {
      const result = await this.deliverWebhook(webhookId, testEvent);
      return {
        success: true,
        statusCode: result.statusCode,
        responseTime: result.responseTime,
        response: result.response
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        statusCode: error.statusCode
      };
    }
  }
  
  async validateWebhookConfig(config: any) {
    const issues = [];
    
    if (!config.url || !this.isValidUrl(config.url)) {
      issues.push('Invalid webhook URL');
    }
    
    if (!config.events || config.events.length === 0) {
      issues.push('No events specified');
    }
    
    if (config.security && !this.validateSecurity(config.security)) {
      issues.push('Invalid security configuration');
    }
    
    return issues;
  }
}
```

## Best Practices

- **Implement idempotency** - handle duplicate webhook deliveries gracefully
- **Use proper authentication** - verify webhook signatures to ensure security
- **Handle retries appropriately** - implement exponential backoff for failed deliveries
- **Monitor webhook health** - track delivery rates and response times
- **Filter events wisely** - only send relevant events to reduce noise
- **Set appropriate timeouts** - prevent webhooks from hanging indefinitely
- **Log webhook activity** - maintain audit trails for debugging and compliance
- **Test webhook endpoints** - validate webhook receivers before production use
- **Handle webhook failures** - implement dead letter queues for failed deliveries
- **Document webhook payloads** - provide clear schemas for webhook consumers