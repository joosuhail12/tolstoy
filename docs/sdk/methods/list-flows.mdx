---
title: listFlows()
sidebar_position: 4
---

# listFlows()

List all workflows in the organization.

## Signature

```typescript
listFlows(): Promise<FlowList>
```

## Parameters

None - this method uses the organization context from the TolstoyClient constructor.

## Returns

Returns a `Promise<FlowList>`:

```typescript
interface FlowList {
  data: Flow[];
}

interface Flow {
  id: string;
  name: string;
  description?: string;
  active: boolean;
  version: string;
  createdAt: string;
  updatedAt: string;
  createdBy: string;
  tags?: string[];
}
```

## Usage Examples

### Basic Flow Listing
```typescript
const flows = await client.listFlows();

flows.data.forEach(flow => {
  console.log(`${flow.id}: ${flow.name}`);
  console.log(`  Active: ${flow.active}`);
  console.log(`  Version: ${flow.version}`);
  console.log(`  Created: ${flow.createdAt}`);
});
```

### Active Flows Only
```typescript
const flows = await client.listFlows();
const activeFlows = flows.data.filter(flow => flow.active);

console.log(`Found ${activeFlows.length} active workflows:`);
activeFlows.forEach(flow => {
  console.log(`- ${flow.name} (${flow.id})`);
});
```

### Flows by Tags
```typescript
const flows = await client.listFlows();
const onboardingFlows = flows.data.filter(flow => 
  flow.tags?.includes('onboarding')
);

console.log('Onboarding workflows:');
onboardingFlows.forEach(flow => {
  console.log(`- ${flow.name}: ${flow.description}`);
});
```

### Flow Selection Interface
```typescript
async function selectFlow(): Promise<Flow | null> {
  const flows = await client.listFlows();
  const activeFlows = flows.data.filter(flow => flow.active);
  
  if (activeFlows.length === 0) {
    console.log('No active workflows found');
    return null;
  }
  
  console.log('Available workflows:');
  activeFlows.forEach((flow, index) => {
    console.log(`${index + 1}. ${flow.name}`);
    console.log(`   ${flow.description || 'No description'}`);
  });
  
  // In a real app, you'd use a proper input method
  const selection = 0; // First flow for example
  return activeFlows[selection];
}

const selectedFlow = await selectFlow();
if (selectedFlow) {
  console.log(`Selected: ${selectedFlow.name}`);
}
```

## Flow Properties

### Basic Information
```typescript
const flows = await client.listFlows();
const flow = flows.data[0];

console.log('Flow Details:');
console.log(`  ID: ${flow.id}`);
console.log(`  Name: ${flow.name}`);
console.log(`  Description: ${flow.description || 'None'}`);
console.log(`  Version: ${flow.version}`);
console.log(`  Status: ${flow.active ? 'Active' : 'Inactive'}`);
```

### Timestamps
```typescript
const flows = await client.listFlows();

flows.data.forEach(flow => {
  const created = new Date(flow.createdAt);
  const updated = new Date(flow.updatedAt);
  
  console.log(`${flow.name}:`);
  console.log(`  Created: ${created.toLocaleDateString()}`);
  console.log(`  Last Updated: ${updated.toLocaleDateString()}`);
  
  if (updated > created) {
    const daysSinceUpdate = Math.floor(
      (Date.now() - updated.getTime()) / (1000 * 60 * 60 * 24)
    );
    console.log(`  Updated ${daysSinceUpdate} days ago`);
  }
});
```

### Tags and Organization
```typescript
const flows = await client.listFlows();

// Group flows by tags
const flowsByTag = new Map<string, Flow[]>();

flows.data.forEach(flow => {
  if (flow.tags) {
    flow.tags.forEach(tag => {
      if (!flowsByTag.has(tag)) {
        flowsByTag.set(tag, []);
      }
      flowsByTag.get(tag)!.push(flow);
    });
  }
});

// Display grouped flows
flowsByTag.forEach((flows, tag) => {
  console.log(`\n${tag.toUpperCase()} Workflows:`);
  flows.forEach(flow => {
    console.log(`  - ${flow.name}`);
  });
});
```

## Error Handling

```typescript
import { AxiosError } from 'axios';

try {
  const flows = await client.listFlows();
  
  if (flows.data.length === 0) {
    console.log('No workflows found in this organization');
  } else {
    console.log(`Found ${flows.data.length} workflows`);
  }
} catch (error) {
  const apiError = error as AxiosError;
  
  if (apiError.response?.status === 403) {
    console.error('Access denied - check organization permissions');
  } else if (apiError.response?.status === 401) {
    console.error('Authentication failed - check credentials');
  } else {
    console.error('Failed to list flows:', error.message);
  }
}
```

## Advanced Usage

### Flow Discovery
```typescript
class FlowDiscovery {
  async findFlowsByPattern(pattern: string): Promise<Flow[]> {
    const flows = await client.listFlows();
    return flows.data.filter(flow => 
      flow.name.toLowerCase().includes(pattern.toLowerCase()) ||
      flow.description?.toLowerCase().includes(pattern.toLowerCase())
    );
  }
  
  async getRecentlyUpdated(days = 7): Promise<Flow[]> {
    const flows = await client.listFlows();
    const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
    
    return flows.data.filter(flow => 
      new Date(flow.updatedAt) > cutoff
    );
  }
  
  async getFlowsByCreator(creatorId: string): Promise<Flow[]> {
    const flows = await client.listFlows();
    return flows.data.filter(flow => flow.createdBy === creatorId);
  }
}

const discovery = new FlowDiscovery();

// Find email-related workflows
const emailFlows = await discovery.findFlowsByPattern('email');
console.log(`Found ${emailFlows.length} email workflows`);

// Find recently updated workflows  
const recentFlows = await discovery.getRecentlyUpdated(30);
console.log(`${recentFlows.length} workflows updated in last 30 days`);
```

### Flow Validation
```typescript
async function validateFlowsHealth(): Promise<void> {
  const flows = await client.listFlows();
  const issues: string[] = [];
  
  flows.data.forEach(flow => {
    // Check for missing descriptions
    if (!flow.description) {
      issues.push(`Flow ${flow.name} has no description`);
    }
    
    // Check for inactive flows
    if (!flow.active) {
      issues.push(`Flow ${flow.name} is inactive`);
    }
    
    // Check for old flows
    const monthsOld = (Date.now() - new Date(flow.updatedAt).getTime()) 
      / (1000 * 60 * 60 * 24 * 30);
    if (monthsOld > 6) {
      issues.push(`Flow ${flow.name} hasn't been updated in ${Math.round(monthsOld)} months`);
    }
  });
  
  if (issues.length > 0) {
    console.warn('Flow Health Issues:');
    issues.forEach(issue => console.warn(`- ${issue}`));
  } else {
    console.log('All flows are healthy!');
  }
}

await validateFlowsHealth();
```

### Flow Registry
```typescript
class FlowRegistry {
  private flowCache: Map<string, Flow> = new Map();
  private lastFetch = 0;
  private cacheTTL = 5 * 60 * 1000; // 5 minutes
  
  async getFlows(forceRefresh = false): Promise<Flow[]> {
    const now = Date.now();
    
    if (forceRefresh || (now - this.lastFetch) > this.cacheTTL) {
      const flows = await client.listFlows();
      
      // Update cache
      this.flowCache.clear();
      flows.data.forEach(flow => {
        this.flowCache.set(flow.id, flow);
      });
      
      this.lastFetch = now;
      return flows.data;
    }
    
    return Array.from(this.flowCache.values());
  }
  
  async getFlowById(id: string): Promise<Flow | null> {
    const flows = await this.getFlows();
    return flows.find(flow => flow.id === id) || null;
  }
  
  async getFlowByName(name: string): Promise<Flow | null> {
    const flows = await this.getFlows();
    return flows.find(flow => flow.name === name) || null;
  }
  
  async searchFlows(query: string): Promise<Flow[]> {
    const flows = await this.getFlows();
    const lowercaseQuery = query.toLowerCase();
    
    return flows.filter(flow =>
      flow.name.toLowerCase().includes(lowercaseQuery) ||
      flow.description?.toLowerCase().includes(lowercaseQuery) ||
      flow.tags?.some(tag => tag.toLowerCase().includes(lowercaseQuery))
    );
  }
}

const registry = new FlowRegistry();

// Use the registry
const userOnboardingFlow = await registry.getFlowByName('User Onboarding');
const emailFlows = await registry.searchFlows('email');
```

## Integration Patterns

### Flow Menu Builder
```typescript
async function buildFlowMenu(): Promise<void> {
  const flows = await client.listFlows();
  const activeFlows = flows.data.filter(flow => flow.active);
  
  const menu = activeFlows.map((flow, index) => ({
    id: index + 1,
    name: flow.name,
    description: flow.description,
    flowId: flow.id,
    tags: flow.tags || []
  }));
  
  console.log('Available Workflows:');
  console.log('===================');
  
  menu.forEach(item => {
    console.log(`${item.id}. ${item.name}`);
    if (item.description) {
      console.log(`   ${item.description}`);
    }
    if (item.tags.length > 0) {
      console.log(`   Tags: ${item.tags.join(', ')}`);
    }
    console.log('');
  });
}

await buildFlowMenu();
```

### Workflow Dashboard
```typescript
interface FlowStats {
  total: number;
  active: number;
  inactive: number;
  byCreator: Map<string, number>;
  recentlyUpdated: number;
}

async function getFlowStats(): Promise<FlowStats> {
  const flows = await client.listFlows();
  const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
  
  const stats: FlowStats = {
    total: flows.data.length,
    active: 0,
    inactive: 0,
    byCreator: new Map(),
    recentlyUpdated: 0
  };
  
  flows.data.forEach(flow => {
    if (flow.active) {
      stats.active++;
    } else {
      stats.inactive++;
    }
    
    // Count by creator
    const count = stats.byCreator.get(flow.createdBy) || 0;
    stats.byCreator.set(flow.createdBy, count + 1);
    
    // Count recently updated
    if (new Date(flow.updatedAt) > oneWeekAgo) {
      stats.recentlyUpdated++;
    }
  });
  
  return stats;
}

const stats = await getFlowStats();
console.log('Workflow Statistics:');
console.log(`  Total: ${stats.total}`);
console.log(`  Active: ${stats.active}`);
console.log(`  Inactive: ${stats.inactive}`);
console.log(`  Recently Updated: ${stats.recentlyUpdated}`);
```

## Best Practices

### Caching
```typescript
// Cache flows for performance
let cachedFlows: Flow[] = [];
let lastFetch = 0;
const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

async function getCachedFlows(): Promise<Flow[]> {
  const now = Date.now();
  
  if (cachedFlows.length === 0 || (now - lastFetch) > CACHE_DURATION) {
    const flows = await client.listFlows();
    cachedFlows = flows.data;
    lastFetch = now;
  }
  
  return cachedFlows;
}
```

### Error Recovery
```typescript
async function robustListFlows(retries = 3): Promise<Flow[]> {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const flows = await client.listFlows();
      return flows.data;
    } catch (error) {
      if (attempt === retries) throw error;
      
      console.warn(`Attempt ${attempt} failed, retrying...`);
      await new Promise(resolve => setTimeout(resolve, attempt * 1000));
    }
  }
  return [];
}
```

## Related Methods

- [runFlow()](/sdk/methods/run-flow) - Execute a specific workflow
- [getFlowExecution()](/sdk/methods/get-flow-execution) - Monitor workflow status
- [TolstoyClient](/sdk/methods/tolstoy-client) - Client setup

## See Also

- [List Flows API](/api/flows/get-flows) - Direct API documentation
- [Workflow Examples](/sdk/examples) - Real-world flow management patterns