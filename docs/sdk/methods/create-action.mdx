---
title: createAction()
sidebar_position: 18
---

# createAction()

Create a new reusable action that can be used in workflows.

## Signature

```typescript
createAction(actionData: CreateActionDto): Promise<Action>
```

## Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `actionData` | `CreateActionDto` | Action configuration |

### CreateActionDto Interface

```typescript
interface CreateActionDto {
  name: string;
  description?: string;
  category: string;
  toolId?: string;
  method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
  endpoint: string;
  inputSchema: {
    type: 'object';
    properties: Record<string, any>;
    required?: string[];
  };
  outputSchema?: {
    type: 'object';
    properties: Record<string, any>;
  };
  active?: boolean;
  headers?: Record<string, string>;
  authentication?: {
    type: 'bearer' | 'apikey' | 'basic';
    field?: string;
  };
}
```

## Returns

Returns a `Promise<Action>`:

```typescript
interface Action {
  data: {
    id: string;
    name: string;
    description?: string;
    category: string;
    toolId?: string;
    toolName?: string;
    method: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';
    endpoint: string;
    inputSchema: any;
    outputSchema?: any;
    active: boolean;
    createdAt: string;
    updatedAt: string;
    lastUsed?: string;
    usageCount: number;
  };
}
```

## Usage Examples

### Simple GET Action
```typescript
const getUserAction = await client.createAction({
  name: 'Get User Profile',
  description: 'Retrieve user profile information',
  category: 'User Management',
  toolId: 'tool_github_api',
  method: 'GET',
  endpoint: '/user',
  inputSchema: {
    type: 'object',
    properties: {
      username: {
        type: 'string',
        description: 'GitHub username'
      }
    },
    required: ['username']
  },
  outputSchema: {
    type: 'object',
    properties: {
      id: { type: 'number' },
      login: { type: 'string' },
      name: { type: 'string' },
      email: { type: 'string' }
    }
  },
  active: true
});

console.log(`Created action: ${getUserAction.data.name}`);
console.log(`Action ID: ${getUserAction.data.id}`);
```

### POST Action with Complex Schema
```typescript
const createIssueAction = await client.createAction({
  name: 'Create GitHub Issue',
  description: 'Create a new issue in a GitHub repository',
  category: 'Issue Management',
  toolId: 'tool_github_api',
  method: 'POST',
  endpoint: '/repos/{{owner}}/{{repo}}/issues',
  inputSchema: {
    type: 'object',
    properties: {
      owner: {
        type: 'string',
        description: 'Repository owner'
      },
      repo: {
        type: 'string',
        description: 'Repository name'
      },
      title: {
        type: 'string',
        description: 'Issue title'
      },
      body: {
        type: 'string',
        description: 'Issue description'
      },
      labels: {
        type: 'array',
        items: { type: 'string' },
        description: 'Issue labels'
      },
      assignees: {
        type: 'array',
        items: { type: 'string' },
        description: 'Assignee usernames'
      }
    },
    required: ['owner', 'repo', 'title']
  },
  outputSchema: {
    type: 'object',
    properties: {
      id: { type: 'number' },
      number: { type: 'number' },
      title: { type: 'string' },
      html_url: { type: 'string' },
      state: { type: 'string' }
    }
  },
  headers: {
    'Accept': 'application/vnd.github.v3+json'
  },
  active: true
});
```

### Email Action
```typescript
const sendEmailAction = await client.createAction({
  name: 'Send Transactional Email',
  description: 'Send email using SendGrid API',
  category: 'Email',
  toolId: 'tool_sendgrid',
  method: 'POST',
  endpoint: '/mail/send',
  inputSchema: {
    type: 'object',
    properties: {
      to: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            email: { type: 'string' },
            name: { type: 'string' }
          },
          required: ['email']
        },
        description: 'Recipients'
      },
      from: {
        type: 'object',
        properties: {
          email: { type: 'string' },
          name: { type: 'string' }
        },
        required: ['email'],
        description: 'Sender information'
      },
      subject: {
        type: 'string',
        description: 'Email subject'
      },
      content: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            type: { type: 'string' },
            value: { type: 'string' }
          }
        },
        description: 'Email content'
      },
      template_id: {
        type: 'string',
        description: 'SendGrid template ID'
      },
      dynamic_template_data: {
        type: 'object',
        description: 'Template variables'
      }
    },
    required: ['to', 'from', 'subject']
  },
  active: true
});
```

## Error Handling

```typescript
import { AxiosError } from 'axios';

try {
  const action = await client.createAction({
    name: 'My Custom Action',
    category: 'Custom',
    method: 'POST',
    endpoint: '/api/custom',
    inputSchema: {
      type: 'object',
      properties: {
        data: { type: 'string' }
      }
    }
  });
  
  console.log(`✅ Action created: ${action.data.id}`);
} catch (error) {
  const apiError = error as AxiosError;
  
  if (apiError.response) {
    const { status, data } = apiError.response;
    
    switch (data.error.code) {
      case 'VALIDATION_ERROR':
        console.error('Invalid action configuration:', data.error.details);
        break;
      case 'CONFLICT':
        console.error('Action with this name already exists');
        break;
      case 'INVALID_SCHEMA':
        console.error('Invalid input/output schema format');
        break;
      case 'TOOL_NOT_FOUND':
        console.error('Specified tool does not exist');
        break;
      default:
        console.error(`API Error ${status}:`, data.error.message);
    }
  }
}
```

## Advanced Usage

### Action Library Builder
```typescript
class ActionLibraryBuilder {
  async buildRESTAPIActions(
    toolId: string,
    apiSpec: OpenAPISpec
  ): Promise<Action[]> {
    const actions: Action[] = [];
    
    for (const [path, methods] of Object.entries(apiSpec.paths)) {
      for (const [method, spec] of Object.entries(methods)) {
        const actionName = this.generateActionName(path, method, spec);
        
        try {
          const action = await client.createAction({
            name: actionName,
            description: spec.description || spec.summary,
            category: this.categorizeEndpoint(path, method),
            toolId,
            method: method.toUpperCase() as any,
            endpoint: path,
            inputSchema: this.convertOpenAPISchema(spec.parameters, spec.requestBody),
            outputSchema: this.convertResponseSchema(spec.responses),
            active: true
          });
          
          actions.push(action);
          console.log(`✅ Created action: ${actionName}`);
        } catch (error: any) {
          console.error(`❌ Failed to create action for ${method.toUpperCase()} ${path}:`, error.message);
        }
      }
    }
    
    return actions;
  }
  
  private generateActionName(path: string, method: string, spec: any): string {
    if (spec.operationId) {
      return spec.operationId.replace(/([A-Z])/g, ' $1').trim();
    }
    
    // Generate name from path and method
    const pathParts = path.split('/').filter(Boolean);
    const resource = pathParts[pathParts.length - 1];
    const action = method === 'get' && path.includes('{') ? 'Get' :
                  method === 'get' ? 'List' :
                  method === 'post' ? 'Create' :
                  method === 'put' ? 'Update' :
                  method === 'patch' ? 'Modify' :
                  method === 'delete' ? 'Delete' : 
                  method.toUpperCase();
    
    return `${action} ${resource.replace(/[{}]/g, '')}`;
  }
  
  private categorizeEndpoint(path: string, method: string): string {
    const pathParts = path.split('/').filter(Boolean);
    const resource = pathParts[0] || 'General';
    return resource.charAt(0).toUpperCase() + resource.slice(1);
  }
  
  private convertOpenAPISchema(parameters: any[], requestBody: any): any {
    const properties: Record<string, any> = {};
    const required: string[] = [];
    
    // Convert parameters
    if (parameters) {
      parameters.forEach(param => {
        properties[param.name] = {
          type: param.schema?.type || 'string',
          description: param.description
        };
        if (param.required) required.push(param.name);
      });
    }
    
    // Convert request body
    if (requestBody?.content?.['application/json']?.schema) {
      const bodySchema = requestBody.content['application/json'].schema;
      Object.assign(properties, bodySchema.properties || {});
      if (bodySchema.required) required.push(...bodySchema.required);
    }
    
    return {
      type: 'object',
      properties,
      required
    };
  }
  
  private convertResponseSchema(responses: any): any {
    const successResponse = responses['200'] || responses['201'] || responses['default'];
    if (!successResponse?.content?.['application/json']?.schema) {
      return undefined;
    }
    
    return successResponse.content['application/json'].schema;
  }
}

interface OpenAPISpec {
  paths: Record<string, Record<string, any>>;
}

const builder = new ActionLibraryBuilder();

// Example: Build actions from OpenAPI spec
const gitHubActions = await builder.buildRESTAPIActions('tool_github', {
  paths: {
    '/user': {
      get: {
        operationId: 'getUserProfile',
        description: 'Get authenticated user profile',
        responses: {
          '200': {
            content: {
              'application/json': {
                schema: {
                  type: 'object',
                  properties: {
                    login: { type: 'string' },
                    name: { type: 'string' }
                  }
                }
              }
            }
          }
        }
      }
    },
    '/repos/{owner}/{repo}/issues': {
      post: {
        operationId: 'createIssue',
        description: 'Create a new issue',
        parameters: [
          { name: 'owner', required: true, schema: { type: 'string' } },
          { name: 'repo', required: true, schema: { type: 'string' } }
        ],
        requestBody: {
          content: {
            'application/json': {
              schema: {
                type: 'object',
                properties: {
                  title: { type: 'string' },
                  body: { type: 'string' }
                },
                required: ['title']
              }
            }
          }
        }
      }
    }
  }
});

console.log(`Created ${gitHubActions.length} GitHub actions`);
```

### Action Template System
```typescript
class ActionTemplateSystem {
  private templates = new Map<string, Partial<CreateActionDto>>();
  
  constructor() {
    this.initializeTemplates();
  }
  
  private initializeTemplates(): void {
    // HTTP GET template
    this.templates.set('http-get', {
      method: 'GET',
      inputSchema: {
        type: 'object',
        properties: {
          id: { type: 'string', description: 'Resource ID' }
        },
        required: ['id']
      },
      active: true
    });
    
    // HTTP POST template
    this.templates.set('http-post', {
      method: 'POST',
      inputSchema: {
        type: 'object',
        properties: {
          data: { type: 'object', description: 'Data to create' }
        },
        required: ['data']
      },
      active: true
    });
    
    // Email template
    this.templates.set('email', {
      category: 'Email',
      method: 'POST',
      endpoint: '/send',
      inputSchema: {
        type: 'object',
        properties: {
          to: { type: 'string', description: 'Recipient email' },
          subject: { type: 'string', description: 'Email subject' },
          body: { type: 'string', description: 'Email body' }
        },
        required: ['to', 'subject', 'body']
      },
      active: true
    });
    
    // Database query template
    this.templates.set('db-query', {
      category: 'Database',
      method: 'POST',
      endpoint: '/query',
      inputSchema: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'SQL query' },
          parameters: { type: 'object', description: 'Query parameters' }
        },
        required: ['query']
      },
      active: true
    });
  }
  
  async createFromTemplate(
    templateName: string,
    customization: Partial<CreateActionDto>
  ): Promise<Action> {
    const template = this.templates.get(templateName);
    if (!template) {
      throw new Error(`Template '${templateName}' not found`);
    }
    
    const actionData: CreateActionDto = {
      ...template,
      ...customization,
      inputSchema: {
        ...template.inputSchema!,
        ...customization.inputSchema,
        properties: {
          ...template.inputSchema?.properties,
          ...customization.inputSchema?.properties
        },
        required: [
          ...(template.inputSchema?.required || []),
          ...(customization.inputSchema?.required || [])
        ]
      }
    };
    
    return client.createAction(actionData);
  }
  
  listTemplates(): string[] {
    return Array.from(this.templates.keys());
  }
}

const templateSystem = new ActionTemplateSystem();

// Create action from email template
const emailAction = await templateSystem.createFromTemplate('email', {
  name: 'Send Welcome Email',
  description: 'Send welcome email to new users',
  toolId: 'tool_sendgrid',
  endpoint: '/mail/send',
  inputSchema: {
    properties: {
      template: { type: 'string', description: 'Email template ID' }
    }
  }
});

console.log('Available templates:', templateSystem.listTemplates());
```

### Action Testing Framework
```typescript
class ActionTester {
  async testAction(actionId: string, testCases: TestCase[]): Promise<TestResults> {
    const results: TestResults = {
      actionId,
      passed: 0,
      failed: 0,
      results: []
    };
    
    for (const testCase of testCases) {
      try {
        console.log(`Running test: ${testCase.name}`);
        
        // This would execute the action with test inputs
        // const result = await client.executeAction(actionId, testCase.inputs);
        
        // For now, we'll simulate the test
        const testResult: TestResult = {
          name: testCase.name,
          passed: true,
          inputs: testCase.inputs,
          expectedOutput: testCase.expectedOutput,
          actualOutput: { success: true, data: 'mocked response' },
          duration: 150
        };
        
        results.results.push(testResult);
        results.passed++;
        
        console.log(`✅ ${testCase.name} passed`);
      } catch (error: any) {
        const testResult: TestResult = {
          name: testCase.name,
          passed: false,
          inputs: testCase.inputs,
          expectedOutput: testCase.expectedOutput,
          actualOutput: null,
          error: error.message,
          duration: 0
        };
        
        results.results.push(testResult);
        results.failed++;
        
        console.log(`❌ ${testCase.name} failed: ${error.message}`);
      }
    }
    
    return results;
  }
  
  generateTestReport(results: TestResults): string {
    let report = `ACTION TEST REPORT\n`;
    report += `Action ID: ${results.actionId}\n`;
    report += `Total Tests: ${results.passed + results.failed}\n`;
    report += `Passed: ${results.passed}\n`;
    report += `Failed: ${results.failed}\n\n`;
    
    results.results.forEach(result => {
      report += `${result.passed ? '✅' : '❌'} ${result.name}\n`;
      if (!result.passed && result.error) {
        report += `  Error: ${result.error}\n`;
      }
      report += `  Duration: ${result.duration}ms\n\n`;
    });
    
    return report;
  }
}

interface TestCase {
  name: string;
  inputs: any;
  expectedOutput?: any;
}

interface TestResult {
  name: string;
  passed: boolean;
  inputs: any;
  expectedOutput?: any;
  actualOutput: any;
  error?: string;
  duration: number;
}

interface TestResults {
  actionId: string;
  passed: number;
  failed: number;
  results: TestResult[];
}

const tester = new ActionTester();

// Test action with various inputs
const testResults = await tester.testAction('action_123', [
  {
    name: 'Valid input test',
    inputs: { to: 'test@example.com', subject: 'Test', body: 'Hello' }
  },
  {
    name: 'Missing required field',
    inputs: { to: 'test@example.com', body: 'Hello' }
  }
]);

console.log(tester.generateTestReport(testResults));
```

## Best Practices

### Schema Validation
```typescript
function validateActionSchema(schema: any): string[] {
  const errors: string[] = [];
  
  if (!schema || typeof schema !== 'object') {
    errors.push('Schema must be an object');
    return errors;
  }
  
  if (schema.type !== 'object') {
    errors.push('Schema type must be "object"');
  }
  
  if (!schema.properties || typeof schema.properties !== 'object') {
    errors.push('Schema must have properties');
  }
  
  // Validate properties
  if (schema.properties) {
    Object.entries(schema.properties).forEach(([key, prop]: [string, any]) => {
      if (!prop.type) {
        errors.push(`Property '${key}' missing type`);
      }
    });
  }
  
  return errors;
}

// Usage
const schema = {
  type: 'object',
  properties: {
    name: { type: 'string' },
    age: { type: 'number' }
  }
};

const errors = validateActionSchema(schema);
if (errors.length > 0) {
  console.error('Schema validation errors:', errors);
}
```

### Naming Conventions
```typescript
function generateActionName(resource: string, operation: string, method: string): string {
  const operations = {
    'GET': resource.endsWith('s') ? 'List' : 'Get',
    'POST': 'Create',
    'PUT': 'Update',
    'PATCH': 'Modify', 
    'DELETE': 'Delete'
  };
  
  const verb = operations[method] || operation;
  return `${verb} ${resource}`.replace(/([A-Z])/g, ' $1').trim();
}

// Usage
const actionName = generateActionName('users', 'retrieve', 'GET');
console.log(actionName); // "List users"
```

## Related Methods

- [listActions()](/sdk/methods/list-actions) - List all actions
- [getAction()](/sdk/methods/get-action) - Get action details
- [updateAction()](/sdk/methods/update-action) - Update action
- [deleteAction()](/sdk/methods/delete-action) - Delete action
- [listTools()](/sdk/methods/list-tools) - List available tools
- [TolstoyClient](/sdk/methods/tolstoy-client) - Client setup

## See Also

- [Create Action API](/api/actions/post-actions) - Direct API documentation
- [Action Development Guide](/docs/actions) - Comprehensive action building
- [Tool Integration](/docs/tools) - Connecting external APIs