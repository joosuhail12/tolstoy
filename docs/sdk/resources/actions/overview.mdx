---
title: "Actions SDK Overview"
description: "Complete guide to managing and executing actions with the Tolstoy TypeScript SDK - from basic operations to advanced automation patterns."
---

# Actions SDK Overview

The Actions SDK provides comprehensive functionality for managing and executing individual actions within your applications. Actions are the building blocks of workflows, representing discrete operations that can be executed independently or as part of larger automation sequences.

## Quick Start

```typescript
import { TolstoyClient } from '@joosuhail/tolstoy-sdk';

const client = new TolstoyClient({
  orgId: process.env.TOLSTOY_ORG_ID!,
  userId: process.env.TOLSTOY_USER_ID!
});

// List all available actions
const actions = await client.actions.list();

// Execute a specific action
const execution = await client.actions.execute('send-email', {
  to: 'user@example.com',
  subject: 'Welcome!',
  template: 'welcome',
  variables: {
    name: 'John Doe'
  }
});

console.log('Action executed:', execution.id);
```

## Available Methods

### Action Management

| Method | Description | Returns |
|--------|-------------|---------|
| `list(options?)` | List actions with filtering and pagination | `Promise<Action[]>` |
| `get(actionId)` | Get detailed action information | `Promise<Action>` |
| `create(definition)` | Create a custom action | `Promise<Action>` |
| `update(actionId, definition)` | Update existing action | `Promise<Action>` |
| `delete(actionId)` | Delete a custom action | `Promise<void>` |
| `validate(definition)` | Validate action definition | `Promise<ValidationResult>` |

### Action Execution

| Method | Description | Returns |
|--------|-------------|---------|
| `execute(actionId, inputs?, options?)` | Execute an action | `Promise<ActionExecution>` |
| `executeSync(actionId, inputs?, options?)` | Execute synchronously | `Promise<ExecutionResult>` |
| `executeBatch(requests, options?)` | Execute multiple actions | `Promise<BatchResult>` |
| `cancelExecution(executionId)` | Cancel running execution | `Promise<void>` |
| `retryExecution(executionId)` | Retry failed execution | `Promise<ActionExecution>` |

### Execution Monitoring

| Method | Description | Returns |
|--------|-------------|---------|
| `getExecution(executionId)` | Get execution details | `Promise<ActionExecution>` |
| `listExecutions(actionId?, options?)` | List executions | `Promise<ActionExecution[]>` |
| `waitForCompletion(executionId, options?)` | Wait for execution to complete | `Promise<ExecutionResult>` |
| `streamExecution(executionId)` | Stream execution updates | `AsyncIterator<ExecutionUpdate>` |

### Action Discovery and Search

| Method | Description | Returns |
|--------|-------------|---------|
| `search(query, options?)` | Search actions by name, description, or tags | `Promise<Action[]>` |
| `getByCategory(category)` | Get actions by category | `Promise<Action[]>` |
| `getByTags(tags)` | Get actions by tags | `Promise<Action[]>` |
| `getSuggestions(context)` | Get suggested actions for context | `Promise<Action[]>` |

## Core Types

### Action Definition

```typescript
interface Action {
  id: string;
  name: string;
  description?: string;
  category: ActionCategory;
  version: string;
  
  // Configuration
  inputs: ActionInput[];
  outputs: ActionOutput[];
  settings: ActionSettings;
  
  // Metadata
  tags: string[];
  provider: string;
  icon?: string;
  
  // Runtime information
  status: 'active' | 'inactive' | 'deprecated';
  capabilities: ActionCapability[];
  
  // Statistics
  stats: ActionStats;
  
  // Timestamps
  created_at: string;
  updated_at: string;
  last_executed_at?: string;
}

interface ActionInput {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'object' | 'array' | 'file';
  required: boolean;
  description?: string;
  default?: any;
  validation?: ValidationRule;
  sensitive?: boolean;
  examples?: any[];
}

interface ActionOutput {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'object' | 'array' | 'file';
  description?: string;
  schema?: any;
}

type ActionCategory = 
  | 'communication'
  | 'data_processing'
  | 'integrations'
  | 'utilities'
  | 'ai_ml'
  | 'storage'
  | 'monitoring'
  | 'custom';

interface ActionCapability {
  name: string;
  description: string;
  supported: boolean;
}
```

### Action Execution

```typescript
interface ActionExecution {
  id: string;
  action_id: string;
  status: ExecutionStatus;
  mode: 'sync' | 'async';
  
  // Input/Output
  inputs: Record<string, any>;
  outputs?: Record<string, any>;
  
  // Execution details
  started_at: string;
  completed_at?: string;
  duration_ms?: number;
  
  // Error information
  error?: ExecutionError;
  
  // Metadata
  metadata: ExecutionMetadata;
  cost?: ExecutionCost;
}

interface ExecutionCost {
  amount: number;
  currency: string;
  breakdown?: CostBreakdown[];
}

interface CostBreakdown {
  category: string;
  amount: number;
  unit: string;
  quantity: number;
}
```

## Action Categories and Examples

### Communication Actions

Actions for sending messages, emails, notifications, and managing communication channels.

<CodeGroup>
```typescript Send Email
const execution = await client.actions.execute('send-email', {
  to: 'recipient@example.com',
  cc: ['manager@example.com'],
  subject: 'Project Update',
  template: 'project-update',
  variables: {
    projectName: 'Website Redesign',
    status: 'In Progress',
    dueDate: '2024-02-15',
    teamMembers: ['Alice', 'Bob', 'Carol']
  },
  attachments: [
    {
      filename: 'report.pdf',
      content: 'base64-encoded-content',
      contentType: 'application/pdf'
    }
  ]
});
```

```typescript Send Slack Message
const execution = await client.actions.execute('slack-send-message', {
  channel: '#general',
  text: 'Deployment completed successfully! 🎉',
  blocks: [
    {
      type: 'section',
      text: {
        type: 'mrkdwn',
        text: '*Deployment Summary*\n• Environment: Production\n• Version: v1.2.3\n• Duration: 5 minutes'
      }
    },
    {
      type: 'actions',
      elements: [
        {
          type: 'button',
          text: { type: 'plain_text', text: 'View Logs' },
          url: 'https://logs.company.com/deployment-123'
        }
      ]
    }
  ]
});
```

```typescript Send SMS
const execution = await client.actions.execute('send-sms', {
  to: '+1234567890',
  message: 'Your verification code is: 123456',
  sender: 'CompanyName'
});
```
</CodeGroup>

### Data Processing Actions

Actions for transforming, validating, and processing data.

<CodeGroup>
```typescript Data Transformation
const execution = await client.actions.execute('transform-data', {
  input: {
    users: [
      { firstName: 'John', lastName: 'Doe', email: 'john@example.com' },
      { firstName: 'Jane', lastName: 'Smith', email: 'jane@example.com' }
    ]
  },
  transformations: [
    {
      field: 'fullName',
      expression: '{{firstName}} {{lastName}}'
    },
    {
      field: 'domain',
      expression: 'email.split("@")[1]'
    },
    {
      field: 'initials',
      expression: '{{firstName[0]}}{{lastName[0]}}'
    }
  ],
  outputFormat: 'json'
});
```

```typescript Data Validation
const execution = await client.actions.execute('validate-data', {
  data: {
    email: 'user@example.com',
    phone: '+1234567890',
    age: 25,
    preferences: ['email', 'sms']
  },
  schema: {
    type: 'object',
    properties: {
      email: { type: 'string', format: 'email' },
      phone: { type: 'string', pattern: '^\\+[1-9]\\d{1,14}$' },
      age: { type: 'number', minimum: 18, maximum: 120 },
      preferences: {
        type: 'array',
        items: { enum: ['email', 'sms', 'push'] }
      }
    },
    required: ['email', 'age']
  }
});
```

```typescript CSV Processing
const execution = await client.actions.execute('process-csv', {
  input: 'data:text/csv;base64,bmFtZSxhZ2UsZW1haWwKSm9obiwyNSxqb2huQGV4YW1wbGUuY29t',
  options: {
    hasHeaders: true,
    delimiter: ',',
    encoding: 'utf8'
  },
  transformations: [
    { column: 'name', operation: 'trim' },
    { column: 'email', operation: 'lowercase' },
    { column: 'age', operation: 'parseInt' }
  ],
  filters: [
    { column: 'age', operator: '>=', value: 18 }
  ]
});
```
</CodeGroup>

### Integration Actions

Actions for connecting with external services and APIs.

<CodeGroup>
```typescript HTTP Request
const execution = await client.actions.execute('http-request', {
  method: 'POST',
  url: 'https://api.external-service.com/v1/users',
  headers: {
    'Authorization': 'Bearer {{secrets.api_token}}',
    'Content-Type': 'application/json'
  },
  body: {
    name: '{{inputs.userName}}',
    email: '{{inputs.userEmail}}',
    preferences: {
      notifications: true,
      marketing: false
    }
  },
  timeout: 30000,
  retryPolicy: {
    maxRetries: 3,
    retryDelay: 1000,
    retryOn: [500, 502, 503, 504]
  }
});
```

```typescript Database Query
const execution = await client.actions.execute('database-query', {
  connection: 'primary-db',
  query: 'SELECT * FROM users WHERE created_at > ? AND status = ?',
  parameters: ['2024-01-01', 'active'],
  options: {
    timeout: 60000,
    fetchSize: 1000
  }
});
```

```typescript Webhook Call
const execution = await client.actions.execute('call-webhook', {
  url: 'https://hooks.company.com/notifications',
  method: 'POST',
  headers: {
    'X-Event-Type': 'user.created',
    'X-Signature': '{{hmac_sha256(secrets.webhook_secret, payload)}}'
  },
  payload: {
    event: 'user.created',
    timestamp: '{{now()}}',
    data: {
      userId: '{{inputs.userId}}',
      email: '{{inputs.email}}',
      source: 'registration_form'
    }
  }
});
```
</CodeGroup>

### AI/ML Actions

Actions for artificial intelligence and machine learning operations.

<CodeGroup>
```typescript Text Analysis
const execution = await client.actions.execute('analyze-text', {
  text: 'I love this product! The customer service was excellent.',
  analysis: [
    'sentiment',
    'entities',
    'keywords',
    'language'
  ],
  options: {
    includeConfidence: true,
    language: 'auto-detect'
  }
});
```

```typescript Image Recognition
const execution = await client.actions.execute('analyze-image', {
  image: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD...',
  analysis: [
    'objects',
    'text',
    'faces',
    'explicit_content'
  ],
  options: {
    maxResults: 10,
    minConfidence: 0.7
  }
});
```

```typescript Translation
const execution = await client.actions.execute('translate-text', {
  text: 'Hello, how are you today?',
  source: 'en',
  target: 'es',
  options: {
    formal: false,
    preserveFormatting: true
  }
});
```
</CodeGroup>

## Advanced Usage Patterns

### Batch Action Execution

Execute multiple actions efficiently with comprehensive monitoring and error handling.

```typescript
interface BatchExecutionRequest {
  actionId: string;
  inputs: any;
  priority?: number;
  timeout?: number;
  retryPolicy?: RetryPolicy;
  metadata?: Record<string, any>;
}

class BatchActionExecutor {
  constructor(private client: TolstoyClient) {}
  
  async executeBatch(
    requests: BatchExecutionRequest[],
    options: {
      concurrency?: number;
      failFast?: boolean;
      progressCallback?: (progress: BatchProgress) => void;
      onError?: (request: BatchExecutionRequest, error: any) => Promise<'retry' | 'skip' | 'abort'>;
    } = {}
  ): Promise<BatchExecutionResult> {
    const {
      concurrency = 5,
      failFast = false,
      progressCallback,
      onError
    } = options;
    
    const results = new Map<string, ActionExecution>();
    const errors = new Map<string, Error>();
    const retries = new Map<string, number>();
    
    let completed = 0;
    let successful = 0;
    let failed = 0;
    
    console.log(`🚀 Starting batch execution of ${requests.length} actions`);
    
    // Sort requests by priority
    const sortedRequests = [...requests].sort((a, b) => 
      (b.priority || 0) - (a.priority || 0)
    );
    
    // Execute in batches with controlled concurrency
    for (let i = 0; i < sortedRequests.length; i += concurrency) {
      const batch = sortedRequests.slice(i, i + concurrency);
      
      const batchPromises = batch.map(async (request, index) => {
        const requestId = `${request.actionId}-${i + index}`;
        
        try {
          console.log(`📋 Executing: ${request.actionId}`);
          
          const execution = await this.client.actions.execute(
            request.actionId,
            request.inputs,
            {
              timeout: request.timeout,
              retryPolicy: request.retryPolicy,
              metadata: request.metadata
            }
          );
          
          const result = await this.client.actions.waitForCompletion(execution.id);
          
          if (result.status === 'completed') {
            results.set(requestId, result);
            successful++;
            console.log(`✅ Completed: ${request.actionId}`);
          } else {
            throw new Error(`Action failed: ${result.error?.message}`);
          }
          
        } catch (error) {
          console.log(`❌ Failed: ${request.actionId} - ${error.message}`);
          
          let action: 'retry' | 'skip' | 'abort' = 'skip';
          
          if (onError) {
            action = await onError(request, error);
          }
          
          if (action === 'retry') {
            const retryCount = retries.get(requestId) || 0;
            if (retryCount < 3) {
              retries.set(requestId, retryCount + 1);
              console.log(`🔄 Retrying: ${request.actionId} (attempt ${retryCount + 2})`);
              
              // Add back to queue for retry
              sortedRequests.push(request);
              return;
            }
          }
          
          if (action === 'abort' || failFast) {
            throw new Error(`Batch execution aborted due to error in ${request.actionId}`);
          }
          
          errors.set(requestId, error);
          failed++;
          
        } finally {
          completed++;
          
          if (progressCallback) {
            progressCallback({
              completed,
              total: requests.length,
              successful,
              failed,
              percentage: (completed / requests.length) * 100
            });
          }
        }
      });
      
      await Promise.allSettled(batchPromises);
      
      // Small delay between batches
      if (i + concurrency < sortedRequests.length) {
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    
    console.log(`🎊 Batch execution completed: ${successful} successful, ${failed} failed`);
    
    return {
      results,
      errors,
      summary: {
        total: requests.length,
        successful,
        failed,
        retries: Array.from(retries.values()).reduce((sum, count) => sum + count, 0),
        successRate: successful / requests.length
      }
    };
  }
}

interface BatchProgress {
  completed: number;
  total: number;
  successful: number;
  failed: number;
  percentage: number;
}

interface BatchExecutionResult {
  results: Map<string, ActionExecution>;
  errors: Map<string, Error>;
  summary: {
    total: number;
    successful: number;
    failed: number;
    retries: number;
    successRate: number;
  };
}

// Usage
const batchExecutor = new BatchActionExecutor(client);

const batchRequests: BatchExecutionRequest[] = [
  {
    actionId: 'send-email',
    inputs: {
      to: 'user1@example.com',
      subject: 'Welcome!',
      template: 'welcome'
    },
    priority: 10,
    timeout: 30000
  },
  {
    actionId: 'create-user-profile',
    inputs: {
      userId: 'user1',
      profileData: { name: 'John Doe', preferences: {} }
    },
    priority: 8
  },
  {
    actionId: 'send-slack-notification',
    inputs: {
      channel: '#onboarding',
      message: 'New user registered: user1'
    },
    priority: 5,
    retryPolicy: {
      maxRetries: 2,
      retryDelay: 1000
    }
  }
];

const batchResult = await batchExecutor.executeBatch(batchRequests, {
  concurrency: 3,
  progressCallback: (progress) => {
    console.log(`Progress: ${progress.percentage.toFixed(1)}% (${progress.completed}/${progress.total})`);
  },
  onError: async (request, error) => {
    console.log(`Error in ${request.actionId}: ${error.message}`);
    
    // Decide what to do based on the error
    if (error.message.includes('rate limit')) {
      return 'retry'; // Rate limit - retry after delay
    } else if (error.message.includes('invalid input')) {
      return 'skip'; // Invalid input - skip this request
    } else {
      return 'skip'; // Other errors - skip by default
    }
  }
});

console.log(`Success rate: ${(batchResult.summary.successRate * 100).toFixed(1)}%`);
```

### Action Chaining and Pipelines

Create complex data processing pipelines by chaining multiple actions.

```typescript
interface PipelineStep {
  actionId: string;
  inputs: (previousResults: any[]) => any;
  outputMapping?: (result: any) => any;
  condition?: (previousResults: any[]) => boolean;
  errorHandler?: (error: any, previousResults: any[]) => any;
}

class ActionPipeline {
  private steps: PipelineStep[] = [];
  
  constructor(private client: TolstoyClient) {}
  
  addStep(step: PipelineStep): ActionPipeline {
    this.steps.push(step);
    return this;
  }
  
  async execute(initialInput: any): Promise<PipelineResult> {
    const results: any[] = [initialInput];
    const stepResults: StepResult[] = [];
    
    console.log(`🔗 Starting pipeline with ${this.steps.length} steps`);
    
    for (let i = 0; i < this.steps.length; i++) {
      const step = this.steps[i];
      
      try {
        // Check condition
        if (step.condition && !step.condition(results)) {
          console.log(`⏭️  Skipping step ${i + 1}: condition not met`);
          stepResults.push({
            stepIndex: i,
            actionId: step.actionId,
            skipped: true,
            inputs: null,
            outputs: null,
            error: null,
            duration: 0
          });
          continue;
        }
        
        // Prepare inputs
        const inputs = step.inputs(results);
        console.log(`🔄 Executing step ${i + 1}: ${step.actionId}`);
        
        const startTime = Date.now();
        
        // Execute action
        const execution = await this.client.actions.execute(step.actionId, inputs);
        const result = await this.client.actions.waitForCompletion(execution.id);
        
        const duration = Date.now() - startTime;
        
        if (result.status === 'completed') {
          // Apply output mapping if specified
          const mappedOutput = step.outputMapping 
            ? step.outputMapping(result.outputs)
            : result.outputs;
          
          results.push(mappedOutput);
          
          stepResults.push({
            stepIndex: i,
            actionId: step.actionId,
            skipped: false,
            inputs,
            outputs: mappedOutput,
            error: null,
            duration
          });
          
          console.log(`✅ Step ${i + 1} completed in ${duration}ms`);
          
        } else {
          throw new Error(`Step failed: ${result.error?.message}`);
        }
        
      } catch (error) {
        console.log(`❌ Step ${i + 1} failed: ${error.message}`);
        
        // Try error handler
        if (step.errorHandler) {
          try {
            const handlerResult = step.errorHandler(error, results);
            results.push(handlerResult);
            
            stepResults.push({
              stepIndex: i,
              actionId: step.actionId,
              skipped: false,
              inputs: step.inputs(results.slice(0, -1)),
              outputs: handlerResult,
              error: error.message,
              duration: 0
            });
            
            console.log(`🔧 Error handled by custom handler`);
            continue;
            
          } catch (handlerError) {
            console.log(`💥 Error handler also failed: ${handlerError.message}`);
          }
        }
        
        // Pipeline failed
        stepResults.push({
          stepIndex: i,
          actionId: step.actionId,
          skipped: false,
          inputs: step.inputs(results),
          outputs: null,
          error: error.message,
          duration: 0
        });
        
        return {
          success: false,
          results,
          stepResults,
          error: error.message,
          failedAtStep: i
        };
      }
    }
    
    console.log(`🎉 Pipeline completed successfully`);
    
    return {
      success: true,
      results,
      stepResults,
      error: null,
      failedAtStep: null
    };
  }
}

interface StepResult {
  stepIndex: number;
  actionId: string;
  skipped: boolean;
  inputs: any;
  outputs: any;
  error: string | null;
  duration: number;
}

interface PipelineResult {
  success: boolean;
  results: any[];
  stepResults: StepResult[];
  error: string | null;
  failedAtStep: number | null;
}

// Example: User onboarding pipeline
const onboardingPipeline = new ActionPipeline(client)
  .addStep({
    actionId: 'validate-user-data',
    inputs: (results) => results[0], // Use initial input
    condition: (results) => results[0]?.email && results[0]?.name
  })
  .addStep({
    actionId: 'create-user-account',
    inputs: (results) => ({
      userData: results[1], // Use validated data from step 1
      sendWelcomeEmail: true
    }),
    outputMapping: (result) => ({
      userId: result.userId,
      email: result.email,
      createdAt: result.createdAt
    })
  })
  .addStep({
    actionId: 'setup-user-preferences',
    inputs: (results) => ({
      userId: results[2].userId,
      preferences: results[0]?.preferences || {}
    })
  })
  .addStep({
    actionId: 'send-welcome-email',
    inputs: (results) => ({
      to: results[2].email,
      template: 'welcome',
      variables: {
        name: results[1].name,
        userId: results[2].userId
      }
    }),
    errorHandler: (error, results) => {
      console.log('Email sending failed, but continuing onboarding');
      return { emailSent: false, error: error.message };
    }
  })
  .addStep({
    actionId: 'track-user-event',
    inputs: (results) => ({
      userId: results[2].userId,
      event: 'user_onboarded',
      properties: {
        source: results[0]?.source || 'unknown',
        emailSent: results[4]?.emailSent !== false
      }
    })
  });

// Execute pipeline
const pipelineResult = await onboardingPipeline.execute({
  email: 'newuser@example.com',
  name: 'Alice Johnson',
  source: 'landing_page',
  preferences: {
    newsletter: true,
    notifications: false
  }
});

if (pipelineResult.success) {
  console.log('🎊 User onboarding completed successfully');
  console.log('Final result:', pipelineResult.results[pipelineResult.results.length - 1]);
} else {
  console.error(`💥 Pipeline failed at step ${pipelineResult.failedAtStep + 1}: ${pipelineResult.error}`);
}

// Print step summary
pipelineResult.stepResults.forEach((step, index) => {
  if (step.skipped) {
    console.log(`Step ${index + 1} (${step.actionId}): Skipped`);
  } else if (step.error) {
    console.log(`Step ${index + 1} (${step.actionId}): Failed - ${step.error}`);
  } else {
    console.log(`Step ${index + 1} (${step.actionId}): Success (${step.duration}ms)`);
  }
});
```

## Action Development and Custom Actions

### Creating Custom Actions

```typescript
interface CustomActionDefinition {
  name: string;
  description: string;
  category: ActionCategory;
  inputs: ActionInput[];
  outputs: ActionOutput[];
  implementation: {
    type: 'javascript' | 'python' | 'webhook' | 'docker';
    code?: string;
    endpoint?: string;
    image?: string;
    environment?: Record<string, string>;
  };
  settings?: {
    timeout?: number;
    retryPolicy?: RetryPolicy;
    resources?: {
      memory?: string;
      cpu?: string;
    };
  };
  tags?: string[];
}

class CustomActionBuilder {
  constructor(private client: TolstoyClient) {}
  
  async createJavaScriptAction(definition: CustomActionDefinition): Promise<Action> {
    const actionDefinition = {
      ...definition,
      implementation: {
        type: 'javascript' as const,
        code: this.wrapJavaScriptCode(definition.implementation.code!),
        environment: {
          NODE_VERSION: '18',
          ...definition.implementation.environment
        }
      }
    };
    
    // Validate the action first
    const validation = await this.client.actions.validate(actionDefinition);
    
    if (!validation.valid) {
      throw new Error(`Action validation failed: ${validation.errors.join(', ')}`);
    }
    
    const action = await this.client.actions.create(actionDefinition);
    console.log(`✅ Created custom action: ${action.id}`);
    
    return action;
  }
  
  private wrapJavaScriptCode(userCode: string): string {
    return `
      // Action runtime wrapper
      const { inputs, context, secrets } = require('./runtime');
      const fetch = require('node-fetch');
      const crypto = require('crypto');
      
      async function executeAction() {
        try {
          // User-defined action code
          ${userCode}
          
          // Return the result
          if (typeof result === 'undefined') {
            throw new Error('Action must return a result');
          }
          
          return {
            success: true,
            outputs: result,
            metadata: {
              executedAt: new Date().toISOString(),
              runtime: 'nodejs'
            }
          };
          
        } catch (error) {
          return {
            success: false,
            error: {
              message: error.message,
              stack: error.stack,
              type: error.constructor.name
            }
          };
        }
      }
      
      module.exports = { executeAction };
    `;
  }
  
  async createWebhookAction(definition: CustomActionDefinition): Promise<Action> {
    const actionDefinition = {
      ...definition,
      implementation: {
        type: 'webhook' as const,
        endpoint: definition.implementation.endpoint!,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Action-Id': '{{action.id}}',
          'X-Execution-Id': '{{execution.id}}',
          ...(definition.implementation.environment || {})
        }
      }
    };
    
    const action = await this.client.actions.create(actionDefinition);
    console.log(`✅ Created webhook action: ${action.id}`);
    
    return action;
  }
}

// Example: Create a custom data processing action
const actionBuilder = new CustomActionBuilder(client);

const customDataProcessor = await actionBuilder.createJavaScriptAction({
  name: 'Advanced Data Processor',
  description: 'Process and transform data with custom business logic',
  category: 'data_processing',
  inputs: [
    {
      name: 'data',
      type: 'object',
      required: true,
      description: 'Input data to process'
    },
    {
      name: 'transformations',
      type: 'array',
      required: true,
      description: 'Array of transformation rules'
    },
    {
      name: 'options',
      type: 'object',
      required: false,
      default: {},
      description: 'Processing options'
    }
  ],
  outputs: [
    {
      name: 'processedData',
      type: 'object',
      description: 'Transformed data'
    },
    {
      name: 'stats',
      type: 'object',
      description: 'Processing statistics'
    }
  ],
  implementation: {
    type: 'javascript',
    code: `
      const data = inputs.data;
      const transformations = inputs.transformations;
      const options = inputs.options || {};
      
      let processedData = { ...data };
      const stats = {
        recordsProcessed: 0,
        transformationsApplied: 0,
        errors: []
      };
      
      // Apply transformations
      for (const transformation of transformations) {
        try {
          if (transformation.type === 'map') {
            if (Array.isArray(processedData[transformation.field])) {
              processedData[transformation.field] = processedData[transformation.field]
                .map(item => applyExpression(item, transformation.expression));
            }
          } else if (transformation.type === 'filter') {
            if (Array.isArray(processedData[transformation.field])) {
              const originalLength = processedData[transformation.field].length;
              processedData[transformation.field] = processedData[transformation.field]
                .filter(item => evaluateCondition(item, transformation.condition));
              stats.recordsFiltered = originalLength - processedData[transformation.field].length;
            }
          } else if (transformation.type === 'aggregate') {
            if (Array.isArray(processedData[transformation.field])) {
              const values = processedData[transformation.field]
                .map(item => item[transformation.aggregateField])
                .filter(val => val != null);
              
              switch (transformation.operation) {
                case 'sum':
                  processedData[transformation.outputField] = values.reduce((sum, val) => sum + val, 0);
                  break;
                case 'avg':
                  processedData[transformation.outputField] = values.reduce((sum, val) => sum + val, 0) / values.length;
                  break;
                case 'count':
                  processedData[transformation.outputField] = values.length;
                  break;
              }
            }
          }
          
          stats.transformationsApplied++;
          
        } catch (error) {
          stats.errors.push({
            transformation: transformation.type,
            error: error.message
          });
        }
      }
      
      // Count processed records
      stats.recordsProcessed = Array.isArray(processedData) 
        ? processedData.length 
        : Object.keys(processedData).length;
      
      const result = {
        processedData,
        stats
      };
      
      function applyExpression(item, expression) {
        // Simple expression evaluator (in production, use a proper expression library)
        return eval(expression.replace(/\\$\\{([^}]+)\\}/g, 'item.$1'));
      }
      
      function evaluateCondition(item, condition) {
        // Simple condition evaluator
        const { field, operator, value } = condition;
        const itemValue = item[field];
        
        switch (operator) {
          case '==': return itemValue == value;
          case '!=': return itemValue != value;
          case '>': return itemValue > value;
          case '<': return itemValue < value;
          case '>=': return itemValue >= value;
          case '<=': return itemValue <= value;
          case 'contains': return String(itemValue).includes(value);
          default: return true;
        }
      }
    `
  },
  settings: {
    timeout: 30000,
    retryPolicy: {
      maxRetries: 2,
      retryDelay: 1000
    }
  },
  tags: ['custom', 'data-processing', 'transformations']
});

// Test the custom action
const testExecution = await client.actions.execute(customDataProcessor.id, {
  data: {
    users: [
      { id: 1, name: 'John', age: 25, score: 85 },
      { id: 2, name: 'Jane', age: 30, score: 92 },
      { id: 3, name: 'Bob', age: 22, score: 78 }
    ]
  },
  transformations: [
    {
      type: 'filter',
      field: 'users',
      condition: { field: 'age', operator: '>=', value: 25 }
    },
    {
      type: 'aggregate',
      field: 'users',
      operation: 'avg',
      aggregateField: 'score',
      outputField: 'averageScore'
    }
  ]
});

console.log('Custom action result:', testExecution.outputs);
```

## Related Resources

<CardGroup cols={2}>
  <Card title="Action Execution" icon="play" href="/sdk/resources/actions/execute">
    Advanced action execution patterns and monitoring
  </Card>
  <Card title="Custom Actions" icon="code" href="/sdk/resources/actions/custom">
    Build and deploy custom actions for your use cases
  </Card>
</CardGroup>

<CardGroup cols={2}>
  <Card title="Error Handling" icon="shield-exclamation" href="/sdk/guides/error-handling">
    Robust error handling strategies for action execution
  </Card>
  <Card title="Performance Optimization" icon="performance" href="/sdk/guides/performance">
    Optimize action execution for scale and efficiency
  </Card>
</CardGroup>

---

*The Actions SDK provides the foundation for building powerful automation workflows. From simple executions to complex pipelines, use these patterns to create robust, scalable automation solutions.*