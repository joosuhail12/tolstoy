---
title: "Flows SDK Overview"
description: "Complete guide to managing workflows with the Tolstoy TypeScript SDK - from creation to execution and monitoring."
---

# Flows SDK Overview

The Flows SDK provides a comprehensive interface for managing workflows in your applications. This includes creating, updating, executing, and monitoring workflows with full TypeScript support and excellent developer experience.

## Quick Start

```typescript
import { TolstoyClient } from '@joosuhail/tolstoy-sdk';

const client = new TolstoyClient({
  orgId: process.env.TOLSTOY_ORG_ID!,
  userId: process.env.TOLSTOY_USER_ID!
});

// List all flows
const flows = await client.flows.list();

// Execute a specific flow
const execution = await client.flows.execute('flow_abc123', {
  email: 'user@example.com',
  name: 'John Doe'
});

console.log('Execution started:', execution.id);
```

## Available Methods

### Flow Management

| Method | Description | Returns |
|--------|-------------|---------|
| `list(options?)` | List flows with filtering and pagination | `Promise<Flow[]>` |
| `get(flowId)` | Get detailed flow information | `Promise<Flow>` |
| `create(definition)` | Create a new flow | `Promise<Flow>` |
| `update(flowId, definition)` | Update existing flow | `Promise<Flow>` |
| `delete(flowId)` | Delete a flow | `Promise<void>` |
| `validate(definition)` | Validate flow definition | `Promise<ValidationResult>` |

### Flow Execution

| Method | Description | Returns |
|--------|-------------|---------|
| `execute(flowId, inputs?, options?)` | Execute a flow | `Promise<FlowExecution>` |
| `executeSync(flowId, inputs?, options?)` | Execute synchronously | `Promise<ExecutionResult>` |
| `executeAsync(flowId, inputs?, options?)` | Execute asynchronously | `Promise<FlowExecution>` |
| `cancelExecution(executionId)` | Cancel running execution | `Promise<void>` |
| `retryExecution(executionId)` | Retry failed execution | `Promise<FlowExecution>` |

### Execution Monitoring

| Method | Description | Returns |
|--------|-------------|---------|
| `getExecution(executionId)` | Get execution details | `Promise<FlowExecution>` |
| `listExecutions(flowId?, options?)` | List executions | `Promise<FlowExecution[]>` |
| `waitForCompletion(executionId, options?)` | Wait for execution to complete | `Promise<ExecutionResult>` |
| `getExecutionLogs(executionId, options?)` | Get execution logs | `Promise<ExecutionLog[]>` |
| `streamExecution(executionId)` | Stream execution updates | `AsyncIterator<ExecutionUpdate>` |

### Metrics and Analytics

| Method | Description | Returns |
|--------|-------------|---------|
| `getMetrics(flowId, options?)` | Get flow performance metrics | `Promise<FlowMetrics>` |
| `getAnalytics(flowId, options?)` | Get detailed analytics | `Promise<FlowAnalytics>` |
| `exportExecutions(flowId, options?)` | Export execution data | `Promise<ExportResult>` |

## Core Types

### Flow Definition

```typescript
interface Flow {
  id: string;
  name: string;
  description?: string;
  version: number;
  status: 'active' | 'inactive' | 'draft';
  
  // Flow structure
  inputs: FlowInput[];
  steps: FlowStep[];
  outputs?: FlowOutput[];
  
  // Configuration
  settings: FlowSettings;
  tags: string[];
  
  // Metadata
  created_at: string;
  updated_at: string;
  created_by: User;
  
  // Statistics
  stats: FlowStats;
}

interface FlowInput {
  name: string;
  type: 'string' | 'number' | 'boolean' | 'object' | 'array';
  required: boolean;
  description?: string;
  default?: any;
  validation?: ValidationRule;
}

interface FlowStep {
  key: string;
  name: string;
  action: string;
  inputs: Record<string, any>;
  executeIf?: string;
  onError?: ErrorHandler;
  retryPolicy?: RetryPolicy;
}
```

### Flow Execution

```typescript
interface FlowExecution {
  id: string;
  flow_id: string;
  status: ExecutionStatus;
  mode: 'sync' | 'async';
  
  // Input/Output
  inputs: Record<string, any>;
  outputs?: Record<string, any>;
  
  // Execution details
  started_at: string;
  completed_at?: string;
  duration_ms?: number;
  
  // Step execution
  steps: StepExecution[];
  current_step?: string;
  
  // Error information
  error?: ExecutionError;
  
  // Metadata
  metadata: ExecutionMetadata;
}

type ExecutionStatus = 
  | 'pending'
  | 'running'
  | 'completed' 
  | 'failed'
  | 'cancelled'
  | 'timeout';

interface StepExecution {
  key: string;
  status: ExecutionStatus;
  started_at: string;
  completed_at?: string;
  duration_ms?: number;
  inputs: Record<string, any>;
  outputs?: Record<string, any>;
  error?: StepError;
}
```

## Basic Usage Examples

### Creating and Managing Flows

<CodeGroup>
```typescript Create Flow
const flowDefinition = {
  name: 'User Onboarding',
  description: 'Automated user welcome process',
  inputs: [
    {
      name: 'email',
      type: 'string' as const,
      required: true,
      description: 'User email address'
    },
    {
      name: 'name',
      type: 'string' as const,
      required: false,
      description: 'User full name'
    }
  ],
  steps: [
    {
      key: 'validate-email',
      name: 'Validate Email',
      action: 'email-validator',
      inputs: {
        email: '{{inputs.email}}'
      }
    },
    {
      key: 'send-welcome',
      name: 'Send Welcome Email',
      action: 'send-email',
      inputs: {
        to: '{{inputs.email}}',
        template: 'welcome',
        variables: {
          name: '{{inputs.name}}'
        }
      },
      executeIf: '{{steps.validate-email.outputs.valid}} == true'
    }
  ],
  settings: {
    timeout: 300000,
    retryPolicy: {
      maxRetries: 3,
      retryDelay: 1000
    }
  }
};

const flow = await client.flows.create(flowDefinition);
console.log('Created flow:', flow.id);
```

```typescript Update Flow
// Get existing flow
const existingFlow = await client.flows.get('flow_abc123');

// Modify the definition
const updatedDefinition = {
  ...existingFlow,
  steps: [
    ...existingFlow.steps,
    {
      key: 'notify-slack',
      name: 'Notify Team',
      action: 'slack-notification',
      inputs: {
        channel: '#onboarding',
        message: 'New user: {{inputs.email}}'
      }
    }
  ],
  version: existingFlow.version + 1
};

const updatedFlow = await client.flows.update('flow_abc123', updatedDefinition);
console.log('Updated to version:', updatedFlow.version);
```
</CodeGroup>

### Flow Execution

<CodeGroup>
```typescript Basic Execution
// Simple execution
const execution = await client.flows.execute('flow_abc123', {
  email: 'user@example.com',
  name: 'John Doe'
});

console.log('Execution ID:', execution.id);
console.log('Status:', execution.status);
```

```typescript Synchronous Execution
// Wait for completion (up to 30 seconds)
try {
  const result = await client.flows.executeSync('flow_abc123', {
    email: 'user@example.com',
    name: 'John Doe'
  }, {
    timeout: 30000
  });
  
  console.log('Flow completed successfully');
  console.log('Outputs:', result.outputs);
  
} catch (error) {
  if (error.code === 'EXECUTION_TIMEOUT') {
    console.log('Flow is still running, check status later');
  } else {
    console.error('Flow execution failed:', error);
  }
}
```

```typescript Asynchronous Execution with Monitoring
// Start async execution
const execution = await client.flows.executeAsync('flow_abc123', {
  email: 'user@example.com',
  name: 'John Doe'
});

console.log('Started async execution:', execution.id);

// Monitor progress
const result = await client.flows.waitForCompletion(execution.id, {
  timeout: 300000, // 5 minutes
  pollInterval: 1000 // Check every second
});

if (result.status === 'completed') {
  console.log('Flow completed successfully');
  console.log('Final outputs:', result.outputs);
} else {
  console.error('Flow failed:', result.error);
}
```
</CodeGroup>

## Advanced Usage Patterns

### Batch Processing

```typescript
async function processBatchUsers(users: UserData[]) {
  const batchSize = 10;
  const results = [];
  
  // Process users in batches to avoid overwhelming the system
  for (let i = 0; i < users.length; i += batchSize) {
    const batch = users.slice(i, i + batchSize);
    
    // Execute flows in parallel for each batch
    const batchPromises = batch.map(user => 
      client.flows.execute('user-onboarding-flow', {
        email: user.email,
        name: user.name,
        company: user.company
      })
    );
    
    const batchResults = await Promise.allSettled(batchPromises);
    results.push(...batchResults);
    
    // Log progress
    console.log(`Processed ${i + batch.length}/${users.length} users`);
    
    // Small delay between batches
    if (i + batchSize < users.length) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  
  // Analyze results
  const successful = results.filter(r => r.status === 'fulfilled').length;
  const failed = results.filter(r => r.status === 'rejected').length;
  
  console.log(`Batch complete: ${successful} successful, ${failed} failed`);
  return results;
}
```

### Real-time Execution Streaming

```typescript
async function streamFlowExecution(flowId: string, inputs: any) {
  // Start the execution
  const execution = await client.flows.executeAsync(flowId, inputs);
  
  console.log(`Started execution: ${execution.id}`);
  console.log('Streaming updates...\n');
  
  // Stream real-time updates
  for await (const update of client.flows.streamExecution(execution.id)) {
    switch (update.type) {
      case 'step_started':
        console.log(`ðŸƒ Started: ${update.step.name}`);
        break;
        
      case 'step_completed':
        const duration = update.step.duration_ms;
        console.log(`âœ… Completed: ${update.step.name} (${duration}ms)`);
        break;
        
      case 'step_failed':
        console.log(`âŒ Failed: ${update.step.name} - ${update.step.error?.message}`);
        break;
        
      case 'execution_completed':
        console.log(`\nðŸŽ‰ Execution completed in ${update.execution.duration_ms}ms`);
        return update.execution;
        
      case 'execution_failed':
        console.log(`\nðŸ’¥ Execution failed: ${update.execution.error?.message}`);
        throw new Error(update.execution.error?.message);
    }
  }
}

// Usage
try {
  const result = await streamFlowExecution('flow_abc123', {
    email: 'user@example.com'
  });
  console.log('Final result:', result.outputs);
} catch (error) {
  console.error('Execution failed:', error);
}
```

### Error Handling and Retry Logic

```typescript
class FlowExecutor {
  constructor(private client: TolstoyClient) {}
  
  async executeWithRetry(
    flowId: string, 
    inputs: any, 
    options: {
      maxRetries?: number;
      retryDelay?: number;
      retryCondition?: (error: any) => boolean;
    } = {}
  ) {
    const {
      maxRetries = 3,
      retryDelay = 1000,
      retryCondition = (error) => error.retriable !== false
    } = options;
    
    let lastError;
    
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        const result = await this.client.flows.execute(flowId, inputs);
        
        if (result.status === 'completed') {
          return result;
        } else if (result.status === 'failed') {
          throw new Error(`Flow execution failed: ${result.error?.message}`);
        }
        
        // Wait for completion
        return await this.client.flows.waitForCompletion(result.id);
        
      } catch (error) {
        lastError = error;
        
        if (attempt === maxRetries || !retryCondition(error)) {
          throw error;
        }
        
        console.log(`Attempt ${attempt + 1} failed, retrying in ${retryDelay}ms...`);
        await new Promise(resolve => setTimeout(resolve, retryDelay));
        
        // Exponential backoff
        retryDelay *= 2;
      }
    }
    
    throw lastError;
  }
  
  async executeBulkWithErrorHandling(executions: { flowId: string; inputs: any }[]) {
    const results = await Promise.allSettled(
      executions.map(({ flowId, inputs }) => 
        this.executeWithRetry(flowId, inputs)
      )
    );
    
    const successful = results.filter((r): r is PromiseFulfilledResult<any> => 
      r.status === 'fulfilled'
    );
    
    const failed = results.filter((r): r is PromiseRejectedResult => 
      r.status === 'rejected'
    );
    
    return {
      successful: successful.map(r => r.value),
      failed: failed.map(r => r.reason),
      summary: {
        total: executions.length,
        successful: successful.length,
        failed: failed.length,
        successRate: successful.length / executions.length
      }
    };
  }
}

// Usage
const executor = new FlowExecutor(client);

const results = await executor.executeBulkWithErrorHandling([
  { flowId: 'onboarding-flow', inputs: { email: 'user1@example.com' } },
  { flowId: 'onboarding-flow', inputs: { email: 'user2@example.com' } },
  { flowId: 'onboarding-flow', inputs: { email: 'user3@example.com' } }
]);

console.log(`Success rate: ${(results.summary.successRate * 100).toFixed(1)}%`);
```

## Performance and Best Practices

### Connection Management

```typescript
// Singleton client pattern for better connection reuse
class TolstoyService {
  private static instance: TolstoyService;
  private client: TolstoyClient;
  
  private constructor() {
    this.client = new TolstoyClient({
      orgId: process.env.TOLSTOY_ORG_ID!,
      userId: process.env.TOLSTOY_USER_ID!,
      
      // Optimize for production use
      timeout: 30000,
      retries: 3,
      retryDelay: 1000,
      
      // Connection pooling
      httpOptions: {
        keepAlive: true,
        maxSockets: 10,
        timeout: 30000
      }
    });
  }
  
  static getInstance(): TolstoyService {
    if (!TolstoyService.instance) {
      TolstoyService.instance = new TolstoyService();
    }
    return TolstoyService.instance;
  }
  
  getClient(): TolstoyClient {
    return this.client;
  }
}

// Usage
const tolstoy = TolstoyService.getInstance().getClient();
```

### Caching Strategy

```typescript
import { LRUCache } from 'lru-cache';

class CachedFlowService {
  private flowCache = new LRUCache<string, Flow>({
    max: 100,
    ttl: 5 * 60 * 1000 // 5 minutes
  });
  
  private executionCache = new LRUCache<string, FlowExecution>({
    max: 500,
    ttl: 30 * 1000 // 30 seconds for executions
  });
  
  constructor(private client: TolstoyClient) {}
  
  async getFlow(flowId: string, useCache = true): Promise<Flow> {
    if (useCache && this.flowCache.has(flowId)) {
      return this.flowCache.get(flowId)!;
    }
    
    const flow = await this.client.flows.get(flowId);
    this.flowCache.set(flowId, flow);
    return flow;
  }
  
  async getExecution(executionId: string, useCache = true): Promise<FlowExecution> {
    if (useCache && this.executionCache.has(executionId)) {
      return this.executionCache.get(executionId)!;
    }
    
    const execution = await this.client.flows.getExecution(executionId);
    
    // Only cache completed executions
    if (['completed', 'failed', 'cancelled'].includes(execution.status)) {
      this.executionCache.set(executionId, execution);
    }
    
    return execution;
  }
  
  // Invalidate cache when flow is updated
  async updateFlow(flowId: string, definition: any): Promise<Flow> {
    const flow = await this.client.flows.update(flowId, definition);
    this.flowCache.set(flowId, flow);
    return flow;
  }
}
```

## Integration Examples

### Express.js Middleware

```typescript
import express from 'express';
import { TolstoyClient } from '@joosuhail/tolstoy-sdk';

const app = express();
const tolstoy = new TolstoyClient({
  orgId: process.env.TOLSTOY_ORG_ID!,
  userId: process.env.TOLSTOY_USER_ID!
});

// Middleware for flow execution
app.post('/api/workflows/:flowId/execute', async (req, res) => {
  try {
    const { flowId } = req.params;
    const inputs = req.body;
    
    // Execute flow asynchronously
    const execution = await tolstoy.flows.executeAsync(flowId, inputs);
    
    res.json({
      success: true,
      execution_id: execution.id,
      status: execution.status
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Check execution status
app.get('/api/executions/:executionId', async (req, res) => {
  try {
    const { executionId } = req.params;
    const execution = await tolstoy.flows.getExecution(executionId);
    
    res.json({
      success: true,
      execution
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
```

### React Hook

```typescript
import { useState, useEffect, useCallback } from 'react';
import { TolstoyClient, FlowExecution } from '@joosuhail/tolstoy-sdk';

const client = new TolstoyClient({
  orgId: process.env.REACT_APP_TOLSTOY_ORG_ID!,
  userId: process.env.REACT_APP_TOLSTOY_USER_ID!
});

interface UseFlowExecutionResult {
  execute: (inputs: any) => Promise<void>;
  execution: FlowExecution | null;
  loading: boolean;
  error: string | null;
  progress: number;
}

export function useFlowExecution(flowId: string): UseFlowExecutionResult {
  const [execution, setExecution] = useState<FlowExecution | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [progress, setProgress] = useState(0);
  
  const execute = useCallback(async (inputs: any) => {
    setLoading(true);
    setError(null);
    setProgress(0);
    
    try {
      // Start execution
      const exec = await client.flows.executeAsync(flowId, inputs);
      setExecution(exec);
      
      // Monitor progress
      for await (const update of client.flows.streamExecution(exec.id)) {
        setExecution(update.execution);
        
        if (update.type === 'step_completed' && update.execution.steps) {
          const completed = update.execution.steps.filter(
            s => s.status === 'completed'
          ).length;
          const total = update.execution.steps.length;
          setProgress((completed / total) * 100);
        }
        
        if (['completed', 'failed', 'cancelled'].includes(update.execution.status)) {
          setProgress(100);
          break;
        }
      }
      
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setLoading(false);
    }
  }, [flowId]);
  
  return {
    execute,
    execution,
    loading,
    error,
    progress
  };
}

// Usage in component
function WorkflowButton({ flowId }: { flowId: string }) {
  const { execute, execution, loading, error, progress } = useFlowExecution(flowId);
  
  const handleExecute = () => {
    execute({
      email: 'user@example.com',
      name: 'Test User'
    });
  };
  
  return (
    <div>
      <button onClick={handleExecute} disabled={loading}>
        {loading ? 'Executing...' : 'Run Workflow'}
      </button>
      
      {loading && (
        <div>
          <div>Progress: {progress.toFixed(0)}%</div>
          <progress value={progress} max={100} />
        </div>
      )}
      
      {execution && (
        <div>Status: {execution.status}</div>
      )}
      
      {error && (
        <div style={{ color: 'red' }}>Error: {error}</div>
      )}
    </div>
  );
}
```

## Related Resources

<CardGroup cols={2}>
  <Card title="Flow Creation" icon="plus" href="/sdk/resources/flows/create">
    Learn how to create and update flows programmatically
  </Card>
  <Card title="Flow Execution" icon="play" href="/sdk/resources/flows/execute">
    Master flow execution patterns and monitoring
  </Card>
</CardGroup>

<CardGroup cols={2}>
  <Card title="Error Handling" icon="shield-exclamation" href="/sdk/guides/error-handling">
    Implement robust error handling for production use
  </Card>
  <Card title="TypeScript Tips" icon="code" href="/sdk/guides/typescript-tips">
    Advanced TypeScript patterns and best practices
  </Card>
</CardGroup>

---

*The Flows SDK provides everything you need to integrate workflow automation into your applications. Use these patterns and examples to build robust, scalable automation solutions.*