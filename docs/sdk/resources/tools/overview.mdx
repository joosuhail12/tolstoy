---
title: "Tools SDK Overview"
description: "Complete guide to managing external tool integrations with the Tolstoy TypeScript SDK - from creation to authentication and monitoring."
---

# Tools SDK Overview

The Tools SDK provides comprehensive management of external tool integrations in your workflows. This includes creating tool configurations, managing authentication credentials, testing connections, and monitoring health status.

## Quick Start

```typescript
import { TolstoyClient } from '@joosuhail/tolstoy-sdk';

const client = new TolstoyClient({
  orgId: process.env.TOLSTOY_ORG_ID!,
  userId: process.env.TOLSTOY_USER_ID!
});

// List all tools
const tools = await client.tools.list();

// Create a new API integration
const githubTool = await client.tools.create({
  name: 'GitHub API',
  baseUrl: 'https://api.github.com',
  authType: 'bearer',
  description: 'GitHub REST API integration'
});

// Test the connection
const testResult = await client.tools.test(githubTool.id);
console.log('Connection test:', testResult.success);
```

## Available Methods

### Tool Management

| Method | Description | Returns |
|--------|-------------|---------|
| `list(options?)` | List tools with filtering and pagination | `Promise<Tool[]>` |
| `get(toolId)` | Get detailed tool configuration | `Promise<Tool>` |
| `create(config)` | Create a new tool integration | `Promise<Tool>` |
| `update(toolId, config)` | Update existing tool | `Promise<Tool>` |
| `delete(toolId)` | Delete a tool | `Promise<void>` |
| `validate(config)` | Validate tool configuration | `Promise<ValidationResult>` |

### Authentication Management

| Method | Description | Returns |
|--------|-------------|---------|
| `setCredentials(toolId, credentials)` | Set authentication credentials | `Promise<void>` |
| `getCredentials(toolId)` | Get masked credential information | `Promise<CredentialInfo>` |
| `updateCredentials(toolId, credentials)` | Update existing credentials | `Promise<void>` |
| `revokeCredentials(toolId)` | Remove stored credentials | `Promise<void>` |
| `refreshToken(toolId)` | Refresh OAuth tokens | `Promise<TokenInfo>` |

### Connection Testing & Health

| Method | Description | Returns |
|--------|-------------|---------|
| `test(toolId, options?)` | Test tool connectivity | `Promise<TestResult>` |
| `healthCheck(toolId?)` | Check health of one or all tools | `Promise<HealthStatus>` |
| `getStatus(toolId)` | Get current connection status | `Promise<ConnectionStatus>` |
| `getMetrics(toolId, options?)` | Get usage and performance metrics | `Promise<ToolMetrics>` |

### Usage Analytics

| Method | Description | Returns |
|--------|-------------|---------|
| `getUsageStats(toolId, options?)` | Get detailed usage statistics | `Promise<UsageStats>` |
| `getErrorLogs(toolId, options?)` | Get connection error logs | `Promise<ErrorLog[]>` |
| `exportConfiguration(toolId)` | Export tool configuration | `Promise<ConfigExport>` |
| `importConfiguration(config)` | Import tool configuration | `Promise<Tool>` |

## Core Types

### Tool Configuration

```typescript
interface Tool {
  id: string;
  name: string;
  description?: string;
  baseUrl: string;
  authType: AuthenticationType;
  
  // Connection settings
  headers?: Record<string, string>;
  timeout?: number;
  retryPolicy?: RetryPolicy;
  
  // Authentication configuration
  authConfig?: AuthenticationConfig;
  
  // SSL/TLS settings
  sslConfig?: SSLConfig;
  
  // Rate limiting
  rateLimits?: RateLimitConfig;
  
  // Metadata
  tags: string[];
  status: 'active' | 'inactive' | 'error';
  
  // Statistics
  stats: ToolStats;
  
  // Audit information
  created_at: string;
  updated_at: string;
  created_by: User;
  last_used_at?: string;
}

type AuthenticationType = 
  | 'none'
  | 'api_key'
  | 'bearer'
  | 'basic'
  | 'oauth1'
  | 'oauth2'
  | 'custom';

interface AuthenticationConfig {
  type: AuthenticationType;
  
  // API Key authentication
  apiKey?: {
    headerName: string;
    prefix?: string; // e.g., "Bearer ", "API-KEY "
  };
  
  // OAuth configuration
  oauth?: {
    authUrl: string;
    tokenUrl: string;
    scopes?: string[];
    clientId?: string;
    redirectUri?: string;
  };
  
  // Basic authentication
  basic?: {
    username?: string;
    passwordField?: string;
  };
  
  // Custom authentication
  custom?: {
    headers: Record<string, string>;
    queryParams?: Record<string, string>;
  };
}

interface ToolStats {
  totalRequests: number;
  successfulRequests: number;
  failedRequests: number;
  averageResponseTime: number;
  lastSuccessfulRequest?: string;
  lastFailedRequest?: string;
  uptime: number; // Percentage
}
```

### Test Results & Health Status

```typescript
interface TestResult {
  success: boolean;
  responseTime: number;
  statusCode?: number;
  error?: string;
  
  // Detailed test information
  tests: {
    connectivity: TestStatus;
    authentication: TestStatus;
    permissions: TestStatus;
    endpoints: EndpointTest[];
  };
  
  // Performance metrics
  performance: {
    dnsLookup: number;
    tcpConnection: number;
    tlsHandshake?: number;
    serverProcessing: number;
    contentTransfer: number;
  };
  
  timestamp: string;
}

interface TestStatus {
  passed: boolean;
  message: string;
  details?: any;
}

interface EndpointTest {
  endpoint: string;
  method: string;
  passed: boolean;
  responseTime: number;
  statusCode: number;
  error?: string;
}

interface HealthStatus {
  toolId: string;
  status: 'healthy' | 'degraded' | 'unhealthy' | 'unknown';
  lastChecked: string;
  
  checks: {
    connectivity: HealthCheck;
    authentication: HealthCheck;
    rateLimits: HealthCheck;
    uptime: HealthCheck;
  };
  
  metrics: {
    uptime: number;
    averageResponseTime: number;
    errorRate: number;
    requestVolume: number;
  };
}

interface HealthCheck {
  status: 'pass' | 'fail' | 'warn';
  message: string;
  value?: number;
  threshold?: number;
  lastUpdated: string;
}
```

## Basic Usage Examples

### Creating Tool Integrations

<CodeGroup>
```typescript API Key Authentication
// Simple API key authentication
const slackTool = await client.tools.create({
  name: 'Slack Workspace',
  description: 'Team communication platform',
  baseUrl: 'https://slack.com/api',
  authType: 'bearer',
  authConfig: {
    type: 'bearer',
    apiKey: {
      headerName: 'Authorization',
      prefix: 'Bearer '
    }
  },
  headers: {
    'Content-Type': 'application/json',
    'User-Agent': 'Tolstoy-Integration/1.0'
  },
  timeout: 30000,
  tags: ['communication', 'notifications']
});

// Set the actual API token
await client.tools.setCredentials(slackTool.id, {
  token: process.env.SLACK_BOT_TOKEN
});
```

```typescript OAuth2 Integration
// OAuth2 authentication setup
const googleTool = await client.tools.create({
  name: 'Google Sheets API',
  description: 'Google Sheets integration for data management',
  baseUrl: 'https://sheets.googleapis.com/v4',
  authType: 'oauth2',
  authConfig: {
    type: 'oauth2',
    oauth: {
      authUrl: 'https://accounts.google.com/o/oauth2/v2/auth',
      tokenUrl: 'https://oauth2.googleapis.com/token',
      scopes: [
        'https://www.googleapis.com/auth/spreadsheets',
        'https://www.googleapis.com/auth/drive.file'
      ],
      clientId: process.env.GOOGLE_CLIENT_ID,
      redirectUri: 'https://your-app.com/oauth/callback'
    }
  },
  rateLimits: {
    requestsPerSecond: 10,
    requestsPerMinute: 100,
    requestsPerDay: 50000
  }
});

// OAuth credentials will be set through the OAuth flow
```

```typescript Database Connection
// Database tool configuration
const dbTool = await client.tools.create({
  name: 'PostgreSQL Database',
  description: 'Primary application database',
  baseUrl: 'postgresql://localhost:5432/myapp',
  authType: 'basic',
  authConfig: {
    type: 'basic',
    basic: {
      username: 'app_user',
      passwordField: 'password'
    }
  },
  sslConfig: {
    enabled: true,
    rejectUnauthorized: false,
    ca: process.env.DB_SSL_CA,
    cert: process.env.DB_SSL_CERT,
    key: process.env.DB_SSL_KEY
  },
  timeout: 5000,
  retryPolicy: {
    maxRetries: 3,
    retryDelay: 1000,
    exponentialBackoff: true
  }
});

await client.tools.setCredentials(dbTool.id, {
  username: process.env.DB_USERNAME,
  password: process.env.DB_PASSWORD
});
```
</CodeGroup>

### Testing and Health Monitoring

<CodeGroup>
```typescript Connection Testing
// Comprehensive connection test
async function testToolConnection(toolId: string) {
  console.log('Testing tool connection...');
  
  const testResult = await client.tools.test(toolId, {
    includePerformance: true,
    testEndpoints: [
      { path: '/health', method: 'GET' },
      { path: '/api/v1/status', method: 'GET' }
    ],
    timeout: 30000
  });
  
  console.log(`Overall test result: ${testResult.success ? '✅ PASS' : '❌ FAIL'}`);
  console.log(`Response time: ${testResult.responseTime}ms`);
  
  // Detailed test results
  if (testResult.tests.connectivity.passed) {
    console.log('✅ Connectivity: OK');
  } else {
    console.log('❌ Connectivity:', testResult.tests.connectivity.message);
  }
  
  if (testResult.tests.authentication.passed) {
    console.log('✅ Authentication: OK');
  } else {
    console.log('❌ Authentication:', testResult.tests.authentication.message);
  }
  
  // Performance breakdown
  console.log('\nPerformance breakdown:');
  console.log(`  DNS lookup: ${testResult.performance.dnsLookup}ms`);
  console.log(`  TCP connection: ${testResult.performance.tcpConnection}ms`);
  if (testResult.performance.tlsHandshake) {
    console.log(`  TLS handshake: ${testResult.performance.tlsHandshake}ms`);
  }
  console.log(`  Server processing: ${testResult.performance.serverProcessing}ms`);
  console.log(`  Content transfer: ${testResult.performance.contentTransfer}ms`);
  
  return testResult;
}

// Usage
const testResult = await testToolConnection('tool_abc123');
```

```typescript Health Monitoring
// Set up health monitoring for all tools
async function monitorToolHealth() {
  const tools = await client.tools.list();
  
  for (const tool of tools) {
    try {
      const health = await client.tools.healthCheck(tool.id);
      
      console.log(`\n📊 Health Status for ${tool.name}:`);
      console.log(`Status: ${getHealthEmoji(health.status)} ${health.status.toUpperCase()}`);
      console.log(`Uptime: ${health.metrics.uptime.toFixed(2)}%`);
      console.log(`Avg Response: ${health.metrics.averageResponseTime}ms`);
      console.log(`Error Rate: ${(health.metrics.errorRate * 100).toFixed(2)}%`);
      
      // Check individual health checks
      const checks = health.checks;
      Object.entries(checks).forEach(([checkName, check]) => {
        const emoji = check.status === 'pass' ? '✅' : 
                     check.status === 'warn' ? '⚠️' : '❌';
        console.log(`  ${emoji} ${checkName}: ${check.message}`);
      });
      
      // Alert on unhealthy tools
      if (health.status === 'unhealthy') {
        await sendHealthAlert(tool, health);
      }
      
    } catch (error) {
      console.error(`❌ Failed to check health for ${tool.name}:`, error.message);
    }
  }
}

function getHealthEmoji(status: string): string {
  switch (status) {
    case 'healthy': return '🟢';
    case 'degraded': return '🟡';
    case 'unhealthy': return '🔴';
    default: return '⚫';
  }
}

async function sendHealthAlert(tool: Tool, health: HealthStatus) {
  // Implement your alerting logic here
  console.log(`🚨 ALERT: ${tool.name} is unhealthy!`);
  
  // Send to monitoring service, Slack, email, etc.
  // await notificationService.send({
  //   type: 'tool_health_alert',
  //   tool: tool.name,
  //   status: health.status,
  //   details: health.checks
  // });
}

// Run health monitoring
await monitorToolHealth();
```
</CodeGroup>

### Credential Management

<CodeGroup>
```typescript Secure Credential Storage
// Secure credential management with encryption
class SecureCredentialManager {
  constructor(private client: TolstoyClient) {}
  
  async storeCredentials(toolId: string, credentials: any, options: {
    encrypt?: boolean;
    expiresAt?: Date;
    rotationPolicy?: 'manual' | 'automatic';
    rotationInterval?: number; // days
  } = {}) {
    const {
      encrypt = true,
      expiresAt,
      rotationPolicy = 'manual',
      rotationInterval = 90
    } = options;
    
    // Prepare credential payload
    const credentialPayload = {
      ...credentials,
      metadata: {
        storedAt: new Date().toISOString(),
        expiresAt: expiresAt?.toISOString(),
        rotationPolicy,
        nextRotation: rotationPolicy === 'automatic' 
          ? new Date(Date.now() + rotationInterval * 24 * 60 * 60 * 1000).toISOString()
          : null,
        encrypted: encrypt
      }
    };
    
    await this.client.tools.setCredentials(toolId, credentialPayload);
    
    console.log(`✅ Credentials stored for tool ${toolId}`);
    
    // Schedule rotation reminder if needed
    if (rotationPolicy === 'automatic') {
      this.scheduleRotationReminder(toolId, rotationInterval);
    }
  }
  
  async rotateCredentials(toolId: string, newCredentials: any) {
    try {
      // Test new credentials before rotation
      console.log('🔄 Testing new credentials...');
      const testResult = await this.testCredentials(toolId, newCredentials);
      
      if (!testResult.success) {
        throw new Error(`New credentials failed validation: ${testResult.error}`);
      }
      
      // Store new credentials
      await this.client.tools.updateCredentials(toolId, newCredentials);
      
      // Log rotation
      console.log(`✅ Credentials rotated successfully for tool ${toolId}`);
      
      return { success: true };
      
    } catch (error) {
      console.error(`❌ Credential rotation failed for tool ${toolId}:`, error.message);
      return { success: false, error: error.message };
    }
  }
  
  private async testCredentials(toolId: string, credentials: any): Promise<{ success: boolean; error?: string }> {
    try {
      // Create temporary tool configuration for testing
      const tool = await this.client.tools.get(toolId);
      const testConfig = {
        ...tool,
        id: `${toolId}_test`,
        name: `${tool.name} (Test)`
      };
      
      // This would ideally be a test-only endpoint that doesn't modify data
      // Implementation depends on your testing strategy
      const testResult = await this.client.tools.test(toolId);
      return { success: testResult.success };
      
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
  
  private scheduleRotationReminder(toolId: string, days: number) {
    // Implement rotation reminder logic
    // This could integrate with your task scheduler, monitoring system, etc.
    console.log(`📅 Rotation reminder scheduled for tool ${toolId} in ${days} days`);
  }
  
  async getCredentialStatus(toolId: string) {
    const credInfo = await this.client.tools.getCredentials(toolId);
    
    return {
      hasCredentials: !!credInfo,
      lastUpdated: credInfo?.metadata?.storedAt,
      expiresAt: credInfo?.metadata?.expiresAt,
      nextRotation: credInfo?.metadata?.nextRotation,
      needsRotation: credInfo?.metadata?.expiresAt && 
        new Date(credInfo.metadata.expiresAt) < new Date()
    };
  }
}

// Usage
const credentialManager = new SecureCredentialManager(client);

await credentialManager.storeCredentials('tool_github', {
  token: process.env.GITHUB_TOKEN
}, {
  encrypt: true,
  rotationPolicy: 'automatic',
  rotationInterval: 30 // 30 days
});
```

```typescript OAuth Token Management
// OAuth token refresh and management
class OAuthTokenManager {
  constructor(private client: TolstoyClient) {}
  
  async refreshOAuthToken(toolId: string): Promise<void> {
    try {
      console.log(`🔄 Refreshing OAuth token for tool ${toolId}...`);
      
      const tokenInfo = await this.client.tools.refreshToken(toolId);
      
      console.log('✅ OAuth token refreshed successfully');
      console.log(`Token expires at: ${tokenInfo.expiresAt}`);
      
      // Schedule next refresh before expiration
      this.scheduleTokenRefresh(toolId, tokenInfo.expiresAt);
      
    } catch (error) {
      console.error(`❌ Failed to refresh OAuth token for tool ${toolId}:`, error.message);
      
      if (error.message.includes('invalid_grant') || error.message.includes('expired')) {
        console.log('🔐 Re-authorization required - refresh token has expired');
        await this.notifyReauthorizationRequired(toolId);
      }
      
      throw error;
    }
  }
  
  private scheduleTokenRefresh(toolId: string, expiresAt: string) {
    const expirationTime = new Date(expiresAt).getTime();
    const refreshTime = expirationTime - (5 * 60 * 1000); // Refresh 5 minutes before expiration
    const now = Date.now();
    
    if (refreshTime > now) {
      const delay = refreshTime - now;
      
      setTimeout(async () => {
        try {
          await this.refreshOAuthToken(toolId);
        } catch (error) {
          console.error(`Scheduled token refresh failed for ${toolId}:`, error.message);
        }
      }, delay);
      
      console.log(`📅 Next token refresh scheduled in ${Math.round(delay / 1000 / 60)} minutes`);
    }
  }
  
  private async notifyReauthorizationRequired(toolId: string) {
    // Send notification that user needs to re-authorize
    // This could be email, in-app notification, etc.
    console.log(`📧 Sending re-authorization notification for tool ${toolId}`);
  }
  
  async checkTokenStatus(toolId: string): Promise<{
    hasToken: boolean;
    expiresAt?: string;
    needsRefresh: boolean;
    needsReauthorization: boolean;
  }> {
    try {
      const credInfo = await this.client.tools.getCredentials(toolId);
      
      if (!credInfo?.accessToken) {
        return {
          hasToken: false,
          needsRefresh: false,
          needsReauthorization: true
        };
      }
      
      const expiresAt = credInfo.expiresAt;
      const now = new Date();
      const expiration = new Date(expiresAt);
      const needsRefresh = expiration.getTime() - now.getTime() < 10 * 60 * 1000; // Less than 10 minutes
      
      return {
        hasToken: true,
        expiresAt,
        needsRefresh,
        needsReauthorization: false
      };
      
    } catch (error) {
      return {
        hasToken: false,
        needsRefresh: false,
        needsReauthorization: true
      };
    }
  }
}

// Usage
const oauthManager = new OAuthTokenManager(client);

const tokenStatus = await oauthManager.checkTokenStatus('tool_google_sheets');

if (tokenStatus.needsRefresh) {
  await oauthManager.refreshOAuthToken('tool_google_sheets');
} else if (tokenStatus.needsReauthorization) {
  console.log('User needs to re-authorize the integration');
}
```
</CodeGroup>

## Advanced Usage Patterns

### Bulk Tool Management

```typescript
class BulkToolManager {
  constructor(private client: TolstoyClient) {}
  
  async createMultipleTools(toolConfigs: any[]): Promise<{
    successful: Tool[];
    failed: { config: any; error: string }[];
  }> {
    const results = await Promise.allSettled(
      toolConfigs.map(config => this.client.tools.create(config))
    );
    
    const successful: Tool[] = [];
    const failed: { config: any; error: string }[] = [];
    
    results.forEach((result, index) => {
      if (result.status === 'fulfilled') {
        successful.push(result.value);
      } else {
        failed.push({
          config: toolConfigs[index],
          error: result.reason.message
        });
      }
    });
    
    console.log(`✅ Created ${successful.length} tools successfully`);
    console.log(`❌ Failed to create ${failed.length} tools`);
    
    return { successful, failed };
  }
  
  async testAllTools(): Promise<{
    passed: string[];
    failed: { toolId: string; error: string }[];
  }> {
    const tools = await this.client.tools.list();
    const results = await Promise.allSettled(
      tools.map(tool => this.client.tools.test(tool.id))
    );
    
    const passed: string[] = [];
    const failed: { toolId: string; error: string }[] = [];
    
    results.forEach((result, index) => {
      const tool = tools[index];
      
      if (result.status === 'fulfilled' && result.value.success) {
        passed.push(tool.id);
        console.log(`✅ ${tool.name}: Connection OK`);
      } else {
        const error = result.status === 'rejected' 
          ? result.reason.message 
          : result.value.error || 'Unknown error';
        
        failed.push({ toolId: tool.id, error });
        console.log(`❌ ${tool.name}: ${error}`);
      }
    });
    
    return { passed, failed };
  }
  
  async generateToolReport(): Promise<string> {
    const tools = await this.client.tools.list();
    const healthChecks = await Promise.allSettled(
      tools.map(tool => this.client.tools.healthCheck(tool.id))
    );
    
    let report = '# Tool Integration Report\n\n';
    report += `Generated: ${new Date().toISOString()}\n`;
    report += `Total Tools: ${tools.length}\n\n`;
    
    for (let i = 0; i < tools.length; i++) {
      const tool = tools[i];
      const healthCheck = healthChecks[i];
      
      report += `## ${tool.name}\n`;
      report += `- **ID**: ${tool.id}\n`;
      report += `- **Base URL**: ${tool.baseUrl}\n`;
      report += `- **Auth Type**: ${tool.authType}\n`;
      report += `- **Status**: ${tool.status}\n`;
      
      if (healthCheck.status === 'fulfilled') {
        const health = healthCheck.value;
        report += `- **Health**: ${health.status}\n`;
        report += `- **Uptime**: ${health.metrics.uptime.toFixed(2)}%\n`;
        report += `- **Avg Response Time**: ${health.metrics.averageResponseTime}ms\n`;
        report += `- **Error Rate**: ${(health.metrics.errorRate * 100).toFixed(2)}%\n`;
      } else {
        report += `- **Health**: Error - ${healthCheck.reason.message}\n`;
      }
      
      report += '\n';
    }
    
    return report;
  }
}

// Usage
const bulkManager = new BulkToolManager(client);

// Test all tools
const testResults = await bulkManager.testAllTools();
console.log(`\n📊 Test Summary: ${testResults.passed.length} passed, ${testResults.failed.length} failed`);

// Generate comprehensive report
const report = await bulkManager.generateToolReport();
console.log('\n' + report);
```

### Tool Configuration Templates

```typescript
class ToolTemplateManager {
  private templates = new Map<string, any>();
  
  constructor(private client: TolstoyClient) {
    this.initializeTemplates();
  }
  
  private initializeTemplates() {
    // Common tool templates
    this.templates.set('slack', {
      name: 'Slack Integration',
      baseUrl: 'https://slack.com/api',
      authType: 'bearer',
      authConfig: {
        type: 'bearer',
        apiKey: { headerName: 'Authorization', prefix: 'Bearer ' }
      },
      headers: { 'Content-Type': 'application/json' },
      timeout: 30000,
      tags: ['communication', 'notifications']
    });
    
    this.templates.set('github', {
      name: 'GitHub API',
      baseUrl: 'https://api.github.com',
      authType: 'bearer',
      authConfig: {
        type: 'bearer',
        apiKey: { headerName: 'Authorization', prefix: 'Bearer ' }
      },
      headers: { 
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'Tolstoy-Integration'
      },
      timeout: 30000,
      tags: ['development', 'version-control']
    });
    
    this.templates.set('sendgrid', {
      name: 'SendGrid Email API',
      baseUrl: 'https://api.sendgrid.com/v3',
      authType: 'bearer',
      authConfig: {
        type: 'bearer',
        apiKey: { headerName: 'Authorization', prefix: 'Bearer ' }
      },
      headers: { 'Content-Type': 'application/json' },
      rateLimits: {
        requestsPerSecond: 10,
        requestsPerMinute: 600
      },
      timeout: 30000,
      tags: ['email', 'communication']
    });
    
    this.templates.set('postgresql', {
      name: 'PostgreSQL Database',
      baseUrl: 'postgresql://localhost:5432',
      authType: 'basic',
      authConfig: {
        type: 'basic',
        basic: { username: '', passwordField: 'password' }
      },
      sslConfig: { enabled: true, rejectUnauthorized: false },
      timeout: 5000,
      retryPolicy: {
        maxRetries: 3,
        retryDelay: 1000,
        exponentialBackoff: true
      },
      tags: ['database', 'storage']
    });
  }
  
  async createFromTemplate(templateName: string, overrides: any = {}): Promise<Tool> {
    const template = this.templates.get(templateName);
    
    if (!template) {
      throw new Error(`Template '${templateName}' not found. Available templates: ${Array.from(this.templates.keys()).join(', ')}`);
    }
    
    const config = this.mergeDeep(template, overrides);
    
    console.log(`🏗️  Creating tool from template: ${templateName}`);
    const tool = await this.client.tools.create(config);
    
    console.log(`✅ Created ${tool.name} (${tool.id}) from template`);
    return tool;
  }
  
  getTemplateNames(): string[] {
    return Array.from(this.templates.keys());
  }
  
  getTemplate(name: string): any {
    return this.templates.get(name);
  }
  
  addTemplate(name: string, template: any): void {
    this.templates.set(name, template);
    console.log(`➕ Added template: ${name}`);
  }
  
  private mergeDeep(target: any, source: any): any {
    const result = { ...target };
    
    for (const key in source) {
      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
        result[key] = this.mergeDeep(target[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }
    
    return result;
  }
}

// Usage
const templateManager = new ToolTemplateManager(client);

// Create Slack integration from template
const slackTool = await templateManager.createFromTemplate('slack', {
  name: 'Company Slack Workspace',
  description: 'Main company communication channel'
});

// Set credentials
await client.tools.setCredentials(slackTool.id, {
  token: process.env.SLACK_BOT_TOKEN
});

// Create GitHub integration with custom settings
const githubTool = await templateManager.createFromTemplate('github', {
  name: 'GitHub Enterprise',
  baseUrl: 'https://github.company.com/api/v3',
  headers: {
    'Accept': 'application/vnd.github.v3+json',
    'User-Agent': 'CompanyApp-Integration',
    'X-Enterprise-Version': '3.0'
  }
});

console.log('Available templates:', templateManager.getTemplateNames());
```

## Integration Examples

### Express.js Middleware

```typescript
import express from 'express';
import { TolstoyClient } from '@joosuhail/tolstoy-sdk';

const app = express();
const client = new TolstoyClient({
  orgId: process.env.TOLSTOY_ORG_ID!,
  userId: process.env.TOLSTOY_USER_ID!
});

// List all tools
app.get('/api/tools', async (req, res) => {
  try {
    const tools = await client.tools.list({
      status: req.query.status as string,
      tags: req.query.tags ? (req.query.tags as string).split(',') : undefined
    });
    
    res.json({ success: true, tools });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Create new tool
app.post('/api/tools', async (req, res) => {
  try {
    const tool = await client.tools.create(req.body);
    res.json({ success: true, tool });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Test tool connection
app.post('/api/tools/:toolId/test', async (req, res) => {
  try {
    const { toolId } = req.params;
    const testResult = await client.tools.test(toolId);
    
    res.json({
      success: true,
      testResult: {
        success: testResult.success,
        responseTime: testResult.responseTime,
        error: testResult.error
      }
    });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Set tool credentials
app.post('/api/tools/:toolId/credentials', async (req, res) => {
  try {
    const { toolId } = req.params;
    await client.tools.setCredentials(toolId, req.body);
    
    res.json({ success: true, message: 'Credentials updated' });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get tool health status
app.get('/api/tools/:toolId/health', async (req, res) => {
  try {
    const { toolId } = req.params;
    const health = await client.tools.healthCheck(toolId);
    
    res.json({ success: true, health });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});
```

### React Component

```typescript
import React, { useState, useEffect } from 'react';
import { TolstoyClient, Tool, HealthStatus } from '@joosuhail/tolstoy-sdk';

const client = new TolstoyClient({
  orgId: process.env.REACT_APP_TOLSTOY_ORG_ID!,
  userId: process.env.REACT_APP_TOLSTOY_USER_ID!
});

interface ToolWithHealth extends Tool {
  health?: HealthStatus;
  testing?: boolean;
}

export function ToolDashboard() {
  const [tools, setTools] = useState<ToolWithHealth[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    loadTools();
  }, []);
  
  const loadTools = async () => {
    try {
      setLoading(true);
      const toolList = await client.tools.list();
      
      // Load health status for each tool
      const toolsWithHealth = await Promise.all(
        toolList.map(async (tool) => {
          try {
            const health = await client.tools.healthCheck(tool.id);
            return { ...tool, health };
          } catch {
            return tool;
          }
        })
      );
      
      setTools(toolsWithHealth);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };
  
  const testTool = async (toolId: string) => {
    setTools(prev => prev.map(tool => 
      tool.id === toolId ? { ...tool, testing: true } : tool
    ));
    
    try {
      const testResult = await client.tools.test(toolId);
      
      if (testResult.success) {
        // Refresh health status
        const health = await client.tools.healthCheck(toolId);
        setTools(prev => prev.map(tool => 
          tool.id === toolId ? { ...tool, health, testing: false } : tool
        ));
      }
    } catch (error) {
      console.error('Test failed:', error);
    } finally {
      setTools(prev => prev.map(tool => 
        tool.id === toolId ? { ...tool, testing: false } : tool
      ));
    }
  };
  
  const getHealthColor = (status?: string) => {
    switch (status) {
      case 'healthy': return 'text-green-600';
      case 'degraded': return 'text-yellow-600';
      case 'unhealthy': return 'text-red-600';
      default: return 'text-gray-400';
    }
  };
  
  if (loading) {
    return <div className="p-4">Loading tools...</div>;
  }
  
  if (error) {
    return <div className="p-4 text-red-600">Error: {error}</div>;
  }
  
  return (
    <div className="p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Tool Integrations</h1>
        <button 
          onClick={loadTools}
          className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
        >
          Refresh
        </button>
      </div>
      
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {tools.map(tool => (
          <div key={tool.id} className="border rounded-lg p-4 bg-white shadow">
            <div className="flex justify-between items-start mb-2">
              <h3 className="font-semibold">{tool.name}</h3>
              <div className={`text-sm ${getHealthColor(tool.health?.status)}`}>
                {tool.health?.status || 'unknown'}
              </div>
            </div>
            
            <p className="text-sm text-gray-600 mb-3">{tool.description}</p>
            
            <div className="text-xs text-gray-500 space-y-1">
              <div>Base URL: {tool.baseUrl}</div>
              <div>Auth: {tool.authType}</div>
              {tool.health && (
                <>
                  <div>Uptime: {tool.health.metrics.uptime.toFixed(1)}%</div>
                  <div>Response: {tool.health.metrics.averageResponseTime}ms</div>
                </>
              )}
            </div>
            
            <div className="flex gap-2 mt-4">
              <button
                onClick={() => testTool(tool.id)}
                disabled={tool.testing}
                className="flex-1 bg-green-500 text-white text-sm px-3 py-1 rounded hover:bg-green-600 disabled:opacity-50"
              >
                {tool.testing ? 'Testing...' : 'Test'}
              </button>
              
              <button className="flex-1 bg-gray-500 text-white text-sm px-3 py-1 rounded hover:bg-gray-600">
                Configure
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
```

## Related Resources

<CardGroup cols={2}>
  <Card title="Tool Creation" icon="plus" href="/sdk/resources/tools/create">
    Learn how to create and configure tool integrations
  </Card>
  <Card title="Authentication" icon="key" href="/sdk/resources/tools/authentication">
    Master tool authentication and credential management
  </Card>
</CardGroup>

<CardGroup cols={2}>
  <Card title="Health Monitoring" icon="heart-pulse" href="/sdk/guides/tool-monitoring">
    Implement comprehensive tool health monitoring
  </Card>
  <Card title="Security Best Practices" icon="shield-check" href="/sdk/guides/security">
    Secure your tool integrations and credentials
  </Card>
</CardGroup>

---

*The Tools SDK provides everything you need to integrate external services into your workflows securely and reliably. Use these patterns to build robust, monitored integrations that scale with your needs.*