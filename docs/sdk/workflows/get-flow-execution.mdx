---
title: getFlowExecution()
sidebar_position: 3
---

# getFlowExecution()

Get the status and details of a workflow execution.

## Signature

```typescript
getFlowExecution(
  flowId: string, 
  executionId: string
): Promise<ExecutionStatus>
```

## Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `flowId` | `string` | Workflow ID |
| `executionId` | `string` | Execution ID from runFlow() |

## Returns

Returns a `Promise<ExecutionStatus>`:

```typescript
interface ExecutionStatus {
  data: {
    executionId: string;
    flowId: string;
    status: 'running' | 'completed' | 'failed' | 'cancelled';
    progress: number; // 0-100
    currentStep?: string;
    result?: any;
    error?: string;
    startedAt: string;
    completedAt?: string;
    duration?: number; // milliseconds
  };
}
```

## Usage Examples

### Basic Status Check
```typescript
const execution = await client.runFlow('flow_123', inputs);
const status = await client.getFlowExecution('flow_123', execution.data.executionId);

console.log(`Status: ${status.data.status}`);
console.log(`Progress: ${status.data.progress}%`);
```

### Polling for Completion
```typescript
async function waitForCompletion(
  flowId: string, 
  executionId: string
): Promise<ExecutionStatus> {
  while (true) {
    const status = await client.getFlowExecution(flowId, executionId);
    
    if (status.data.status === 'completed') {
      console.log('Workflow completed successfully!');
      console.log('Result:', status.data.result);
      return status;
    }
    
    if (status.data.status === 'failed') {
      console.error('Workflow failed:', status.data.error);
      throw new Error(`Workflow failed: ${status.data.error}`);
    }
    
    if (status.data.status === 'cancelled') {
      console.log('Workflow was cancelled');
      return status;
    }
    
    console.log(`Progress: ${status.data.progress}% - Current step: ${status.data.currentStep}`);
    await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
  }
}

const execution = await client.runFlow('flow_123', inputs);
const finalStatus = await waitForCompletion('flow_123', execution.data.executionId);
```

### Progress Monitoring
```typescript
async function monitorProgress(flowId: string, executionId: string) {
  const status = await client.getFlowExecution(flowId, executionId);
  
  console.log(`Execution ${executionId}:`);
  console.log(`  Status: ${status.data.status}`);
  console.log(`  Progress: ${status.data.progress}%`);
  console.log(`  Started: ${status.data.startedAt}`);
  
  if (status.data.currentStep) {
    console.log(`  Current Step: ${status.data.currentStep}`);
  }
  
  if (status.data.duration) {
    console.log(`  Duration: ${status.data.duration}ms`);
  }
  
  if (status.data.completedAt) {
    console.log(`  Completed: ${status.data.completedAt}`);
  }
  
  return status;
}
```

## Status Types

### Running
```typescript
{
  status: 'running',
  progress: 45,
  currentStep: 'Send Email',
  startedAt: '2024-01-15T10:30:00Z'
}
```

### Completed
```typescript
{
  status: 'completed',
  progress: 100,
  result: {
    emailSent: true,
    accountCreated: 'acc_789'
  },
  startedAt: '2024-01-15T10:30:00Z',
  completedAt: '2024-01-15T10:32:15Z',
  duration: 135000
}
```

### Failed
```typescript
{
  status: 'failed',
  progress: 30,
  error: 'API key invalid for SendGrid integration',
  currentStep: 'Send Email',
  startedAt: '2024-01-15T10:30:00Z',
  duration: 15000
}
```

### Cancelled
```typescript
{
  status: 'cancelled',
  progress: 60,
  currentStep: 'Database Update',
  startedAt: '2024-01-15T10:30:00Z',
  duration: 45000
}
```

## Error Handling

```typescript
import { AxiosError } from 'axios';

try {
  const status = await client.getFlowExecution('flow_123', 'exec_456');
  
  if (status.data.status === 'failed') {
    console.error('Workflow failed with error:', status.data.error);
    // Handle workflow failure
  }
} catch (error) {
  const apiError = error as AxiosError;
  
  if (apiError.response?.status === 404) {
    console.error('Execution not found');
  } else {
    console.error('Failed to get execution status:', error.message);
  }
}
```

## Advanced Usage

### Real-time Dashboard
```typescript
class ExecutionDashboard {
  private activeExecutions: Set<string> = new Set();
  
  async addExecution(flowId: string, executionId: string) {
    this.activeExecutions.add(executionId);
    this.startMonitoring(flowId, executionId);
  }
  
  private async startMonitoring(flowId: string, executionId: string) {
    const intervalId = setInterval(async () => {
      try {
        const status = await client.getFlowExecution(flowId, executionId);
        
        this.updateUI(executionId, status.data);
        
        if (status.data.status !== 'running') {
          clearInterval(intervalId);
          this.activeExecutions.delete(executionId);
        }
      } catch (error) {
        console.error(`Failed to monitor ${executionId}:`, error);
        clearInterval(intervalId);
        this.activeExecutions.delete(executionId);
      }
    }, 3000); // Check every 3 seconds
  }
  
  private updateUI(executionId: string, status: any) {
    console.log(`[${executionId}] ${status.status} - ${status.progress}%`);
    // Update your UI here
  }
}

const dashboard = new ExecutionDashboard();
const execution = await client.runFlow('flow_123', inputs);
await dashboard.addExecution('flow_123', execution.data.executionId);
```

### Smart Polling
```typescript
class SmartPoller {
  async pollUntilComplete(
    flowId: string, 
    executionId: string,
    options = {}
  ): Promise<ExecutionStatus> {
    const {
      initialDelay = 1000,
      maxDelay = 10000,
      backoffMultiplier = 1.5,
      timeout = 300000 // 5 minutes
    } = options;
    
    let delay = initialDelay;
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      const status = await client.getFlowExecution(flowId, executionId);
      
      if (status.data.status !== 'running') {
        return status;
      }
      
      await new Promise(resolve => setTimeout(resolve, delay));
      delay = Math.min(delay * backoffMultiplier, maxDelay);
    }
    
    throw new Error(`Polling timeout after ${timeout}ms`);
  }
}

const poller = new SmartPoller();
const execution = await client.runFlow('flow_123', inputs);
const result = await poller.pollUntilComplete('flow_123', execution.data.executionId);
```

### Execution Analytics
```typescript
class ExecutionAnalytics {
  private executionData: Map<string, ExecutionStatus[]> = new Map();
  
  async trackExecution(flowId: string, executionId: string) {
    const history: ExecutionStatus[] = [];
    
    const monitor = setInterval(async () => {
      try {
        const status = await client.getFlowExecution(flowId, executionId);
        history.push(status);
        
        if (status.data.status !== 'running') {
          clearInterval(monitor);
          this.executionData.set(executionId, history);
          this.analyzeExecution(executionId, history);
        }
      } catch (error) {
        clearInterval(monitor);
      }
    }, 5000);
  }
  
  private analyzeExecution(executionId: string, history: ExecutionStatus[]) {
    const final = history[history.length - 1];
    const steps = new Set(history.map(h => h.data.currentStep).filter(Boolean));
    
    console.log(`Execution ${executionId} Analysis:`);
    console.log(`  Final Status: ${final.data.status}`);
    console.log(`  Duration: ${final.data.duration}ms`);
    console.log(`  Steps: ${Array.from(steps).join(', ')}`);
    console.log(`  Progress Updates: ${history.length}`);
  }
  
  getExecutionHistory(executionId: string): ExecutionStatus[] {
    return this.executionData.get(executionId) || [];
  }
}
```

## Best Practices

### Efficient Polling
```typescript
// Avoid: Polling too frequently
setInterval(() => client.getFlowExecution(flowId, executionId), 100); // Too fast!

// Good: Reasonable polling interval
setInterval(() => client.getFlowExecution(flowId, executionId), 2000); // 2 seconds

// Better: Progressive backoff
let delay = 1000;
const poll = async () => {
  const status = await client.getFlowExecution(flowId, executionId);
  if (status.data.status === 'running') {
    delay = Math.min(delay * 1.2, 10000); // Increase up to 10s
    setTimeout(poll, delay);
  }
};
```

### Error Recovery
```typescript
async function robustGetExecution(
  flowId: string, 
  executionId: string,
  retries = 3
): Promise<ExecutionStatus> {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      return await client.getFlowExecution(flowId, executionId);
    } catch (error) {
      if (attempt === retries) throw error;
      
      const delay = attempt * 1000; // Linear backoff
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  throw new Error('Should never reach here');
}
```

## Related Methods

- [runFlow()](/sdk/methods/run-flow) - Execute workflows
- [listFlows()](/sdk/methods/list-flows) - List available workflows
- [TolstoyClient](/sdk/methods/tolstoy-client) - Client setup

## See Also

- [Execution Status API](/api/flows/get-flows-executions-1) - Direct API documentation
- [Flow Execution Patterns](/sdk/examples) - Real-world monitoring examples