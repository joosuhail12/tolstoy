---
title: getDetailedHealth()
sidebar_position: 10
---

# getDetailedHealth()

Get comprehensive health information about the Tolstoy API service and its dependencies.

## Signature

```typescript
getDetailedHealth(): Promise<DetailedHealthStatus>
```

## Parameters

None - this method provides detailed system health information.

## Returns

Returns a `Promise<DetailedHealthStatus>`:

```typescript
interface DetailedHealthStatus {
  data: {
    status: 'ok' | 'error';
    timestamp: string;
    uptime: number;
    version: string;
    dependencies: {
      database: {
        status: 'ok' | 'error';
        responseTime: number;
        connections: number;
      };
      redis: {
        status: 'ok' | 'error';
        responseTime: number;
        memory: number;
      };
      queue: {
        status: 'ok' | 'error';
        pending: number;
        processing: number;
      };
    };
    metrics: {
      memory: {
        used: number;
        total: number;
        percentage: number;
      };
      cpu: {
        usage: number;
      };
      requests: {
        total: number;
        rps: number;
        errorRate: number;
      };
    };
  };
}
```

## Usage Examples

### Comprehensive Health Check
```typescript
const detailedHealth = await client.getDetailedHealth();

console.log(`Overall Status: ${detailedHealth.data.status}`);
console.log(`Version: ${detailedHealth.data.version}`);
console.log(`Uptime: ${Math.floor(detailedHealth.data.uptime / 3600)} hours`);

// Check dependencies
const deps = detailedHealth.data.dependencies;
console.log(`Database: ${deps.database.status} (${deps.database.responseTime}ms)`);
console.log(`Redis: ${deps.redis.status} (${deps.redis.responseTime}ms)`);
console.log(`Queue: ${deps.queue.status} (${deps.queue.pending} pending)`);

// Check metrics
const metrics = detailedHealth.data.metrics;
console.log(`Memory: ${metrics.memory.percentage.toFixed(1)}% used`);
console.log(`CPU: ${metrics.cpu.usage.toFixed(1)}% usage`);
console.log(`Request Rate: ${metrics.requests.rps} req/sec`);
```

### Dependency Monitoring
```typescript
async function checkDependencies(): Promise<string[]> {
  const health = await client.getDetailedHealth();
  const issues: string[] = [];
  
  const deps = health.data.dependencies;
  
  if (deps.database.status !== 'ok') {
    issues.push(`Database is ${deps.database.status}`);
  } else if (deps.database.responseTime > 1000) {
    issues.push(`Database slow response: ${deps.database.responseTime}ms`);
  }
  
  if (deps.redis.status !== 'ok') {
    issues.push(`Redis is ${deps.redis.status}`);
  } else if (deps.redis.responseTime > 100) {
    issues.push(`Redis slow response: ${deps.redis.responseTime}ms`);
  }
  
  if (deps.queue.status !== 'ok') {
    issues.push(`Queue is ${deps.queue.status}`);
  } else if (deps.queue.pending > 1000) {
    issues.push(`Queue backlog: ${deps.queue.pending} pending jobs`);
  }
  
  return issues;
}

const issues = await checkDependencies();
if (issues.length > 0) {
  console.warn('‚ö†Ô∏è Dependency Issues:');
  issues.forEach(issue => console.warn(`  - ${issue}`));
}
```

### Performance Monitoring
```typescript
async function analyzePerformance(): Promise<void> {
  const health = await client.getDetailedHealth();
  const metrics = health.data.metrics;
  
  console.log('Performance Analysis:');
  
  // Memory analysis
  if (metrics.memory.percentage > 80) {
    console.warn(`üî¥ High memory usage: ${metrics.memory.percentage.toFixed(1)}%`);
  } else if (metrics.memory.percentage > 60) {
    console.warn(`üü° Moderate memory usage: ${metrics.memory.percentage.toFixed(1)}%`);
  } else {
    console.log(`üü¢ Memory usage: ${metrics.memory.percentage.toFixed(1)}%`);
  }
  
  // CPU analysis
  if (metrics.cpu.usage > 80) {
    console.warn(`üî¥ High CPU usage: ${metrics.cpu.usage.toFixed(1)}%`);
  } else if (metrics.cpu.usage > 60) {
    console.warn(`üü° Moderate CPU usage: ${metrics.cpu.usage.toFixed(1)}%`);
  } else {
    console.log(`üü¢ CPU usage: ${metrics.cpu.usage.toFixed(1)}%`);
  }
  
  // Request rate analysis
  if (metrics.requests.errorRate > 5) {
    console.warn(`üî¥ High error rate: ${metrics.requests.errorRate.toFixed(2)}%`);
  } else if (metrics.requests.errorRate > 1) {
    console.warn(`üü° Moderate error rate: ${metrics.requests.errorRate.toFixed(2)}%`);
  } else {
    console.log(`üü¢ Error rate: ${metrics.requests.errorRate.toFixed(2)}%`);
  }
  
  console.log(`Request Rate: ${metrics.requests.rps} req/sec`);
}

await analyzePerformance();
```

## Error Handling

```typescript
try {
  const health = await client.getDetailedHealth();
  
  if (health.data.status === 'ok') {
    console.log('‚úÖ System is healthy');
  } else {
    console.warn('‚ö†Ô∏è System reported issues');
    
    // Check which dependencies are failing
    Object.entries(health.data.dependencies).forEach(([name, dep]) => {
      if (dep.status !== 'ok') {
        console.error(`‚ùå ${name} dependency is ${dep.status}`);
      }
    });
  }
} catch (error) {
  console.error('‚ùå Unable to get detailed health:', error.message);
}
```

## Advanced Usage

### Health Monitoring Dashboard
```typescript
class SystemMonitor {
  private healthHistory: DetailedHealthStatus[] = [];
  private alerts: string[] = [];
  
  async monitor(): Promise<void> {
    const health = await client.getDetailedHealth();
    this.healthHistory.push(health);
    
    // Keep last 24 hours (assuming 1-minute intervals)
    if (this.healthHistory.length > 1440) {
      this.healthHistory.shift();
    }
    
    this.checkAlerts(health);
    this.logMetrics(health);
  }
  
  private checkAlerts(health: DetailedHealthStatus): void {
    const metrics = health.data.metrics;
    const deps = health.data.dependencies;
    
    // Memory alert
    if (metrics.memory.percentage > 90) {
      this.addAlert('CRITICAL: Memory usage above 90%');
    }
    
    // Database alert
    if (deps.database.responseTime > 2000) {
      this.addAlert('WARNING: Database response time above 2s');
    }
    
    // Queue alert
    if (deps.queue.pending > 5000) {
      this.addAlert('WARNING: Queue backlog above 5000 jobs');
    }
    
    // Error rate alert
    if (metrics.requests.errorRate > 10) {
      this.addAlert('CRITICAL: Error rate above 10%');
    }
  }
  
  private addAlert(message: string): void {
    const timestamp = new Date().toISOString();
    this.alerts.push(`[${timestamp}] ${message}`);
    console.warn(`üö® ${message}`);
    
    // Keep only last 100 alerts
    if (this.alerts.length > 100) {
      this.alerts.shift();
    }
  }
  
  private logMetrics(health: DetailedHealthStatus): void {
    const metrics = health.data.metrics;
    console.log(`[${new Date().toISOString()}] Metrics:`);
    console.log(`  Memory: ${metrics.memory.percentage.toFixed(1)}%`);
    console.log(`  CPU: ${metrics.cpu.usage.toFixed(1)}%`);
    console.log(`  RPS: ${metrics.requests.rps}`);
    console.log(`  Error Rate: ${metrics.requests.errorRate.toFixed(2)}%`);
  }
  
  getAverageMetrics(minutes = 60): any {
    const recent = this.healthHistory.slice(-minutes);
    if (recent.length === 0) return null;
    
    return {
      avgMemory: recent.reduce((sum, h) => sum + h.data.metrics.memory.percentage, 0) / recent.length,
      avgCpu: recent.reduce((sum, h) => sum + h.data.metrics.cpu.usage, 0) / recent.length,
      avgRps: recent.reduce((sum, h) => sum + h.data.metrics.requests.rps, 0) / recent.length,
      avgErrorRate: recent.reduce((sum, h) => sum + h.data.metrics.requests.errorRate, 0) / recent.length
    };
  }
  
  getRecentAlerts(hours = 1): string[] {
    const cutoff = new Date(Date.now() - hours * 60 * 60 * 1000).toISOString();
    return this.alerts.filter(alert => alert.includes(cutoff.substring(0, 13))); // Hour precision
  }
}

const monitor = new SystemMonitor();

// Start monitoring
setInterval(async () => {
  try {
    await monitor.monitor();
  } catch (error) {
    console.error('Monitoring failed:', error.message);
  }
}, 60000); // Every minute
```

### Auto-scaling Trigger
```typescript
async function checkAutoScalingTriggers(): Promise<boolean> {
  const health = await client.getDetailedHealth();
  const metrics = health.data.metrics;
  
  const shouldScale = 
    metrics.cpu.usage > 70 ||
    metrics.memory.percentage > 80 ||
    metrics.requests.rps > 1000 ||
    health.data.dependencies.queue.pending > 2000;
  
  if (shouldScale) {
    console.log('üöÄ Auto-scaling triggered due to high load');
    console.log(`  CPU: ${metrics.cpu.usage.toFixed(1)}%`);
    console.log(`  Memory: ${metrics.memory.percentage.toFixed(1)}%`);
    console.log(`  RPS: ${metrics.requests.rps}`);
    console.log(`  Queue: ${health.data.dependencies.queue.pending} pending`);
    
    // Trigger scaling action
    // await scaleUp();
  }
  
  return shouldScale;
}
```

### Health Report Generation
```typescript
async function generateHealthReport(): Promise<string> {
  const health = await client.getDetailedHealth();
  
  const report = `
TOLSTOY API HEALTH REPORT
========================
Generated: ${new Date().toISOString()}

OVERALL STATUS: ${health.data.status.toUpperCase()}
Version: ${health.data.version}
Uptime: ${Math.floor(health.data.uptime / 3600)}h ${Math.floor((health.data.uptime % 3600) / 60)}m

DEPENDENCIES:
${Object.entries(health.data.dependencies).map(([name, dep]) => 
  `  ${name}: ${dep.status} (${dep.responseTime || 'N/A'}ms)`
).join('\n')}

SYSTEM METRICS:
  Memory: ${health.data.metrics.memory.used}MB / ${health.data.metrics.memory.total}MB (${health.data.metrics.memory.percentage.toFixed(1)}%)
  CPU: ${health.data.metrics.cpu.usage.toFixed(1)}%
  
REQUEST METRICS:
  Total Requests: ${health.data.metrics.requests.total.toLocaleString()}
  Request Rate: ${health.data.metrics.requests.rps} req/sec
  Error Rate: ${health.data.metrics.requests.errorRate.toFixed(2)}%

QUEUE STATUS:
  Pending Jobs: ${health.data.dependencies.queue.pending}
  Processing Jobs: ${health.data.dependencies.queue.processing}
`;

  return report.trim();
}

const report = await generateHealthReport();
console.log(report);
```

## Integration Patterns

### Prometheus Metrics
```typescript
// Export metrics in Prometheus format
async function exportPrometheusMetrics(): Promise<string> {
  const health = await client.getDetailedHealth();
  const metrics = health.data.metrics;
  const deps = health.data.dependencies;
  
  return `
# HELP tolstoy_memory_usage_percent Memory usage percentage
# TYPE tolstoy_memory_usage_percent gauge
tolstoy_memory_usage_percent ${metrics.memory.percentage}

# HELP tolstoy_cpu_usage_percent CPU usage percentage
# TYPE tolstoy_cpu_usage_percent gauge
tolstoy_cpu_usage_percent ${metrics.cpu.usage}

# HELP tolstoy_requests_per_second Current requests per second
# TYPE tolstoy_requests_per_second gauge
tolstoy_requests_per_second ${metrics.requests.rps}

# HELP tolstoy_error_rate_percent Error rate percentage
# TYPE tolstoy_error_rate_percent gauge
tolstoy_error_rate_percent ${metrics.requests.errorRate}

# HELP tolstoy_database_response_time_ms Database response time in milliseconds
# TYPE tolstoy_database_response_time_ms gauge
tolstoy_database_response_time_ms ${deps.database.responseTime}

# HELP tolstoy_queue_pending_jobs Number of pending queue jobs
# TYPE tolstoy_queue_pending_jobs gauge
tolstoy_queue_pending_jobs ${deps.queue.pending}
`.trim();
}

// Express endpoint for Prometheus scraping
app.get('/metrics', async (req, res) => {
  try {
    const metrics = await exportPrometheusMetrics();
    res.type('text/plain').send(metrics);
  } catch (error) {
    res.status(500).send('Error collecting metrics');
  }
});
```

### Slack Alerts
```typescript
async function sendSlackAlert(webhookUrl: string): Promise<void> {
  const health = await client.getDetailedHealth();
  
  if (health.data.status !== 'ok') {
    const message = {
      text: 'üö® Tolstoy API Health Alert',
      blocks: [
        {
          type: 'header',
          text: { type: 'plain_text', text: 'üö® API Health Alert' }
        },
        {
          type: 'section',
          fields: [
            { type: 'mrkdwn', text: `*Status:* ${health.data.status}` },
            { type: 'mrkdwn', text: `*Version:* ${health.data.version}` },
            { type: 'mrkdwn', text: `*CPU:* ${health.data.metrics.cpu.usage.toFixed(1)}%` },
            { type: 'mrkdwn', text: `*Memory:* ${health.data.metrics.memory.percentage.toFixed(1)}%` }
          ]
        }
      ]
    };
    
    await fetch(webhookUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(message)
    });
  }
}
```

## Best Practices

### Monitoring Intervals
```typescript
// Different monitoring intervals for different use cases
class AdaptiveMonitoring {
  private normalInterval = 60000;     // 1 minute
  private alertInterval = 10000;      // 10 seconds
  private currentInterval = this.normalInterval;
  private isAlerting = false;
  
  async startMonitoring(): Promise<void> {
    const monitor = async () => {
      try {
        const health = await client.getDetailedHealth();
        const hasIssues = this.checkForIssues(health);
        
        if (hasIssues && !this.isAlerting) {
          this.isAlerting = true;
          this.currentInterval = this.alertInterval;
          console.log('‚ö†Ô∏è Issues detected, switching to alert monitoring');
        } else if (!hasIssues && this.isAlerting) {
          this.isAlerting = false;
          this.currentInterval = this.normalInterval;
          console.log('‚úÖ Issues resolved, switching to normal monitoring');
        }
      } catch (error) {
        console.error('Health check failed:', error.message);
      }
      
      setTimeout(monitor, this.currentInterval);
    };
    
    await monitor();
  }
  
  private checkForIssues(health: DetailedHealthStatus): boolean {
    const metrics = health.data.metrics;
    return health.data.status !== 'ok' ||
           metrics.cpu.usage > 80 ||
           metrics.memory.percentage > 85 ||
           metrics.requests.errorRate > 5;
  }
}
```

## Related Methods

- [getHealth()](/sdk/methods/get-health) - Basic health check
- [TolstoyClient](/sdk/methods/tolstoy-client) - Client setup and configuration

## See Also

- [Detailed Health API](/api/health/get-statusdetailed) - Direct API documentation
- [Monitoring Guide](/docs/monitoring) - Comprehensive system monitoring
- [Performance Optimization](/docs/performance) - System performance tuning