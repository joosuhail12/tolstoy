---
title: "Best Practices & Patterns"
description: "Production-ready patterns, performance optimization, security best practices, and common patterns for building robust workflow automation with the Tolstoy SDK."
sidebar_position: 4
---

# Best Practices & Patterns

Learn production-ready patterns and best practices for building robust, scalable, and secure workflow automation applications with the Tolstoy SDK.

## Architecture Patterns

### 1. Service-Oriented Architecture

```typescript
// Organize your Tolstoy integration into focused services
class WorkflowService {
  private client: TolstoyClient;
  private logger: Logger;
  
  constructor(client: TolstoyClient, logger: Logger) {
    this.client = client;
    this.logger = logger;
  }
  
  async executeWorkflow(flowId: string, inputs: any, options: ExecutionOptions = {}) {
    const executionId = generateExecutionId();
    
    try {
      this.logger.info(`Starting workflow ${flowId}`, { executionId, flowId });
      
      const result = await this.client.runFlow(flowId, {
        ...inputs,
        _metadata: {
          executionId,
          timestamp: new Date().toISOString(),
          source: 'workflow-service'
        }
      });
      
      this.logger.info(`Workflow started successfully`, { 
        executionId, 
        workflowExecutionId: result.data.executionId 
      });
      
      return result.data;
    } catch (error) {
      this.logger.error(`Workflow execution failed`, { executionId, error: error.message });
      throw new WorkflowExecutionError(`Failed to execute workflow ${flowId}`, error);
    }
  }
}

class IntegrationService {
  private client: TolstoyClient;
  
  constructor(client: TolstoyClient) {
    this.client = client;
  }
  
  async setupIntegration(config: IntegrationConfig) {
    const tool = await this.client.createTool({
      name: config.name,
      baseUrl: config.baseUrl,
      authType: config.authType,
      description: config.description
    });
    
    return tool.data;
  }
}

class MonitoringService {
  private client: TolstoyClient;
  
  constructor(client: TolstoyClient) {
    this.client = client;
  }
  
  async setupWebhooks(config: WebhookConfig[]) {
    const webhooks = await Promise.all(
      config.map(webhook => this.client.createWebhook(webhook))
    );
    
    return webhooks.map(w => w.data);
  }
}

// Compose services into a unified interface
class TolstoyOrchestrator {
  public readonly workflows: WorkflowService;
  public readonly integrations: IntegrationService;
  public readonly monitoring: MonitoringService;
  
  constructor(client: TolstoyClient, logger: Logger) {
    this.workflows = new WorkflowService(client, logger);
    this.integrations = new IntegrationService(client);
    this.monitoring = new MonitoringService(client);
  }
}
```

### 2. Factory Pattern for Client Management

```typescript
interface ClientConfig {
  apiUrl: string;
  orgId: string;
  userId: string;
  apiKey: string;
  environment: 'development' | 'staging' | 'production';
}

class TolstoyClientFactory {
  private static instances = new Map<string, TolstoyClient>();
  
  static create(config: ClientConfig): TolstoyClient {
    const key = `${config.environment}-${config.orgId}-${config.userId}`;
    
    if (!this.instances.has(key)) {
      const client = new TolstoyClient(
        config.apiUrl,
        config.orgId,
        config.userId,
        config.apiKey,
        this.getClientOptions(config.environment)
      );
      
      this.instances.set(key, client);
    }
    
    return this.instances.get(key)!;
  }
  
  private static getClientOptions(environment: string) {
    const baseOptions = {
      timeout: 30000,
      retries: { attempts: 3, delay: 1000 }
    };
    
    switch (environment) {
      case 'development':
        return {
          ...baseOptions,
          debug: true,
          timeout: 60000
        };
      case 'staging':
        return {
          ...baseOptions,
          timeout: 45000
        };
      case 'production':
        return {
          ...baseOptions,
          timeout: 30000,
          retries: { attempts: 5, delay: 1000, exponentialBackoff: true }
        };
      default:
        return baseOptions;
    }
  }
  
  static cleanup(): void {
    this.instances.clear();
  }
}
```

### 3. Repository Pattern for Data Access

```typescript
interface ExecutionRepository {
  save(execution: ExecutionRecord): Promise<void>;
  findById(id: string): Promise<ExecutionRecord | null>;
  findByStatus(status: string): Promise<ExecutionRecord[]>;
  updateStatus(id: string, status: string): Promise<void>;
}

class DatabaseExecutionRepository implements ExecutionRepository {
  private db: Database;
  
  constructor(db: Database) {
    this.db = db;
  }
  
  async save(execution: ExecutionRecord): Promise<void> {
    await this.db.query(
      'INSERT INTO executions (id, flow_id, status, inputs, created_at) VALUES (?, ?, ?, ?, ?)',
      [execution.id, execution.flowId, execution.status, JSON.stringify(execution.inputs), execution.createdAt]
    );
  }
  
  async findById(id: string): Promise<ExecutionRecord | null> {
    const result = await this.db.query('SELECT * FROM executions WHERE id = ?', [id]);
    return result[0] ? this.mapToExecutionRecord(result[0]) : null;
  }
  
  private mapToExecutionRecord(row: any): ExecutionRecord {
    return {
      id: row.id,
      flowId: row.flow_id,
      status: row.status,
      inputs: JSON.parse(row.inputs),
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };
  }
}

class WorkflowExecutionService {
  constructor(
    private tolstoyClient: TolstoyClient,
    private executionRepo: ExecutionRepository,
    private logger: Logger
  ) {}
  
  async executeAndTrack(flowId: string, inputs: any): Promise<string> {
    const execution: ExecutionRecord = {
      id: generateId(),
      flowId,
      status: 'pending',
      inputs,
      createdAt: new Date()
    };
    
    await this.executionRepo.save(execution);
    
    try {
      const result = await this.tolstoyClient.runFlow(flowId, inputs);
      
      await this.executionRepo.updateStatus(execution.id, 'started');
      
      return result.data.executionId;
    } catch (error) {
      await this.executionRepo.updateStatus(execution.id, 'failed');
      throw error;
    }
  }
}
```

## Error Handling & Resilience

### 1. Comprehensive Error Classification

```typescript
enum ErrorType {
  VALIDATION_ERROR = 'validation_error',
  AUTHENTICATION_ERROR = 'authentication_error',
  AUTHORIZATION_ERROR = 'authorization_error',
  NOT_FOUND_ERROR = 'not_found_error',
  RATE_LIMIT_ERROR = 'rate_limit_error',
  NETWORK_ERROR = 'network_error',
  SERVER_ERROR = 'server_error',
  UNKNOWN_ERROR = 'unknown_error'
}

class TolstoyError extends Error {
  public readonly type: ErrorType;
  public readonly code?: string;
  public readonly details?: any;
  public readonly retryable: boolean;
  
  constructor(
    message: string,
    type: ErrorType,
    code?: string,
    details?: any,
    retryable: boolean = false
  ) {
    super(message);
    this.name = 'TolstoyError';
    this.type = type;
    this.code = code;
    this.details = details;
    this.retryable = retryable;
  }
  
  static fromApiError(error: any): TolstoyError {
    if (!error.response) {
      return new TolstoyError(
        error.message || 'Network error',
        ErrorType.NETWORK_ERROR,
        'NETWORK_ERROR',
        error,
        true
      );
    }
    
    const { status, data } = error.response;
    
    switch (status) {
      case 400:
        return new TolstoyError(
          'Validation failed',
          ErrorType.VALIDATION_ERROR,
          data.code,
          data.details,
          false
        );
      case 401:
        return new TolstoyError(
          'Authentication failed',
          ErrorType.AUTHENTICATION_ERROR,
          'AUTH_FAILED',
          data,
          false
        );
      case 403:
        return new TolstoyError(
          'Permission denied',
          ErrorType.AUTHORIZATION_ERROR,
          'PERMISSION_DENIED',
          data,
          false
        );
      case 404:
        return new TolstoyError(
          'Resource not found',
          ErrorType.NOT_FOUND_ERROR,
          'NOT_FOUND',
          data,
          false
        );
      case 429:
        return new TolstoyError(
          'Rate limit exceeded',
          ErrorType.RATE_LIMIT_ERROR,
          'RATE_LIMITED',
          { retryAfter: error.response.headers['retry-after'] },
          true
        );
      case 500:
      case 502:
      case 503:
      case 504:
        return new TolstoyError(
          'Server error',
          ErrorType.SERVER_ERROR,
          `HTTP_${status}`,
          data,
          true
        );
      default:
        return new TolstoyError(
          data.message || 'Unknown error',
          ErrorType.UNKNOWN_ERROR,
          `HTTP_${status}`,
          data,
          status >= 500
        );
    }
  }
}
```

### 2. Retry Strategies

```typescript
interface RetryConfig {
  maxAttempts: number;
  baseDelay: number;
  maxDelay: number;
  exponentialBackoff: boolean;
  jitter: boolean;
}

class RetryableOperation<T> {
  private config: RetryConfig;
  
  constructor(config: Partial<RetryConfig> = {}) {
    this.config = {
      maxAttempts: 3,
      baseDelay: 1000,
      maxDelay: 30000,
      exponentialBackoff: true,
      jitter: true,
      ...config
    };
  }
  
  async execute(operation: () => Promise<T>): Promise<T> {
    let lastError: any;
    
    for (let attempt = 1; attempt <= this.config.maxAttempts; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = TolstoyError.fromApiError(error);
        
        // Don't retry non-retryable errors
        if (!lastError.retryable || attempt === this.config.maxAttempts) {
          throw lastError;
        }
        
        // Calculate delay
        const delay = this.calculateDelay(attempt);
        console.log(`Retry attempt ${attempt} in ${delay}ms`);
        
        await this.sleep(delay);
      }
    }
    
    throw lastError;
  }
  
  private calculateDelay(attempt: number): number {
    let delay = this.config.baseDelay;
    
    if (this.config.exponentialBackoff) {
      delay *= Math.pow(2, attempt - 1);
    }
    
    delay = Math.min(delay, this.config.maxDelay);
    
    if (this.config.jitter) {
      delay += Math.random() * 1000;
    }
    
    return Math.floor(delay);
  }
  
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Usage
const retryableClient = new RetryableOperation({
  maxAttempts: 5,
  baseDelay: 1000,
  exponentialBackoff: true,
  jitter: true
});

const execution = await retryableClient.execute(() =>
  client.runFlow('workflow_id', inputs)
);
```

### 3. Circuit Breaker Pattern

```typescript
enum CircuitState {
  CLOSED = 'closed',
  OPEN = 'open',
  HALF_OPEN = 'half_open'
}

class CircuitBreaker {
  private state: CircuitState = CircuitState.CLOSED;
  private failures: number = 0;
  private successCount: number = 0;
  private lastFailureTime: number = 0;
  
  constructor(
    private failureThreshold: number = 5,
    private timeout: number = 60000, // 1 minute
    private monitoringPeriod: number = 10000 // 10 seconds
  ) {}
  
  async execute<T>(operation: () => Promise<T>): Promise<T> {
    if (this.state === CircuitState.OPEN) {
      if (Date.now() - this.lastFailureTime < this.timeout) {
        throw new Error('Circuit breaker is OPEN');
      }
      this.state = CircuitState.HALF_OPEN;
      this.successCount = 0;
    }
    
    try {
      const result = await operation();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess(): void {
    this.failures = 0;
    
    if (this.state === CircuitState.HALF_OPEN) {
      this.successCount++;
      if (this.successCount >= 3) { // Require 3 successes to close
        this.state = CircuitState.CLOSED;
        console.log('Circuit breaker closed');
      }
    }
  }
  
  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();
    
    if (this.failures >= this.failureThreshold) {
      this.state = CircuitState.OPEN;
      console.log('Circuit breaker opened');
    }
  }
  
  getState(): CircuitState {
    return this.state;
  }
}

// Usage with Tolstoy client
const circuitBreaker = new CircuitBreaker(5, 60000);

async function executeWorkflowWithCircuitBreaker(flowId: string, inputs: any) {
  return circuitBreaker.execute(() => client.runFlow(flowId, inputs));
}
```

## Performance Optimization

### 1. Connection Pooling & Reuse

```typescript
class OptimizedTolstoyClient {
  private static instance: OptimizedTolstoyClient;
  private client: TolstoyClient;
  private connectionPool: Map<string, TolstoyClient> = new Map();
  
  private constructor() {
    this.client = this.createClient();
  }
  
  static getInstance(): OptimizedTolstoyClient {
    if (!this.instance) {
      this.instance = new OptimizedTolstoyClient();
    }
    return this.instance;
  }
  
  private createClient(): TolstoyClient {
    return new TolstoyClient(
      process.env.TOLSTOY_API_URL!,
      process.env.TOLSTOY_ORG_ID!,
      process.env.TOLSTOY_USER_ID!,
      process.env.TOLSTOY_API_KEY!,
      {
        // Enable keep-alive for connection reuse
        httpOptions: {
          keepAlive: true,
          maxSockets: 10,
          timeout: 30000
        },
        
        // Enable caching for frequently accessed data
        cache: {
          enabled: true,
          ttl: 300000, // 5 minutes
          maxSize: 100
        }
      }
    );
  }
  
  getClient(): TolstoyClient {
    return this.client;
  }
  
  // Get client for specific tenant (multi-tenant optimization)
  getClientForTenant(orgId: string, userId: string): TolstoyClient {
    const key = `${orgId}:${userId}`;
    
    if (!this.connectionPool.has(key)) {
      const client = new TolstoyClient(
        process.env.TOLSTOY_API_URL!,
        orgId,
        userId,
        process.env.TOLSTOY_API_KEY!
      );
      this.connectionPool.set(key, client);
    }
    
    return this.connectionPool.get(key)!;
  }
  
  // Clean up idle connections
  cleanup(): void {
    this.connectionPool.clear();
  }
}
```

### 2. Caching Strategies

```typescript
interface CacheEntry<T> {
  data: T;
  timestamp: number;
  ttl: number;
}

class WorkflowCache {
  private cache = new Map<string, CacheEntry<any>>();
  private defaultTTL: number = 300000; // 5 minutes
  
  set<T>(key: string, data: T, ttl: number = this.defaultTTL): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }
  
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    
    if (!entry) return null;
    
    if (Date.now() - entry.timestamp > entry.ttl) {
      this.cache.delete(key);
      return null;
    }
    
    return entry.data;
  }
  
  invalidate(pattern: string): void {
    const keys = Array.from(this.cache.keys()).filter(key =>
      key.includes(pattern)
    );
    keys.forEach(key => this.cache.delete(key));
  }
  
  clear(): void {
    this.cache.clear();
  }
  
  size(): number {
    return this.cache.size;
  }
}

class CachedWorkflowService {
  private cache = new WorkflowCache();
  
  constructor(private client: TolstoyClient) {}
  
  async getFlows(useCache: boolean = true): Promise<any[]> {
    const cacheKey = 'flows:all';
    
    if (useCache) {
      const cached = this.cache.get<any[]>(cacheKey);
      if (cached) {
        console.log('Cache hit for flows');
        return cached;
      }
    }
    
    console.log('Cache miss for flows, fetching...');
    const flows = await this.client.listFlows();
    
    this.cache.set(cacheKey, flows.data, 300000); // Cache for 5 minutes
    return flows.data;
  }
  
  async getFlow(flowId: string, useCache: boolean = true): Promise<any> {
    const cacheKey = `flow:${flowId}`;
    
    if (useCache) {
      const cached = this.cache.get(cacheKey);
      if (cached) return cached;
    }
    
    const flow = await this.client.raw.flows.flowsControllerFindOne(flowId);
    this.cache.set(cacheKey, flow.data, 600000); // Cache for 10 minutes
    
    return flow.data;
  }
  
  // Invalidate cache when workflows are modified
  invalidateFlowCache(flowId?: string): void {
    if (flowId) {
      this.cache.invalidate(`flow:${flowId}`);
    } else {
      this.cache.invalidate('flow');
    }
  }
}
```

### 3. Batch Operations

```typescript
class BatchWorkflowService {
  constructor(private client: TolstoyClient) {}
  
  async executeBatch(
    requests: Array<{ flowId: string; inputs: any }>,
    options: {
      concurrency?: number;
      failFast?: boolean;
      timeout?: number;
    } = {}
  ) {
    const { concurrency = 5, failFast = false, timeout = 30000 } = options;
    
    console.log(`Executing ${requests.length} workflows with concurrency ${concurrency}`);
    
    const results: Array<{ success: boolean; data?: any; error?: any }> = [];
    
    // Process in batches to control concurrency
    for (let i = 0; i < requests.length; i += concurrency) {
      const batch = requests.slice(i, i + concurrency);
      
      const batchPromises = batch.map(async (request, index) => {
        const globalIndex = i + index;
        
        try {
          console.log(`[${globalIndex + 1}/${requests.length}] Executing ${request.flowId}`);
          
          const execution = await Promise.race([
            this.client.runFlow(request.flowId, request.inputs),
            new Promise((_, reject) =>
              setTimeout(() => reject(new Error('Timeout')), timeout)
            )
          ]);
          
          return { success: true, data: execution.data, index: globalIndex };
        } catch (error) {
          console.error(`[${globalIndex + 1}/${requests.length}] Failed: ${error.message}`);
          
          if (failFast) {
            throw error;
          }
          
          return { success: false, error: error.message, index: globalIndex };
        }
      });
      
      try {
        const batchResults = await Promise.all(batchPromises);
        
        // Insert results in correct order
        batchResults.forEach(result => {
          results[result.index] = result;
        });
        
        console.log(`Batch ${Math.floor(i / concurrency) + 1} completed`);
      } catch (error) {
        if (failFast) {
          throw error;
        }
      }
    }
    
    const successful = results.filter(r => r.success).length;
    const failed = results.filter(r => !r.success).length;
    
    console.log(`Batch execution complete: ${successful} succeeded, ${failed} failed`);
    
    return {
      results,
      summary: {
        total: requests.length,
        successful,
        failed,
        successRate: (successful / requests.length) * 100
      }
    };
  }
}

// Usage
const batchService = new BatchWorkflowService(client);

const requests = [
  { flowId: 'onboarding', inputs: { userId: 'user1' } },
  { flowId: 'onboarding', inputs: { userId: 'user2' } },
  { flowId: 'onboarding', inputs: { userId: 'user3' } },
  // ... more requests
];

const batchResult = await batchService.executeBatch(requests, {
  concurrency: 3,
  failFast: false,
  timeout: 45000
});
```

## Security Best Practices

### 1. Secure Credential Management

```typescript
interface SecureCredentials {
  apiKey: string;
  orgId: string;
  userId: string;
  encryptedAt: Date;
}

class CredentialManager {
  private encryptionKey: string;
  
  constructor() {
    this.encryptionKey = this.getEncryptionKey();
  }
  
  private getEncryptionKey(): string {
    const key = process.env.CREDENTIAL_ENCRYPTION_KEY;
    if (!key || key.length < 32) {
      throw new Error('CREDENTIAL_ENCRYPTION_KEY must be at least 32 characters');
    }
    return key;
  }
  
  encrypt(data: string): string {
    const crypto = require('crypto');
    const cipher = crypto.createCipher('aes-256-cbc', this.encryptionKey);
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    return encrypted;
  }
  
  decrypt(encryptedData: string): string {
    const crypto = require('crypto');
    const decipher = crypto.createDecipher('aes-256-cbc', this.encryptionKey);
    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    return decrypted;
  }
  
  async storeCredentials(credentials: SecureCredentials): Promise<void> {
    const encrypted = {
      apiKey: this.encrypt(credentials.apiKey),
      orgId: credentials.orgId, // Not sensitive, no encryption needed
      userId: credentials.userId, // Not sensitive, no encryption needed
      encryptedAt: new Date()
    };
    
    // Store in secure storage (database, key vault, etc.)
    await this.saveToSecureStorage(encrypted);
  }
  
  async retrieveCredentials(): Promise<SecureCredentials> {
    const encrypted = await this.loadFromSecureStorage();
    
    return {
      apiKey: this.decrypt(encrypted.apiKey),
      orgId: encrypted.orgId,
      userId: encrypted.userId,
      encryptedAt: encrypted.encryptedAt
    };
  }
  
  private async saveToSecureStorage(credentials: any): Promise<void> {
    // Implementation depends on your storage solution
    // Could be database, AWS Secrets Manager, Azure Key Vault, etc.
  }
  
  private async loadFromSecureStorage(): Promise<any> {
    // Implementation depends on your storage solution
    throw new Error('Not implemented');
  }
}
```

### 2. Request Sanitization & Validation

```typescript
import Joi from 'joi';

// Input validation schemas
const workflowInputSchema = Joi.object({
  userId: Joi.string().required().min(1).max(100),
  email: Joi.string().email().when('userId', {
    is: Joi.exist(),
    then: Joi.optional(),
    otherwise: Joi.required()
  }),
  metadata: Joi.object({
    source: Joi.string().valid('web', 'mobile', 'api', 'system').default('api'),
    timestamp: Joi.date().iso().default(new Date()),
    sessionId: Joi.string().optional()
  }).default({}),
  customData: Joi.object().optional().max(50) // Limit number of properties
}).options({ stripUnknown: true }); // Remove unknown properties

class InputValidator {
  static validateWorkflowInput(input: any): { isValid: boolean; data?: any; errors?: string[] } {
    const { error, value } = workflowInputSchema.validate(input);
    
    if (error) {
      return {
        isValid: false,
        errors: error.details.map(d => d.message)
      };
    }
    
    return {
      isValid: true,
      data: value
    };
  }
  
  // Sanitize potentially dangerous input
  static sanitizeInput(input: any): any {
    if (typeof input === 'string') {
      // Remove potential script tags and SQL injection attempts
      return input
        .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
        .replace(/['"`;\\]/g, ''); // Basic SQL injection prevention
    }
    
    if (Array.isArray(input)) {
      return input.map(item => this.sanitizeInput(item));
    }
    
    if (typeof input === 'object' && input !== null) {
      const sanitized: any = {};
      for (const [key, value] of Object.entries(input)) {
        // Only allow alphanumeric keys
        if (/^[a-zA-Z0-9_]+$/.test(key)) {
          sanitized[key] = this.sanitizeInput(value);
        }
      }
      return sanitized;
    }
    
    return input;
  }
}

// Usage in workflow service
class SecureWorkflowService {
  constructor(private client: TolstoyClient) {}
  
  async executeWorkflow(flowId: string, rawInput: any): Promise<any> {
    // Step 1: Validate input structure
    const validation = InputValidator.validateWorkflowInput(rawInput);
    if (!validation.isValid) {
      throw new Error(`Input validation failed: ${validation.errors?.join(', ')}`);
    }
    
    // Step 2: Sanitize input data
    const sanitizedInput = InputValidator.sanitizeInput(validation.data);
    
    // Step 3: Add security metadata
    const secureInput = {
      ...sanitizedInput,
      _security: {
        validatedAt: new Date().toISOString(),
        clientVersion: '1.0.0',
        ipAddress: this.getClientIP(), // If available
        userAgent: this.getUserAgent() // If available
      }
    };
    
    // Step 4: Execute workflow
    return this.client.runFlow(flowId, secureInput);
  }
  
  private getClientIP(): string {
    // Implementation depends on your environment
    return 'unknown';
  }
  
  private getUserAgent(): string {
    // Implementation depends on your environment
    return 'tolstoy-sdk';
  }
}
```

### 3. Audit Logging

```typescript
interface AuditLog {
  timestamp: Date;
  action: string;
  resource: string;
  userId: string;
  orgId: string;
  metadata: any;
  result: 'success' | 'failure';
  error?: string;
}

class AuditLogger {
  private logs: AuditLog[] = [];
  
  log(entry: Omit<AuditLog, 'timestamp'>): void {
    const auditEntry: AuditLog = {
      timestamp: new Date(),
      ...entry
    };
    
    this.logs.push(auditEntry);
    
    // In production, send to logging service immediately
    this.persistLog(auditEntry);
  }
  
  private async persistLog(entry: AuditLog): Promise<void> {
    // Send to logging service (CloudWatch, Splunk, etc.)
    console.log('AUDIT:', JSON.stringify(entry));
    
    // Also store in database for compliance
    // await this.database.auditLogs.insert(entry);
  }
  
  async getAuditTrail(filters: {
    userId?: string;
    action?: string;
    startDate?: Date;
    endDate?: Date;
  }): Promise<AuditLog[]> {
    return this.logs.filter(log => {
      if (filters.userId && log.userId !== filters.userId) return false;
      if (filters.action && log.action !== filters.action) return false;
      if (filters.startDate && log.timestamp < filters.startDate) return false;
      if (filters.endDate && log.timestamp > filters.endDate) return false;
      return true;
    });
  }
}

class AuditedWorkflowService {
  constructor(
    private client: TolstoyClient,
    private auditLogger: AuditLogger
  ) {}
  
  async executeWorkflow(flowId: string, inputs: any): Promise<any> {
    const startTime = Date.now();
    
    try {
      // Log workflow execution attempt
      this.auditLogger.log({
        action: 'workflow_execute_start',
        resource: `workflow:${flowId}`,
        userId: this.client.userId,
        orgId: this.client.orgId,
        metadata: {
          flowId,
          inputKeys: Object.keys(inputs),
          timestamp: new Date().toISOString()
        },
        result: 'success'
      });
      
      const result = await this.client.runFlow(flowId, inputs);
      
      // Log successful execution
      this.auditLogger.log({
        action: 'workflow_execute_success',
        resource: `workflow:${flowId}`,
        userId: this.client.userId,
        orgId: this.client.orgId,
        metadata: {
          flowId,
          executionId: result.data.executionId,
          duration: Date.now() - startTime
        },
        result: 'success'
      });
      
      return result;
    } catch (error) {
      // Log failed execution
      this.auditLogger.log({
        action: 'workflow_execute_failure',
        resource: `workflow:${flowId}`,
        userId: this.client.userId,
        orgId: this.client.orgId,
        metadata: {
          flowId,
          duration: Date.now() - startTime,
          errorType: error.constructor.name
        },
        result: 'failure',
        error: error.message
      });
      
      throw error;
    }
  }
}
```

## Testing Strategies

### 1. Unit Testing with Mocks

```typescript
import { jest } from '@jest/globals';
import { TolstoyClient } from '@joosuhail/tolstoy-sdk';

// Mock the entire SDK
jest.mock('@joosuhail/tolstoy-sdk');

describe('WorkflowService', () => {
  let mockClient: jest.Mocked<TolstoyClient>;
  let workflowService: WorkflowService;
  
  beforeEach(() => {
    // Create a mocked client
    mockClient = {
      runFlow: jest.fn(),
      listFlows: jest.fn(),
      getFlowExecution: jest.fn(),
      createTool: jest.fn(),
      createWebhook: jest.fn(),
      raw: {
        health: {
          healthControllerGetHealth: jest.fn()
        }
      }
    } as any;
    
    // Cast the constructor to return our mock
    (TolstoyClient as jest.MockedClass<typeof TolstoyClient>).mockImplementation(() => mockClient);
    
    workflowService = new WorkflowService(mockClient, mockLogger);
  });
  
  afterEach(() => {
    jest.clearAllMocks();
  });
  
  describe('executeWorkflow', () => {
    it('should execute workflow successfully', async () => {
      // Arrange
      const flowId = 'test-flow';
      const inputs = { userId: 'user123' };
      const expectedResult = {
        data: {
          executionId: 'exec123',
          status: 'running'
        }
      };
      
      mockClient.runFlow.mockResolvedValue(expectedResult);
      
      // Act
      const result = await workflowService.executeWorkflow(flowId, inputs);
      
      // Assert
      expect(mockClient.runFlow).toHaveBeenCalledWith(flowId, {
        ...inputs,
        _metadata: expect.objectContaining({
          timestamp: expect.any(String),
          source: 'workflow-service'
        })
      });
      expect(result).toBe(expectedResult.data);
    });
    
    it('should handle workflow execution failure', async () => {
      // Arrange
      const flowId = 'test-flow';
      const inputs = { userId: 'user123' };
      const error = new Error('Workflow failed');
      
      mockClient.runFlow.mockRejectedValue(error);
      
      // Act & Assert
      await expect(workflowService.executeWorkflow(flowId, inputs))
        .rejects.toThrow(WorkflowExecutionError);
      
      expect(mockClient.runFlow).toHaveBeenCalledTimes(1);
    });
    
    it('should validate required inputs', async () => {
      // Arrange
      const flowId = 'test-flow';
      const invalidInputs = {}; // Missing required fields
      
      // Act & Assert
      await expect(workflowService.executeWorkflow(flowId, invalidInputs))
        .rejects.toThrow('Validation failed');
      
      expect(mockClient.runFlow).not.toHaveBeenCalled();
    });
  });
});
```

### 2. Integration Testing

```typescript
describe('TolstoyClient Integration Tests', () => {
  let client: TolstoyClient;
  let testWorkflowId: string;
  
  beforeAll(async () => {
    // Use test environment credentials
    client = new TolstoyClient(
      process.env.TEST_TOLSTOY_API_URL!,
      process.env.TEST_TOLSTOY_ORG_ID!,
      process.env.TEST_TOLSTOY_USER_ID!,
      process.env.TEST_TOLSTOY_API_KEY!
    );
    
    // Verify connection
    const health = await client.raw.health.healthControllerGetHealth();
    expect(health.data).toBeDefined();
    
    // Find or create a test workflow
    const flows = await client.listFlows();
    const testFlow = flows.data.find(f => f.name.includes('test'));
    testWorkflowId = testFlow?.id || 'default-test-flow';
  });
  
  describe('Workflow Operations', () => {
    it('should list workflows', async () => {
      const flows = await client.listFlows();
      
      expect(Array.isArray(flows.data)).toBe(true);
      expect(flows.data.length).toBeGreaterThan(0);
      
      flows.data.forEach(flow => {
        expect(flow).toHaveProperty('id');
        expect(flow).toHaveProperty('name');
        expect(typeof flow.active).toBe('boolean');
      });
    });
    
    it('should execute workflow and monitor completion', async () => {
      const inputs = {
        testData: 'integration-test',
        timestamp: new Date().toISOString(),
        userId: 'test-user-123'
      };
      
      // Execute workflow
      const execution = await client.runFlow(testWorkflowId, inputs);
      
      expect(execution.data).toHaveProperty('executionId');
      expect(execution.data).toHaveProperty('status');
      
      // Monitor execution (with timeout)
      let status = 'running';
      let attempts = 0;
      const maxAttempts = 30; // 5 minutes
      
      while (status === 'running' && attempts < maxAttempts) {
        const executionStatus = await client.getFlowExecution(
          testWorkflowId,
          execution.data.executionId
        );
        
        status = executionStatus.data.status;
        
        if (status === 'running') {
          await new Promise(resolve => setTimeout(resolve, 10000)); // Wait 10 seconds
          attempts++;
        }
      }
      
      expect(['completed', 'failed']).toContain(status);
      
      if (status === 'completed') {
        console.log('‚úÖ Integration test workflow completed successfully');
      } else {
        console.log('‚ö†Ô∏è  Integration test workflow failed (this might be expected for test workflows)');
      }
    }, 300000); // 5 minute timeout
  });
  
  describe('Tool Management', () => {
    let createdToolId: string;
    
    it('should create a tool integration', async () => {
      const toolConfig = {
        name: `Test Tool ${Date.now()}`,
        baseUrl: 'https://httpbin.org',
        authType: 'none' as const,
        description: 'Test tool for integration tests'
      };
      
      const tool = await client.createTool(toolConfig);
      
      expect(tool.data).toHaveProperty('id');
      expect(tool.data.name).toBe(toolConfig.name);
      expect(tool.data.baseUrl).toBe(toolConfig.baseUrl);
      
      createdToolId = tool.data.id;
    });
    
    it('should list tools including created tool', async () => {
      const tools = await client.listTools();
      
      expect(Array.isArray(tools.data)).toBe(true);
      
      const createdTool = tools.data.find(t => t.id === createdToolId);
      expect(createdTool).toBeDefined();
    });
    
    afterAll(async () => {
      // Clean up created tool
      if (createdToolId) {
        try {
          await client.raw.tools.toolsControllerRemove(createdToolId);
          console.log('üßπ Cleaned up test tool');
        } catch (error) {
          console.warn('‚ö†Ô∏è  Could not clean up test tool:', error.message);
        }
      }
    });
  });
});
```

### 3. Load Testing

```typescript
import { performance } from 'perf_hooks';

class LoadTestRunner {
  constructor(private client: TolstoyClient) {}
  
  async runLoadTest(config: {
    flowId: string;
    concurrency: number;
    duration: number; // in seconds
    inputGenerator: () => any;
  }) {
    console.log(`Starting load test: ${config.concurrency} concurrent users for ${config.duration}s`);
    
    const startTime = performance.now();
    const endTime = startTime + (config.duration * 1000);
    
    const results = {
      totalRequests: 0,
      successfulRequests: 0,
      failedRequests: 0,
      averageResponseTime: 0,
      minResponseTime: Infinity,
      maxResponseTime: 0,
      responseTimes: [] as number[]
    };
    
    const workers = Array.from({ length: config.concurrency }, () =>
      this.createWorker(config, endTime, results)
    );
    
    await Promise.all(workers);
    
    // Calculate statistics
    results.averageResponseTime = results.responseTimes.reduce((a, b) => a + b, 0) / results.responseTimes.length;
    results.minResponseTime = Math.min(...results.responseTimes);
    results.maxResponseTime = Math.max(...results.responseTimes);
    
    const actualDuration = (performance.now() - startTime) / 1000;
    const requestsPerSecond = results.totalRequests / actualDuration;
    
    console.log('Load Test Results:');
    console.log(`Total Requests: ${results.totalRequests}`);
    console.log(`Successful: ${results.successfulRequests}`);
    console.log(`Failed: ${results.failedRequests}`);
    console.log(`Success Rate: ${(results.successfulRequests / results.totalRequests * 100).toFixed(2)}%`);
    console.log(`Requests/Second: ${requestsPerSecond.toFixed(2)}`);
    console.log(`Average Response Time: ${results.averageResponseTime.toFixed(2)}ms`);
    console.log(`Min Response Time: ${results.minResponseTime.toFixed(2)}ms`);
    console.log(`Max Response Time: ${results.maxResponseTime.toFixed(2)}ms`);
    
    return results;
  }
  
  private async createWorker(
    config: any,
    endTime: number,
    results: any
  ): Promise<void> {
    while (performance.now() < endTime) {
      const requestStart = performance.now();
      
      try {
        await this.client.runFlow(config.flowId, config.inputGenerator());
        
        const responseTime = performance.now() - requestStart;
        results.responseTimes.push(responseTime);
        results.successfulRequests++;
      } catch (error) {
        results.failedRequests++;
      }
      
      results.totalRequests++;
      
      // Small delay to prevent overwhelming
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
}

// Usage
const loadTester = new LoadTestRunner(client);

const results = await loadTester.runLoadTest({
  flowId: 'performance-test-flow',
  concurrency: 10,
  duration: 60, // 1 minute
  inputGenerator: () => ({
    userId: `load-test-user-${Math.floor(Math.random() * 1000)}`,
    timestamp: new Date().toISOString(),
    testData: Math.random().toString(36)
  })
});
```

## Monitoring & Observability

### 1. Metrics Collection

```typescript
class MetricsCollector {
  private metrics = new Map<string, number>();
  private counters = new Map<string, number>();
  private histograms = new Map<string, number[]>();
  
  increment(name: string, value: number = 1): void {
    this.counters.set(name, (this.counters.get(name) || 0) + value);
  }
  
  gauge(name: string, value: number): void {
    this.metrics.set(name, value);
  }
  
  histogram(name: string, value: number): void {
    if (!this.histograms.has(name)) {
      this.histograms.set(name, []);
    }
    this.histograms.get(name)!.push(value);
  }
  
  getMetrics(): any {
    const result: any = {
      counters: Object.fromEntries(this.counters),
      gauges: Object.fromEntries(this.metrics),
      histograms: {}
    };
    
    // Calculate histogram statistics
    for (const [name, values] of this.histograms.entries()) {
      const sorted = values.sort((a, b) => a - b);
      result.histograms[name] = {
        count: values.length,
        min: sorted[0],
        max: sorted[sorted.length - 1],
        mean: values.reduce((a, b) => a + b, 0) / values.length,
        p50: sorted[Math.floor(sorted.length * 0.5)],
        p95: sorted[Math.floor(sorted.length * 0.95)],
        p99: sorted[Math.floor(sorted.length * 0.99)]
      };
    }
    
    return result;
  }
  
  reset(): void {
    this.metrics.clear();
    this.counters.clear();
    this.histograms.clear();
  }
}

class MonitoredWorkflowService {
  private metrics = new MetricsCollector();
  
  constructor(private client: TolstoyClient) {
    // Report metrics every minute
    setInterval(() => {
      this.reportMetrics();
    }, 60000);
  }
  
  async executeWorkflow(flowId: string, inputs: any): Promise<any> {
    const startTime = performance.now();
    
    try {
      this.metrics.increment('workflow_executions_total');
      this.metrics.increment(`workflow_executions_${flowId}`);
      
      const result = await this.client.runFlow(flowId, inputs);
      
      const duration = performance.now() - startTime;
      this.metrics.histogram('workflow_execution_duration', duration);
      this.metrics.increment('workflow_executions_successful');
      
      return result;
    } catch (error) {
      const duration = performance.now() - startTime;
      this.metrics.histogram('workflow_execution_duration', duration);
      this.metrics.increment('workflow_executions_failed');
      this.metrics.increment(`workflow_executions_failed_${error.constructor.name}`);
      
      throw error;
    }
  }
  
  private reportMetrics(): void {
    const metrics = this.metrics.getMetrics();
    console.log('üìä Workflow Metrics:', JSON.stringify(metrics, null, 2));
    
    // Send to monitoring service (Prometheus, DataDog, etc.)
    // await this.sendToMonitoringService(metrics);
    
    // Reset counters (keep gauges and histograms for next period)
    this.metrics.reset();
  }
}
```

### 2. Health Checks

```typescript
interface HealthStatus {
  status: 'healthy' | 'unhealthy' | 'degraded';
  timestamp: Date;
  checks: Record<string, {
    status: 'pass' | 'fail';
    message?: string;
    duration?: number;
  }>;
}

class HealthChecker {
  constructor(private client: TolstoyClient) {}
  
  async checkHealth(): Promise<HealthStatus> {
    const checks: HealthStatus['checks'] = {};
    const startTime = performance.now();
    
    // Check API connectivity
    try {
      const apiStart = performance.now();
      await this.client.raw.health.healthControllerGetHealth();
      checks.api = {
        status: 'pass',
        duration: performance.now() - apiStart
      };
    } catch (error) {
      checks.api = {
        status: 'fail',
        message: error.message
      };
    }
    
    // Check workflow listing
    try {
      const flowStart = performance.now();
      await this.client.listFlows();
      checks.workflows = {
        status: 'pass',
        duration: performance.now() - flowStart
      };
    } catch (error) {
      checks.workflows = {
        status: 'fail',
        message: error.message
      };
    }
    
    // Check tool listing
    try {
      const toolStart = performance.now();
      await this.client.listTools();
      checks.tools = {
        status: 'pass',
        duration: performance.now() - toolStart
      };
    } catch (error) {
      checks.tools = {
        status: 'fail',
        message: error.message
      };
    }
    
    // Determine overall status
    const failedChecks = Object.values(checks).filter(check => check.status === 'fail').length;
    const totalChecks = Object.keys(checks).length;
    
    let overallStatus: HealthStatus['status'];
    if (failedChecks === 0) {
      overallStatus = 'healthy';
    } else if (failedChecks < totalChecks) {
      overallStatus = 'degraded';
    } else {
      overallStatus = 'unhealthy';
    }
    
    return {
      status: overallStatus,
      timestamp: new Date(),
      checks
    };
  }
  
  async startHealthMonitoring(intervalMs: number = 30000): Promise<void> {
    const checkHealth = async () => {
      try {
        const health = await this.checkHealth();
        console.log(`üè• Health Check [${health.status.toUpperCase()}]`);
        
        if (health.status !== 'healthy') {
          const failedChecks = Object.entries(health.checks)
            .filter(([_, check]) => check.status === 'fail')
            .map(([name, check]) => `${name}: ${check.message}`);
          
          console.warn('‚ö†Ô∏è  Failed health checks:', failedChecks.join(', '));
        }
        
        // Send to monitoring system
        // await this.sendHealthMetrics(health);
      } catch (error) {
        console.error('‚ùå Health check failed:', error.message);
      }
    };
    
    // Initial check
    await checkHealth();
    
    // Schedule regular checks
    setInterval(checkHealth, intervalMs);
  }
}

// Usage
const healthChecker = new HealthChecker(client);
await healthChecker.startHealthMonitoring(30000); // Check every 30 seconds
```

## Deployment Patterns

### 1. Environment-Specific Configuration

```typescript
// config/index.ts
export interface AppConfig {
  tolstoy: {
    apiUrl: string;
    orgId: string;
    userId: string;
    apiKey: string;
    timeout: number;
    retries: number;
  };
  logging: {
    level: string;
    format: string;
  };
  monitoring: {
    enabled: boolean;
    interval: number;
  };
}

const environments = {
  development: {
    tolstoy: {
      apiUrl: process.env.DEV_TOLSTOY_API_URL || 'https://api-dev.tolstoy.com',
      orgId: process.env.DEV_TOLSTOY_ORG_ID!,
      userId: process.env.DEV_TOLSTOY_USER_ID!,
      apiKey: process.env.DEV_TOLSTOY_API_KEY!,
      timeout: 60000,
      retries: 1
    },
    logging: {
      level: 'debug',
      format: 'pretty'
    },
    monitoring: {
      enabled: true,
      interval: 60000
    }
  },
  
  production: {
    tolstoy: {
      apiUrl: process.env.TOLSTOY_API_URL!,
      orgId: process.env.TOLSTOY_ORG_ID!,
      userId: process.env.TOLSTOY_USER_ID!,
      apiKey: process.env.TOLSTOY_API_KEY!,
      timeout: 30000,
      retries: 5
    },
    logging: {
      level: 'info',
      format: 'json'
    },
    monitoring: {
      enabled: true,
      interval: 30000
    }
  }
} as const;

export function getConfig(): AppConfig {
  const env = process.env.NODE_ENV || 'development';
  return environments[env as keyof typeof environments] || environments.development;
}
```

### 2. Graceful Shutdown

```typescript
class GracefulShutdownManager {
  private isShuttingDown = false;
  private activeOperations = new Set<Promise<any>>();
  
  constructor() {
    // Listen for shutdown signals
    process.on('SIGTERM', () => this.shutdown('SIGTERM'));
    process.on('SIGINT', () => this.shutdown('SIGINT'));
    process.on('SIGUSR2', () => this.shutdown('SIGUSR2')); // Nodemon restart
  }
  
  async trackOperation<T>(operation: Promise<T>): Promise<T> {
    if (this.isShuttingDown) {
      throw new Error('Application is shutting down');
    }
    
    this.activeOperations.add(operation);
    
    try {
      return await operation;
    } finally {
      this.activeOperations.delete(operation);
    }
  }
  
  private async shutdown(signal: string): Promise<void> {
    if (this.isShuttingDown) {
      console.log('üîÑ Shutdown already in progress...');
      return;
    }
    
    this.isShuttingDown = true;
    console.log(`üîÑ Received ${signal}, starting graceful shutdown...`);
    
    // Stop accepting new operations
    console.log('‚èπÔ∏è  Stopping new operations...');
    
    // Wait for active operations to complete (with timeout)
    if (this.activeOperations.size > 0) {
      console.log(`‚è≥ Waiting for ${this.activeOperations.size} active operations to complete...`);
      
      const shutdownTimeout = setTimeout(() => {
        console.log('‚è∞ Shutdown timeout reached, forcing exit...');
        process.exit(1);
      }, 30000); // 30 second timeout
      
      try {
        await Promise.all(Array.from(this.activeOperations));
        console.log('‚úÖ All operations completed successfully');
      } catch (error) {
        console.error('‚ùå Some operations failed during shutdown:', error.message);
      } finally {
        clearTimeout(shutdownTimeout);
      }
    }
    
    console.log('üëã Graceful shutdown complete');
    process.exit(0);
  }
}

// Usage with workflow service
class ProductionWorkflowService {
  private shutdownManager = new GracefulShutdownManager();
  
  constructor(private client: TolstoyClient) {}
  
  async executeWorkflow(flowId: string, inputs: any): Promise<any> {
    // Track the operation for graceful shutdown
    return this.shutdownManager.trackOperation(
      this.client.runFlow(flowId, inputs)
    );
  }
}
```

## Summary

These patterns and practices will help you build robust, scalable, and secure applications with the Tolstoy SDK:

### Key Takeaways

‚úÖ **Architecture**: Use service-oriented patterns with proper separation of concerns
‚úÖ **Error Handling**: Implement comprehensive error classification and retry strategies  
‚úÖ **Performance**: Optimize with connection pooling, caching, and batch operations
‚úÖ **Security**: Secure credentials, validate inputs, and maintain audit trails
‚úÖ **Testing**: Use unit, integration, and load testing strategies
‚úÖ **Monitoring**: Implement health checks, metrics collection, and observability
‚úÖ **Deployment**: Use environment-specific config and graceful shutdown

### Next Steps

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
  <div className="border rounded-lg p-4">
    <h3 className="text-lg font-semibold mb-2">üèóÔ∏è Advanced Architecture</h3>
    <p className="text-sm text-gray-600 mb-3">Learn about microservices, event sourcing, and CQRS patterns.</p>
    <a href="/sdk/guides/architecture" className="text-blue-600 font-medium">Architecture Guide ‚Üí</a>
  </div>
  
  <div className="border rounded-lg p-4">
    <h3 className="text-lg font-semibold mb-2">üìä Production Monitoring</h3>
    <p className="text-sm text-gray-600 mb-3">Set up comprehensive monitoring and alerting for production systems.</p>
    <a href="/sdk/guides/monitoring" className="text-blue-600 font-medium">Monitoring Guide ‚Üí</a>
  </div>
</div>

---

*üöÄ Following these best practices will ensure your Tolstoy SDK integration is production-ready, secure, and maintainable at scale.*