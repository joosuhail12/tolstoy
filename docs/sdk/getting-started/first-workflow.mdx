---
title: "Your First Workflow"
description: "Step-by-step tutorial to create, execute, and monitor your first workflow using the Tolstoy SDK with practical examples and best practices."
sidebar_position: 3
---

# Your First Workflow

Learn how to create, execute, and monitor your first workflow using the Tolstoy SDK. This tutorial takes you from setup to a working automation in under 10 minutes.

## Prerequisites

Before starting, make sure you have:

- ‚úÖ Installed the Tolstoy SDK ([Installation Guide](/sdk/getting-started/installation))
- ‚úÖ Configured authentication ([Authentication Guide](/sdk/getting-started/authentication))
- ‚úÖ A valid Tolstoy account with proper permissions

## Step 1: Initialize Your Client

```typescript
import { TolstoyClient } from '@joosuhail/tolstoy-sdk';

// Initialize authenticated client
const client = new TolstoyClient(
  process.env.TOLSTOY_API_URL || 'https://tolstoy.getpullse.com',
  process.env.TOLSTOY_ORG_ID!,
  process.env.TOLSTOY_USER_ID!,
  process.env.TOLSTOY_API_KEY!
);

// Verify connection
async function verifyConnection() {
  try {
    const health = await client.raw.health.healthControllerGetHealth();
    console.log('‚úÖ Connected to Tolstoy:', health.data.status);
    return true;
  } catch (error) {
    console.error('‚ùå Connection failed:', error.message);
    return false;
  }
}

const isConnected = await verifyConnection();
if (!isConnected) {
  process.exit(1);
}
```

## Step 2: Explore Available Workflows

Before creating your first workflow, let's see what's available:

```typescript
// List all available workflows
async function exploreWorkflows() {
  try {
    const flows = await client.listFlows();
    
    console.log(`üìö Found ${flows.data.length} workflows:`);
    
    flows.data.forEach((flow, index) => {
      console.log(`\n${index + 1}. ${flow.name} (${flow.id})`);
      console.log(`   üìù ${flow.description || 'No description'}`);
      console.log(`   üè∑Ô∏è  Status: ${flow.active ? '‚úÖ Active' : '‚ùå Inactive'}`);
      console.log(`   üìÖ Created: ${new Date(flow.createdAt).toLocaleDateString()}`);
      
      if (flow.tags && flow.tags.length > 0) {
        console.log(`   üè∑Ô∏è  Tags: ${flow.tags.join(', ')}`);
      }
    });
    
    // Find beginner-friendly workflows
    const beginnerFlows = flows.data.filter(flow => 
      flow.name.toLowerCase().includes('test') ||
      flow.name.toLowerCase().includes('demo') ||
      flow.name.toLowerCase().includes('simple') ||
      flow.tags?.some(tag => tag.toLowerCase().includes('beginner'))
    );
    
    if (beginnerFlows.length > 0) {
      console.log(`\nüéØ Beginner-friendly workflows:`);
      beginnerFlows.forEach(flow => {
        console.log(`   ‚Ä¢ ${flow.name} (${flow.id})`);
      });
    }
    
    return flows.data;
  } catch (error) {
    console.error('‚ùå Failed to list workflows:', error.message);
    return [];
  }
}

const availableFlows = await exploreWorkflows();
```

## Step 3: Execute Your First Workflow

### Simple Workflow Execution

Let's start with a simple workflow execution:

```typescript
// Execute a basic workflow
async function executeSimpleWorkflow() {
  try {
    console.log('üöÄ Executing your first workflow...');
    
    // Use a simple test workflow or the first available one
    const flowId = 'test_workflow'; // Replace with an actual flow ID from step 2
    
    const execution = await client.runFlow(flowId, {
      // Basic input data
      message: 'Hello from my first workflow!',
      timestamp: new Date().toISOString(),
      userId: 'first_time_user',
      
      // Workflow metadata
      source: 'first_workflow_tutorial',
      version: '1.0',
      
      // Any additional data your workflow needs
      preferences: {
        notifications: true,
        logging: 'verbose'
      }
    });
    
    console.log('‚úÖ Workflow execution started!');
    console.log(`üìä Execution ID: ${execution.data.executionId}`);
    console.log(`üèÉ Status: ${execution.data.status}`);
    
    return execution.data;
  } catch (error) {
    console.error('‚ùå Workflow execution failed:', error.message);
    
    // Handle common errors
    if (error.response?.status === 404) {
      console.error('üí° The workflow might not exist. Check the flow ID.');
    } else if (error.response?.status === 400) {
      console.error('üí° Invalid input data. Check the workflow requirements.');
    } else if (error.response?.status === 403) {
      console.error('üí° Permission denied. Check your API credentials and permissions.');
    }
    
    throw error;
  }
}

// Execute the workflow
const execution = await executeSimpleWorkflow();
```

### Advanced Workflow Execution with Validation

```typescript
// More robust workflow execution with input validation
class WorkflowExecutor {
  private client: TolstoyClient;
  
  constructor(client: TolstoyClient) {
    this.client = client;
  }
  
  // Validate workflow exists and is active
  async validateWorkflow(flowId: string): Promise<boolean> {
    try {
      const flows = await this.client.listFlows();
      const workflow = flows.data.find(f => f.id === flowId);
      
      if (!workflow) {
        console.error(`‚ùå Workflow '${flowId}' not found`);
        return false;
      }
      
      if (!workflow.active) {
        console.error(`‚ùå Workflow '${flowId}' is inactive`);
        return false;
      }
      
      console.log(`‚úÖ Workflow '${workflow.name}' is available and active`);
      return true;
    } catch (error) {
      console.error('‚ùå Failed to validate workflow:', error.message);
      return false;
    }
  }
  
  // Execute workflow with comprehensive error handling
  async execute(flowId: string, inputs: any, options: {
    timeout?: number;
    retries?: number;
    validateInputs?: boolean;
  } = {}) {
    const { timeout = 30000, retries = 3, validateInputs = true } = options;
    
    // Step 1: Validate workflow
    const isValid = await this.validateWorkflow(flowId);
    if (!isValid) {
      throw new Error(`Workflow validation failed for: ${flowId}`);
    }
    
    // Step 2: Validate inputs (if requested)
    if (validateInputs) {
      const validationResult = this.validateInputs(inputs);
      if (!validationResult.isValid) {
        throw new Error(`Input validation failed: ${validationResult.errors.join(', ')}`);
      }
    }
    
    // Step 3: Execute with retries
    let lastError: any;
    
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        console.log(`üöÄ Attempt ${attempt}/${retries}: Executing workflow ${flowId}`);
        
        const startTime = Date.now();
        const execution = await this.client.runFlow(flowId, {
          ...inputs,
          _metadata: {
            executionTime: new Date().toISOString(),
            attempt,
            timeout,
            source: 'first-workflow-tutorial'
          }
        });
        
        const duration = Date.now() - startTime;
        console.log(`‚úÖ Workflow started successfully in ${duration}ms`);
        console.log(`üìä Execution details:`, {
          executionId: execution.data.executionId,
          status: execution.data.status,
          flowId,
          attempt,
          duration: `${duration}ms`
        });
        
        return execution.data;
      } catch (error) {
        lastError = error;
        console.error(`‚ùå Attempt ${attempt} failed:`, error.message);
        
        // Don't retry for certain error types
        if (error.response?.status === 404 || error.response?.status === 403) {
          break;
        }
        
        // Wait before retrying (exponential backoff)
        if (attempt < retries) {
          const delay = Math.min(1000 * Math.pow(2, attempt - 1), 10000);
          console.log(`‚è±Ô∏è  Waiting ${delay}ms before retry...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    throw lastError;
  }
  
  private validateInputs(inputs: any): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    // Basic validation rules
    if (!inputs) {
      errors.push('Inputs cannot be null or undefined');
    } else if (typeof inputs !== 'object') {
      errors.push('Inputs must be an object');
    } else {
      // Check for required fields (customize based on your workflows)
      const requiredFields = ['timestamp']; // Add your required fields
      
      for (const field of requiredFields) {
        if (!inputs[field]) {
          errors.push(`Missing required field: ${field}`);
        }
      }
      
      // Validate timestamp format
      if (inputs.timestamp && !Date.parse(inputs.timestamp)) {
        errors.push('Invalid timestamp format');
      }
    }
    
    return {
      isValid: errors.length === 0,
      errors
    };
  }
}

// Usage
const executor = new WorkflowExecutor(client);

const execution = await executor.execute('user_onboarding', {
  userId: 'user_123',
  email: 'user@example.com',
  name: 'John Doe',
  timestamp: new Date().toISOString(),
  plan: 'free',
  source: 'signup_form'
}, {
  timeout: 60000,
  retries: 3,
  validateInputs: true
});
```

## Step 4: Monitor Execution Progress

Once you've started a workflow, you'll want to monitor its progress:

```typescript
// Monitor workflow execution with real-time updates
async function monitorExecution(flowId: string, executionId: string) {
  console.log(`üîç Monitoring execution: ${executionId}`);
  
  let status = 'running';
  let attempts = 0;
  const maxAttempts = 60; // 10 minutes with 10-second intervals
  const pollInterval = 10000; // 10 seconds
  
  while (status === 'running' && attempts < maxAttempts) {
    try {
      const execution = await client.getFlowExecution(flowId, executionId);
      status = execution.data.status;
      attempts++;
      
      // Progress indicator
      const progress = attempts <= maxAttempts ? (attempts / maxAttempts * 100).toFixed(1) : '100.0';
      const statusEmoji = {
        'running': 'üèÉ',
        'completed': '‚úÖ',
        'failed': '‚ùå',
        'cancelled': '‚èπÔ∏è',
        'pending': '‚è≥'
      }[status] || '‚ùì';
      
      console.log(`${statusEmoji} [${progress}%] Status: ${status} (check ${attempts}/${maxAttempts})`);
      
      // Show additional details if available
      if (execution.data.currentStep) {
        console.log(`   üìç Current step: ${execution.data.currentStep}`);
      }
      
      if (execution.data.progress) {
        console.log(`   üìä Progress: ${execution.data.progress}%`);
      }
      
      // Check if execution is complete
      if (['completed', 'failed', 'cancelled'].includes(status)) {
        console.log(`\nüéØ Final Status: ${status.toUpperCase()}`);
        
        if (status === 'completed') {
          console.log('üéâ Workflow completed successfully!');
          
          if (execution.data.result) {
            console.log('üìã Results:');
            console.log(JSON.stringify(execution.data.result, null, 2));
          }
          
          if (execution.data.metrics) {
            console.log('üìà Metrics:');
            console.log(`   ‚è±Ô∏è  Duration: ${execution.data.metrics.durationMs}ms`);
            console.log(`   üî¢ Steps completed: ${execution.data.metrics.stepsCompleted}`);
            console.log(`   üíæ Data processed: ${execution.data.metrics.dataProcessed || 'N/A'}`);
          }
        } else if (status === 'failed') {
          console.log('üí• Workflow failed!');
          
          if (execution.data.error) {
            console.log('üêõ Error details:');
            console.log(`   Message: ${execution.data.error.message}`);
            console.log(`   Step: ${execution.data.error.step || 'Unknown'}`);
            console.log(`   Code: ${execution.data.error.code || 'Unknown'}`);
          }
          
          // Suggest next steps
          console.log('\nüí° Troubleshooting suggestions:');
          console.log('   ‚Ä¢ Check workflow inputs for correctness');
          console.log('   ‚Ä¢ Verify all required tools are configured');
          console.log('   ‚Ä¢ Review the workflow definition for errors');
          console.log('   ‚Ä¢ Check the execution logs for detailed error information');
        }
        
        return {
          status,
          duration: Date.now(),
          result: execution.data
        };
      }
      
      // Wait before next check
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    } catch (error) {
      console.error('‚ùå Error checking execution status:', error.message);
      attempts++;
      
      if (attempts < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, pollInterval));
      }
    }
  }
  
  if (attempts >= maxAttempts) {
    console.log('‚è∞ Monitoring timeout reached');
    console.log('üí° The workflow might still be running. Check manually or extend the timeout.');
  }
  
  return { status: 'timeout', duration: Date.now() };
}

// Monitor the execution
const result = await monitorExecution('user_onboarding', execution.executionId);
```

## Step 5: Handle Results and Next Steps

After your workflow completes, you'll want to handle the results:

```typescript
// Handle workflow completion
async function handleWorkflowCompletion(executionResult: any) {
  const { status, result } = executionResult;
  
  switch (status) {
    case 'completed':
      console.log('‚úÖ Processing successful workflow completion...');
      
      // Extract useful data from results
      if (result.result) {
        const workflowData = result.result;
        
        // Example: Handle user onboarding completion
        if (workflowData.userId) {
          console.log(`üë§ User ${workflowData.userId} onboarded successfully`);
          
          // Send welcome notification
          if (workflowData.email) {
            console.log(`üìß Sending welcome email to ${workflowData.email}`);
            // await sendWelcomeEmail(workflowData.email, workflowData);
          }
          
          // Update user status in database
          console.log('üíæ Updating user status in database');
          // await updateUserStatus(workflowData.userId, 'onboarded');
        }
      }
      
      // Log success metrics
      console.log('üìä Success metrics logged');
      break;
      
    case 'failed':
      console.log('‚ùå Processing workflow failure...');
      
      // Send failure notifications
      console.log('üö® Sending failure alerts');
      // await sendFailureAlert(result);
      
      // Log error for debugging
      console.log('üìù Logging error details for debugging');
      // await logWorkflowError(result);
      
      // Implement retry logic if appropriate
      if (result.error?.retryable) {
        console.log('üîÑ Scheduling retry attempt');
        // await scheduleRetry(execution.executionId);
      }
      break;
      
    case 'timeout':
      console.log('‚è∞ Workflow monitoring timed out');
      console.log('üí° Consider checking the execution status manually');
      break;
      
    default:
      console.log(`‚ùì Unknown status: ${status}`);
  }
  
  return status;
}

// Process the workflow result
await handleWorkflowCompletion(result);
```

## Complete Example: End-to-End Workflow

Here's a complete example that puts everything together:

```typescript
import { TolstoyClient } from '@joosuhail/tolstoy-sdk';

class FirstWorkflowExample {
  private client: TolstoyClient;
  
  constructor() {
    this.client = new TolstoyClient(
      process.env.TOLSTOY_API_URL!,
      process.env.TOLSTOY_ORG_ID!,
      process.env.TOLSTOY_USER_ID!,
      process.env.TOLSTOY_API_KEY!
    );
  }
  
  async run() {
    console.log('üöÄ Starting first workflow example...\n');
    
    try {
      // Step 1: Verify connection
      await this.verifyConnection();
      
      // Step 2: Explore available workflows
      const workflows = await this.exploreWorkflows();
      
      if (workflows.length === 0) {
        throw new Error('No workflows available');
      }
      
      // Step 3: Select a workflow to execute
      const selectedFlow = this.selectWorkflow(workflows);
      
      // Step 4: Execute the workflow
      const execution = await this.executeWorkflow(selectedFlow.id, {
        userId: 'first_tutorial_user',
        email: 'tutorial@example.com',
        name: 'Tutorial User',
        timestamp: new Date().toISOString(),
        source: 'first_workflow_tutorial',
        preferences: {
          notifications: true,
          theme: 'light'
        }
      });
      
      // Step 5: Monitor execution
      const result = await this.monitorExecution(selectedFlow.id, execution.executionId);
      
      // Step 6: Handle completion
      await this.handleCompletion(result);
      
      console.log('\nüéâ First workflow tutorial completed successfully!');
      
    } catch (error) {
      console.error('\nüí• Tutorial failed:', error.message);
      console.log('\nüîß Troubleshooting steps:');
      console.log('1. Verify your environment variables are set correctly');
      console.log('2. Check your API key permissions');
      console.log('3. Ensure the selected workflow exists and is active');
      console.log('4. Review the workflow input requirements');
    }
  }
  
  private async verifyConnection(): Promise<void> {
    console.log('üîç Verifying connection...');
    const health = await this.client.raw.health.healthControllerGetHealth();
    console.log(`‚úÖ Connected to Tolstoy: ${health.data.status}\n`);
  }
  
  private async exploreWorkflows() {
    console.log('üìö Exploring available workflows...');
    const flows = await this.client.listFlows();
    
    console.log(`Found ${flows.data.length} workflows:`);
    flows.data.slice(0, 5).forEach((flow, index) => {
      console.log(`  ${index + 1}. ${flow.name} (${flow.active ? '‚úÖ' : '‚ùå'})`);
    });
    
    if (flows.data.length > 5) {
      console.log(`  ... and ${flows.data.length - 5} more\n`);
    } else {
      console.log('');
    }
    
    return flows.data.filter(flow => flow.active);
  }
  
  private selectWorkflow(workflows: any[]) {
    // Prefer demo/test workflows, otherwise use the first active one
    const testFlow = workflows.find(flow => 
      flow.name.toLowerCase().includes('test') ||
      flow.name.toLowerCase().includes('demo') ||
      flow.name.toLowerCase().includes('simple')
    );
    
    const selectedFlow = testFlow || workflows[0];
    console.log(`üéØ Selected workflow: ${selectedFlow.name} (${selectedFlow.id})\n`);
    
    return selectedFlow;
  }
  
  private async executeWorkflow(flowId: string, inputs: any) {
    console.log('üöÄ Executing workflow...');
    const execution = await this.client.runFlow(flowId, inputs);
    
    console.log(`‚úÖ Execution started: ${execution.data.executionId}`);
    console.log(`üìä Status: ${execution.data.status}\n`);
    
    return execution.data;
  }
  
  private async monitorExecution(flowId: string, executionId: string) {
    console.log('üëÅÔ∏è  Monitoring execution progress...');
    
    let status = 'running';
    let attempts = 0;
    const maxAttempts = 30; // 5 minutes
    
    while (status === 'running' && attempts < maxAttempts) {
      try {
        const execution = await this.client.getFlowExecution(flowId, executionId);
        status = execution.data.status;
        
        const statusEmoji = status === 'running' ? 'üèÉ' : 
                           status === 'completed' ? '‚úÖ' : 
                           status === 'failed' ? '‚ùå' : '‚ùì';
        
        console.log(`${statusEmoji} Check ${attempts + 1}: ${status}`);
        
        if (status !== 'running') {
          return { status, result: execution.data };
        }
        
        await new Promise(resolve => setTimeout(resolve, 10000)); // Wait 10 seconds
        attempts++;
      } catch (error) {
        console.error(`‚ö†Ô∏è  Error checking status: ${error.message}`);
        attempts++;
      }
    }
    
    return { status: attempts >= maxAttempts ? 'timeout' : status, result: null };
  }
  
  private async handleCompletion(result: any) {
    console.log('\nüìã Execution Summary:');
    console.log(`Status: ${result.status}`);
    
    if (result.status === 'completed') {
      console.log('üéâ Workflow completed successfully!');
      if (result.result?.result) {
        console.log('Results received:', Object.keys(result.result.result).length, 'properties');
      }
    } else if (result.status === 'failed') {
      console.log('‚ùå Workflow failed');
      if (result.result?.error) {
        console.log(`Error: ${result.result.error.message}`);
      }
    } else if (result.status === 'timeout') {
      console.log('‚è∞ Monitoring timed out - workflow may still be running');
    }
  }
}

// Run the complete example
async function runFirstWorkflowTutorial() {
  const tutorial = new FirstWorkflowExample();
  await tutorial.run();
}

// Execute the tutorial
await runFirstWorkflowTutorial();
```

## Common Patterns and Best Practices

### 1. Workflow Input Patterns

```typescript
// ‚úÖ Good: Structured, validated inputs
const goodInputs = {
  // Core data
  userId: 'user_123',
  email: 'user@example.com',
  
  // Metadata for tracking
  metadata: {
    source: 'web_app',
    timestamp: new Date().toISOString(),
    version: '1.0',
    sessionId: 'session_abc123'
  },
  
  // Configuration
  options: {
    notifications: true,
    async: false,
    timeout: 30000
  },
  
  // Custom data specific to your workflow
  customData: {
    referralCode: 'FRIEND2024',
    plan: 'premium',
    preferences: {
      theme: 'dark',
      language: 'en'
    }
  }
};

// ‚ùå Avoid: Flat, unstructured data
const badInputs = {
  user_id: 'user_123',
  email: 'user@example.com',
  ref_code: 'FRIEND2024',
  notif: true,
  lang: 'en'
  // Hard to maintain and validate
};
```

### 2. Error Handling Patterns

```typescript
// Comprehensive error handling wrapper
async function executeWorkflowSafely(
  client: TolstoyClient,
  flowId: string, 
  inputs: any
) {
  try {
    const execution = await client.runFlow(flowId, inputs);
    return { success: true, data: execution.data };
  } catch (error) {
    // Categorize errors for better handling
    if (error.response) {
      const status = error.response.status;
      const errorData = error.response.data;
      
      switch (status) {
        case 400:
          return {
            success: false,
            error: 'validation_error',
            message: 'Invalid input data',
            details: errorData.details
          };
        case 401:
          return {
            success: false,
            error: 'auth_error',
            message: 'Authentication failed',
            action: 'check_api_key'
          };
        case 404:
          return {
            success: false,
            error: 'not_found',
            message: `Workflow '${flowId}' not found`,
            action: 'check_flow_id'
          };
        case 429:
          return {
            success: false,
            error: 'rate_limit',
            message: 'Too many requests',
            retryAfter: error.response.headers['retry-after']
          };
        default:
          return {
            success: false,
            error: 'api_error',
            message: errorData.message || 'Unknown API error',
            status
          };
      }
    } else if (error.request) {
      return {
        success: false,
        error: 'network_error',
        message: 'Unable to reach Tolstoy API',
        action: 'check_connection'
      };
    } else {
      return {
        success: false,
        error: 'unknown_error',
        message: error.message,
        action: 'contact_support'
      };
    }
  }
}
```

### 3. Logging and Monitoring

```typescript
class WorkflowLogger {
  private logLevel: 'error' | 'warn' | 'info' | 'debug';
  
  constructor(logLevel: 'error' | 'warn' | 'info' | 'debug' = 'info') {
    this.logLevel = logLevel;
  }
  
  logExecution(flowId: string, executionId: string, inputs: any) {
    this.info('Workflow execution started', {
      flowId,
      executionId,
      inputKeys: Object.keys(inputs),
      timestamp: new Date().toISOString()
    });
  }
  
  logCompletion(executionId: string, status: string, duration: number, result?: any) {
    this.info('Workflow execution completed', {
      executionId,
      status,
      duration: `${duration}ms`,
      hasResult: !!result,
      timestamp: new Date().toISOString()
    });
  }
  
  logError(executionId: string, error: any) {
    this.error('Workflow execution failed', {
      executionId,
      error: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
  }
  
  private info(message: string, data?: any) {
    if (['info', 'debug'].includes(this.logLevel)) {
      console.log(`‚ÑπÔ∏è  ${message}`, data ? JSON.stringify(data, null, 2) : '');
    }
  }
  
  private error(message: string, data?: any) {
    console.error(`‚ùå ${message}`, data ? JSON.stringify(data, null, 2) : '');
  }
}

const logger = new WorkflowLogger('info');
```

## Troubleshooting Common Issues

### Workflow Not Found

```typescript
// Debug workflow availability
async function debugWorkflowAvailability(client: TolstoyClient, flowId: string) {
  console.log(`üîç Debugging workflow: ${flowId}`);
  
  const flows = await client.listFlows();
  const workflow = flows.data.find(f => f.id === flowId);
  
  if (!workflow) {
    console.log('‚ùå Workflow not found');
    console.log('Available workflows:');
    flows.data.forEach(f => console.log(`  ‚Ä¢ ${f.id}: ${f.name}`));
  } else {
    console.log('‚úÖ Workflow found');
    console.log(`  Name: ${workflow.name}`);
    console.log(`  Status: ${workflow.active ? 'Active' : 'Inactive'}`);
    console.log(`  Created: ${workflow.createdAt}`);
  }
}
```

### Authentication Issues

```typescript
// Debug authentication
async function debugAuthentication(client: TolstoyClient) {
  try {
    const health = await client.raw.health.healthControllerGetHealth();
    console.log('‚úÖ Authentication successful');
  } catch (error) {
    console.log('‚ùå Authentication failed');
    console.log(`Error: ${error.message}`);
    
    if (error.response?.status === 401) {
      console.log('üí° Check your API key');
    } else if (error.response?.status === 403) {
      console.log('üí° Check your permissions');
    }
  }
}
```

## Next Steps

Congratulations! You've successfully executed your first workflow. Here's what to explore next:

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-6">
  <div className="border rounded-lg p-4">
    <h3 className="text-lg font-semibold mb-2">üîß Core Features</h3>
    <p className="text-sm text-gray-600 mb-3">Explore advanced workflow features, tools, and webhooks.</p>
    <a href="/sdk/core-features" className="text-blue-600 font-medium">Core Features ‚Üí</a>
  </div>
  
  <div className="border rounded-lg p-4">
    <h3 className="text-lg font-semibold mb-2">üí° Real Examples</h3>
    <p className="text-sm text-gray-600 mb-3">See complete implementations for common use cases.</p>
    <a href="/sdk/examples" className="text-blue-600 font-medium">View Examples ‚Üí</a>
  </div>
  
  <div className="border rounded-lg p-4">
    <h3 className="text-lg font-semibold mb-2">üîó Webhooks</h3>
    <p className="text-sm text-gray-600 mb-3">Set up real-time notifications for workflow events.</p>
    <a href="/sdk/guides/webhooks" className="text-blue-600 font-medium">Webhook Guide ‚Üí</a>
  </div>
  
  <div className="border rounded-lg p-4">
    <h3 className="text-lg font-semibold mb-2">üõ†Ô∏è Tools</h3>
    <p className="text-sm text-gray-600 mb-3">Connect external APIs and services to your workflows.</p>
    <a href="/sdk/guides/tools" className="text-blue-600 font-medium">Tool Integration ‚Üí</a>
  </div>
</div>

---

*üéâ You're now ready to build powerful workflow automations! The concepts you've learned here form the foundation for all advanced Tolstoy SDK usage.*