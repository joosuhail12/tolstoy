---
title: SDK Examples
description: Complete examples and use cases for Tolstoy SDKs
---

# SDK Examples

This page provides complete, real-world examples of using Tolstoy SDKs to build powerful workflow automation solutions. Each example includes full code, explanations, and best practices.

## Basic Examples

### Simple Email Notification Flow

A basic workflow that sends an email notification when triggered.

<CodeGroup>
```typescript Node.js/TypeScript
import { Client } from '@tolstoy/sdk';

const client = new Client({
  apiKey: process.env.TOLSTOY_API_KEY!
});

async function createEmailNotificationFlow() {
  // Create the flow
  const flow = await client.flows.create({
    name: 'Email Notification Flow',
    description: 'Sends email notifications for important events',
    steps: [
      {
        key: 'send_notification',
        action: 'email',
        inputs: {
          to: '{{inputs.recipient_email}}',
          subject: '{{inputs.subject}}',
          body: `
            <h2>{{inputs.event_type}} Notification</h2>
            <p>{{inputs.message}}</p>
            <p><strong>Timestamp:</strong> {{inputs.timestamp}}</p>
          `
        }
      }
    ]
  });

  console.log('Flow created:', flow.id);
  return flow;
}

async function sendNotification(flowId: string, eventData: any) {
  const execution = await client.flows.execute(flowId, {
    inputs: {
      recipient_email: eventData.email,
      subject: `${eventData.type} - Urgent Notification`,
      event_type: eventData.type,
      message: eventData.description,
      timestamp: new Date().toISOString()
    }
  });

  // Wait for completion
  const result = await client.executions.waitForCompletion(execution.id);
  console.log('Notification sent:', result.status);
  return result;
}

// Usage
createEmailNotificationFlow().then(flow => {
  sendNotification(flow.id, {
    email: 'admin@company.com',
    type: 'System Alert',
    description: 'Server CPU usage exceeded 90%'
  });
});
```

```python Python
import os
from tolstoy import Client

client = Client(api_key=os.getenv('TOLSTOY_API_KEY'))

async def create_email_notification_flow():
    """Create a simple email notification flow"""
    flow = await client.flows.create({
        'name': 'Email Notification Flow',
        'description': 'Sends email notifications for important events',
        'steps': [
            {
                'key': 'send_notification',
                'action': 'email',
                'inputs': {
                    'to': '{{inputs.recipient_email}}',
                    'subject': '{{inputs.subject}}',
                    'body': '''
                        <h2>{{inputs.event_type}} Notification</h2>
                        <p>{{inputs.message}}</p>
                        <p><strong>Timestamp:</strong> {{inputs.timestamp}}</p>
                    '''
                }
            }
        ]
    })
    
    print(f'Flow created: {flow.id}')
    return flow

async def send_notification(flow_id: str, event_data: dict):
    """Send a notification using the flow"""
    execution = await client.flows.execute(flow_id, {
        'inputs': {
            'recipient_email': event_data['email'],
            'subject': f"{event_data['type']} - Urgent Notification",
            'event_type': event_data['type'],
            'message': event_data['description'],
            'timestamp': datetime.now().isoformat()
        }
    })
    
    # Wait for completion
    result = await client.executions.wait_for_completion(execution.id)
    print(f'Notification sent: {result.status}')
    return result

# Usage
import asyncio
from datetime import datetime

async def main():
    flow = await create_email_notification_flow()
    await send_notification(flow.id, {
        'email': 'admin@company.com',
        'type': 'System Alert',
        'description': 'Server CPU usage exceeded 90%'
    })

asyncio.run(main())
```

```go Go
package main

import (
    "context"
    "fmt"
    "os"
    "time"
    
    "github.com/tolstoy/tolstoy-go"
)

func createEmailNotificationFlow(client *tolstoy.Client) (*tolstoy.Flow, error) {
    ctx := context.Background()
    
    flow, err := client.Flows.Create(ctx, &tolstoy.CreateFlowParams{
        Name:        "Email Notification Flow",
        Description: "Sends email notifications for important events",
        Steps: []tolstoy.Step{
            {
                Key:    "send_notification",
                Action: "email",
                Inputs: map[string]interface{}{
                    "to":      "{{inputs.recipient_email}}",
                    "subject": "{{inputs.subject}}",
                    "body": `
                        <h2>{{inputs.event_type}} Notification</h2>
                        <p>{{inputs.message}}</p>
                        <p><strong>Timestamp:</strong> {{inputs.timestamp}}</p>
                    `,
                },
            },
        },
    })
    
    if err != nil {
        return nil, err
    }
    
    fmt.Printf("Flow created: %s\n", flow.ID)
    return flow, nil
}

func sendNotification(client *tolstoy.Client, flowID string, eventData map[string]interface{}) error {
    ctx := context.Background()
    
    execution, err := client.Flows.Execute(ctx, flowID, &tolstoy.ExecuteFlowParams{
        Inputs: map[string]interface{}{
            "recipient_email": eventData["email"],
            "subject":        fmt.Sprintf("%s - Urgent Notification", eventData["type"]),
            "event_type":     eventData["type"],
            "message":        eventData["description"],
            "timestamp":      time.Now().Format(time.RFC3339),
        },
    })
    
    if err != nil {
        return err
    }
    
    // Wait for completion
    result, err := client.Executions.WaitForCompletion(ctx, execution.ID)
    if err != nil {
        return err
    }
    
    fmt.Printf("Notification sent: %s\n", result.Status)
    return nil
}

func main() {
    client := tolstoy.NewClient(&tolstoy.Config{
        APIKey: os.Getenv("TOLSTOY_API_KEY"),
    })
    
    flow, err := createEmailNotificationFlow(client)
    if err != nil {
        panic(err)
    }
    
    eventData := map[string]interface{}{
        "email":       "admin@company.com",
        "type":        "System Alert",
        "description": "Server CPU usage exceeded 90%",
    }
    
    if err := sendNotification(client, flow.ID, eventData); err != nil {
        panic(err)
    }
}
```
</CodeGroup>

### Data Processing Pipeline

A workflow that fetches data from an API, processes it, and stores the results.

<CodeGroup>
```typescript Node.js/TypeScript
import { Client } from '@tolstoy/sdk';

const client = new Client({
  apiKey: process.env.TOLSTOY_API_KEY!
});

async function createDataProcessingPipeline() {
  const flow = await client.flows.create({
    name: 'User Data Processing Pipeline',
    description: 'Fetches, processes, and stores user data',
    steps: [
      // Step 1: Fetch data from API
      {
        key: 'fetch_users',
        action: 'http_request',
        inputs: {
          url: 'https://jsonplaceholder.typicode.com/users',
          method: 'GET',
          headers: {
            'Content-Type': 'application/json'
          }
        }
      },
      
      // Step 2: Process and transform data
      {
        key: 'process_users',
        action: 'transform',
        inputs: {
          data: '{{steps.fetch_users.outputs.body}}',
          operations: [
            {
              type: 'map',
              expression: `{
                id: id,
                name: name,
                email: email,
                company: company.name,
                location: address.city + ', ' + address.zipcode
              }`
            },
            {
              type: 'filter',
              condition: 'email.includes("@")'
            }
          ]
        }
      },
      
      // Step 3: Store processed data
      {
        key: 'store_data',
        action: 'database',
        inputs: {
          operation: 'bulk_insert',
          table: 'processed_users',
          data: '{{steps.process_users.outputs.result}}',
          on_conflict: 'update'
        }
      },
      
      // Step 4: Send completion notification
      {
        key: 'notify_completion',
        action: 'slack',
        inputs: {
          channel: '#data-pipeline',
          message: `
            âœ… User data processing completed
            â€¢ Fetched: {{steps.fetch_users.outputs.body.length}} users
            â€¢ Processed: {{steps.process_users.outputs.count}} valid users
            â€¢ Stored: {{steps.store_data.outputs.inserted_count}} records
          `
        }
      }
    ]
  });

  console.log('Data pipeline created:', flow.id);
  return flow;
}

async function runDataPipeline(flowId: string) {
  const execution = await client.flows.execute(flowId);
  
  // Monitor progress
  const stream = client.executions.stream(execution.id);
  
  stream.on('step_completed', (update) => {
    console.log(`âœ… Step completed: ${update.stepKey}`);
  });
  
  stream.on('completed', (result) => {
    console.log('Pipeline completed successfully!');
    console.log('Results:', result.outputs);
  });
  
  stream.on('failed', (error) => {
    console.error('Pipeline failed:', error);
  });
  
  return execution;
}

// Usage
createDataProcessingPipeline().then(flow => {
  runDataPipeline(flow.id);
});
```

```python Python
import asyncio
from tolstoy import AsyncClient

client = AsyncClient(api_key=os.getenv('TOLSTOY_API_KEY'))

async def create_data_processing_pipeline():
    """Create a comprehensive data processing pipeline"""
    flow = await client.flows.create({
        'name': 'User Data Processing Pipeline',
        'description': 'Fetches, processes, and stores user data',
        'steps': [
            # Step 1: Fetch data from API
            {
                'key': 'fetch_users',
                'action': 'http_request',
                'inputs': {
                    'url': 'https://jsonplaceholder.typicode.com/users',
                    'method': 'GET',
                    'headers': {
                        'Content-Type': 'application/json'
                    }
                }
            },
            
            # Step 2: Process and transform data
            {
                'key': 'process_users',
                'action': 'transform',
                'inputs': {
                    'data': '{{steps.fetch_users.outputs.body}}',
                    'operations': [
                        {
                            'type': 'map',
                            'expression': '''{ 
                                id: id,
                                name: name,
                                email: email,
                                company: company.name,
                                location: address.city + ', ' + address.zipcode
                            }'''
                        },
                        {
                            'type': 'filter',
                            'condition': 'email.includes("@")'
                        }
                    ]
                }
            },
            
            # Step 3: Store processed data  
            {
                'key': 'store_data',
                'action': 'database',
                'inputs': {
                    'operation': 'bulk_insert',
                    'table': 'processed_users',
                    'data': '{{steps.process_users.outputs.result}}',
                    'on_conflict': 'update'
                }
            },
            
            # Step 4: Send completion notification
            {
                'key': 'notify_completion',
                'action': 'slack',
                'inputs': {
                    'channel': '#data-pipeline',
                    'message': '''
                        âœ… User data processing completed
                        â€¢ Fetched: {{steps.fetch_users.outputs.body.length}} users
                        â€¢ Processed: {{steps.process_users.outputs.count}} valid users
                        â€¢ Stored: {{steps.store_data.outputs.inserted_count}} records
                    '''
                }
            }
        ]
    })
    
    print(f'Data pipeline created: {flow.id}')
    return flow

async def run_data_pipeline(flow_id: str):
    """Run the data pipeline and monitor progress"""
    execution = await client.flows.execute(flow_id)
    
    # Monitor progress
    async for update in client.executions.stream(execution.id):
        if update.type == 'step_completed':
            print(f'âœ… Step completed: {update.step_key}')
        elif update.type == 'completed':
            print('Pipeline completed successfully!')
            print(f'Results: {update.outputs}')
            break
        elif update.type == 'failed':
            print(f'Pipeline failed: {update.error}')
            break
    
    return execution

# Usage
async def main():
    flow = await create_data_processing_pipeline()
    await run_data_pipeline(flow.id)

asyncio.run(main())
```
</CodeGroup>

## Advanced Examples

### Conditional Workflow with Error Handling

A robust workflow that includes conditional logic, retry mechanisms, and comprehensive error handling.

<CodeGroup>
```typescript Node.js/TypeScript
import { Client, TolstoyError } from '@tolstoy/sdk';

const client = new Client({
  apiKey: process.env.TOLSTOY_API_KEY!
});

async function createAdvancedWorkflow() {
  const flow = await client.flows.create({
    name: 'Advanced Order Processing Workflow',
    description: 'Processes orders with validation, payment, and fulfillment',
    steps: [
      // Step 1: Validate order
      {
        key: 'validate_order',
        action: 'evaluate',
        inputs: {
          expression: `
            {{inputs.order.amount}} > 0 AND 
            {{inputs.order.items.length}} > 0 AND
            {{inputs.order.customer_email}} !== null
          `
        }
      },
      
      // Step 2: Check inventory (conditional)
      {
        key: 'check_inventory',
        action: 'http_request',
        condition: '{{steps.validate_order.outputs.result}} === true',
        inputs: {
          url: 'https://api.inventory.com/check',
          method: 'POST',
          body: {
            items: '{{inputs.order.items}}'
          }
        },
        retry: {
          max_attempts: 3,
          delay: 2000,
          exponential_backoff: true
        }
      },
      
      // Step 3: Process payment (conditional)
      {
        key: 'process_payment',
        action: 'http_request',
        condition: '{{steps.check_inventory.outputs.status_code}} === 200',
        inputs: {
          url: 'https://api.payments.com/charge',
          method: 'POST',
          headers: {
            'Authorization': 'Bearer {{secrets.payment_api_key}}'
          },
          body: {
            amount: '{{inputs.order.amount}}',
            currency: '{{inputs.order.currency}}',
            customer: '{{inputs.order.customer_id}}'
          }
        },
        retry: {
          max_attempts: 2,
          delay: 5000
        }
      },
      
      // Step 4a: Success notification
      {
        key: 'send_success_email',
        action: 'email',
        condition: '{{steps.process_payment.outputs.body.status}} === "succeeded"',
        inputs: {
          to: '{{inputs.order.customer_email}}',
          subject: 'Order Confirmation - #{{inputs.order.id}}',
          template: 'order_confirmation',
          data: {
            order: '{{inputs.order}}',
            payment_id: '{{steps.process_payment.outputs.body.id}}'
          }
        }
      },
      
      // Step 4b: Failure notification
      {
        key: 'send_failure_email',
        action: 'email',
        condition: '{{steps.process_payment.outputs.body.status}} !== "succeeded"',
        inputs: {
          to: '{{inputs.order.customer_email}}',
          subject: 'Order Processing Failed - #{{inputs.order.id}}',
          template: 'order_failure',
          data: {
            order: '{{inputs.order}}',
            error: '{{steps.process_payment.outputs.body.error}}'
          }
        }
      },
      
      // Step 5: Update order status
      {
        key: 'update_order_status',
        action: 'database',
        inputs: {
          operation: 'update',
          table: 'orders',
          where: { id: '{{inputs.order.id}}' },
          data: {
            status: `{{steps.process_payment.outputs.body.status === "succeeded" ? "confirmed" : "failed"}}`,
            payment_id: '{{steps.process_payment.outputs.body.id}}',
            updated_at: '{{Date.now()}}'
          }
        }
      }
    ],
    
    // Global error handling
    error_handling: {
      on_failure: {
        action: 'slack',
        inputs: {
          channel: '#order-alerts',
          message: `
            ðŸš¨ Order processing failed
            Order ID: {{inputs.order.id}}
            Customer: {{inputs.order.customer_email}}
            Error: {{error.message}}
          `
        }
      }
    }
  });

  return flow;
}

class OrderProcessor {
  private client: Client;
  private flowId: string;

  constructor(flowId: string) {
    this.client = client;
    this.flowId = flowId;
  }

  async processOrder(order: any) {
    try {
      const execution = await this.client.flows.execute(this.flowId, {
        inputs: { order }
      });

      // Wait for completion with timeout
      const result = await this.client.executions.waitForCompletion(
        execution.id,
        { timeout: 300000 } // 5 minutes
      );

      if (result.status === 'completed') {
        console.log('Order processed successfully:', order.id);
        return { success: true, executionId: execution.id };
      } else {
        console.error('Order processing failed:', result.error);
        return { success: false, error: result.error };
      }
    } catch (error) {
      if (error instanceof TolstoyError) {
        console.error('Tolstoy API error:', error.type, error.message);
      } else {
        console.error('Unexpected error:', error);
      }
      throw error;
    }
  }

  async batchProcessOrders(orders: any[]) {
    const results = await Promise.allSettled(
      orders.map(order => this.processOrder(order))
    );

    const successful = results.filter(r => r.status === 'fulfilled').length;
    const failed = results.filter(r => r.status === 'rejected').length;

    console.log(`Batch processing completed: ${successful} successful, ${failed} failed`);
    return results;
  }
}

// Usage
async function main() {
  const flow = await createAdvancedWorkflow();
  const processor = new OrderProcessor(flow.id);

  const sampleOrder = {
    id: 'order_123',
    customer_id: 'cust_456',
    customer_email: 'customer@example.com',
    amount: 99.99,
    currency: 'USD',
    items: [
      { sku: 'ITEM-001', quantity: 2 },
      { sku: 'ITEM-002', quantity: 1 }
    ]
  };

  await processor.processOrder(sampleOrder);
}

main().catch(console.error);
```
</CodeGroup>

### Real-time Event Processing

A workflow that processes real-time events from webhooks or streams.

<CodeGroup>
```typescript Node.js/TypeScript
import { Client } from '@tolstoy/sdk';
import express from 'express';

const client = new Client({
  apiKey: process.env.TOLSTOY_API_KEY!
});

class EventProcessor {
  private flowId: string;
  private app: express.Application;

  constructor(flowId: string) {
    this.flowId = flowId;
    this.app = express();
    this.setupMiddleware();
    this.setupRoutes();
  }

  private setupMiddleware() {
    this.app.use(express.json());
    this.app.use(express.raw({ type: 'application/webhook+json' }));
  }

  private setupRoutes() {
    // GitHub webhook endpoint
    this.app.post('/webhooks/github', async (req, res) => {
      const signature = req.headers['x-hub-signature-256'] as string;
      
      // Verify webhook signature
      if (!this.verifyGitHubSignature(req.body, signature)) {
        return res.status(401).send('Invalid signature');
      }

      const event = req.body;
      await this.processGitHubEvent(event);
      res.status(200).send('OK');
    });

    // Stripe webhook endpoint
    this.app.post('/webhooks/stripe', async (req, res) => {
      const signature = req.headers['stripe-signature'] as string;
      
      try {
        // Process Stripe event
        await this.processStripeEvent(req.body, signature);
        res.status(200).send('OK');
      } catch (error) {
        console.error('Stripe webhook error:', error);
        res.status(400).send('Webhook error');
      }
    });

    // Generic event endpoint
    this.app.post('/events', async (req, res) => {
      await this.processGenericEvent(req.body);
      res.status(200).send('OK');
    });
  }

  private async processGitHubEvent(event: any) {
    const execution = await client.flows.execute(this.flowId, {
      inputs: {
        source: 'github',
        event_type: event.action,
        repository: event.repository?.name,
        branch: event.ref?.replace('refs/heads/', ''),
        author: event.pusher?.name || event.sender?.login,
        commits: event.commits || [],
        timestamp: new Date().toISOString()
      }
    });

    console.log(`GitHub event processed: ${execution.id}`);
  }

  private async processStripeEvent(event: any, signature: string) {
    // Verify Stripe signature here
    
    const execution = await client.flows.execute(this.flowId, {
      inputs: {
        source: 'stripe',
        event_type: event.type,
        customer_id: event.data?.object?.customer,
        amount: event.data?.object?.amount,
        currency: event.data?.object?.currency,
        status: event.data?.object?.status,
        timestamp: new Date().toISOString()
      }
    });

    console.log(`Stripe event processed: ${execution.id}`);
  }

  private async processGenericEvent(eventData: any) {
    const execution = await client.flows.execute(this.flowId, {
      inputs: {
        source: 'generic',
        ...eventData,
        timestamp: new Date().toISOString()
      }
    });

    console.log(`Generic event processed: ${execution.id}`);
  }

  private verifyGitHubSignature(payload: Buffer, signature: string): boolean {
    // Implement GitHub signature verification
    // This is a simplified example
    return true;
  }

  public start(port: number = 3000) {
    this.app.listen(port, () => {
      console.log(`Event processor listening on port ${port}`);
    });
  }
}

async function createEventProcessingFlow() {
  const flow = await client.flows.create({
    name: 'Real-time Event Processing Flow',
    description: 'Processes events from various sources in real-time',
    steps: [
      // Step 1: Route event based on source
      {
        key: 'route_event',
        action: 'evaluate',
        inputs: {
          source: '{{inputs.source}}',
          event_type: '{{inputs.event_type}}'
        }
      },
      
      // Step 2a: Process GitHub events
      {
        key: 'process_github_event',
        action: 'transform',
        condition: '{{inputs.source}} === "github"',
        inputs: {
          data: '{{inputs}}',
          operations: [
            {
              type: 'map',
              expression: `{
                type: "code_push",
                repository: repository,
                branch: branch,
                author: author,
                commit_count: commits.length,
                message: "New commits pushed to " + repository + " on " + branch
              }`
            }
          ]
        }
      },
      
      // Step 2b: Process Stripe events
      {
        key: 'process_stripe_event',
        action: 'transform',
        condition: '{{inputs.source}} === "stripe"',
        inputs: {
          data: '{{inputs}}',
          operations: [
            {
              type: 'map',
              expression: `{
                type: "payment_event",
                customer: customer_id,
                amount_formatted: (amount / 100).toFixed(2) + " " + currency.toUpperCase(),
                status: status,
                message: "Payment " + status + " for " + (amount / 100).toFixed(2) + " " + currency.toUpperCase()
              }`
            }
          ]
        }
      },
      
      // Step 3: Send notification based on event type
      {
        key: 'send_notification',
        action: 'slack',
        inputs: {
          channel: '#events',
          message: `
            ðŸ“¡ **{{inputs.source}} Event**
            Type: {{inputs.event_type}}
            Message: {{steps.process_github_event.outputs.result.message || steps.process_stripe_event.outputs.result.message}}
            Time: {{inputs.timestamp}}
          `
        }
      },
      
      // Step 4: Store event for analytics
      {
        key: 'store_event',
        action: 'database',
        inputs: {
          operation: 'insert',
          table: 'events',
          data: {
            source: '{{inputs.source}}',
            event_type: '{{inputs.event_type}}',
            processed_data: '{{steps.process_github_event.outputs.result || steps.process_stripe_event.outputs.result}}',
            raw_data: '{{inputs}}',
            processed_at: '{{inputs.timestamp}}'
          }
        }
      }
    ]
  });

  return flow;
}

// Usage
async function main() {
  const flow = await createEventProcessingFlow();
  const processor = new EventProcessor(flow.id);
  processor.start(3000);
}

main().catch(console.error);
```
</CodeGroup>

## Integration Examples

### Multi-Service Integration

Example showing how to integrate multiple services in a single workflow.

<CodeGroup>
```typescript Node.js/TypeScript
async function createMultiServiceIntegration() {
  return await client.flows.create({
    name: 'Multi-Service Customer Onboarding',
    description: 'Comprehensive customer onboarding across multiple services',
    steps: [
      // CRM Integration
      {
        key: 'create_crm_contact',
        action: 'http_request',
        inputs: {
          url: 'https://api.hubspot.com/crm/v3/objects/contacts',
          method: 'POST',
          headers: {
            'Authorization': 'Bearer {{secrets.hubspot_token}}',
            'Content-Type': 'application/json'
          },
          body: {
            properties: {
              firstname: '{{inputs.customer.first_name}}',
              lastname: '{{inputs.customer.last_name}}',
              email: '{{inputs.customer.email}}',
              phone: '{{inputs.customer.phone}}'
            }
          }
        }
      },
      
      // Email Marketing Platform
      {
        key: 'add_to_mailchimp',
        action: 'http_request',
        inputs: {
          url: 'https://us1.api.mailchimp.com/3.0/lists/{{secrets.mailchimp_list_id}}/members',
          method: 'POST',
          headers: {
            'Authorization': 'apikey {{secrets.mailchimp_api_key}}'
          },
          body: {
            email_address: '{{inputs.customer.email}}',
            status: 'subscribed',
            merge_fields: {
              FNAME: '{{inputs.customer.first_name}}',
              LNAME: '{{inputs.customer.last_name}}'
            }
          }
        }
      },
      
      // Slack Notification
      {
        key: 'notify_sales_team',
        action: 'slack',
        inputs: {
          channel: '#sales',
          message: `
            ðŸŽ‰ New customer signed up!
            â€¢ Name: {{inputs.customer.first_name}} {{inputs.customer.last_name}}
            â€¢ Email: {{inputs.customer.email}}
            â€¢ CRM ID: {{steps.create_crm_contact.outputs.body.id}}
            â€¢ Source: {{inputs.customer.source}}
          `
        }
      },
      
      // Google Sheets Logging
      {
        key: 'log_to_sheets',
        action: 'google_sheets',
        inputs: {
          spreadsheet_id: '{{secrets.tracking_sheet_id}}',
          range: 'Signups!A:F',
          values: [[
            '{{inputs.customer.first_name}}',
            '{{inputs.customer.last_name}}',
            '{{inputs.customer.email}}',
            '{{inputs.customer.source}}',
            '{{steps.create_crm_contact.outputs.body.id}}',
            '{{Date.now()}}'
          ]]
        }
      },
      
      // Welcome Email
      {
        key: 'send_welcome_email',
        action: 'email',
        inputs: {
          to: '{{inputs.customer.email}}',
          subject: 'Welcome to Our Platform! ðŸš€',
          template: 'welcome_email',
          data: {
            first_name: '{{inputs.customer.first_name}}',
            onboarding_link: 'https://app.example.com/onboard'
          }
        }
      }
    ]
  });
}
```
</CodeGroup>

These examples demonstrate the power and flexibility of Tolstoy SDKs for building complex automation workflows. Each example includes proper error handling, monitoring, and best practices for production use.

## Next Steps

<CardGroup cols={2}>
  <Card title="API Reference" icon="book" href="/api-reference/authentication">
    Explore detailed API documentation
  </Card>
  <Card title="SDK Installation" icon="download" href="/sdk/installation">
    Get started with SDK installation
  </Card>
  <Card title="Best Practices" icon="star" href="/best-practices">
    Learn workflow design best practices
  </Card>
  <Card title="Troubleshooting" icon="wrench" href="/troubleshooting">
    Common issues and solutions
  </Card>
</CardGroup>