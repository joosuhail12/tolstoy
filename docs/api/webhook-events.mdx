---
title: "Webhook Events"
description: "Complete reference for all webhook events sent by the Tolstoy API"
---

# Webhook Events

Webhooks allow your application to receive real-time notifications when events occur in your Tolstoy organization. This reference covers all available webhook events and their payloads.

## Event Structure

All webhook events follow a consistent structure:

```json
{
  "event": {
    "id": "evt_123456789",
    "type": "flow.completed",
    "created_at": "2024-01-15T10:30:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": { /* Event-specific data */ },
    "previous_attributes": { /* For update events */ }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

### **Event Headers**

Webhook requests include these headers:

| Header | Description | Example |
|--------|-------------|---------|
| `Content-Type` | Always application/json | `application/json` |
| `User-Agent` | Tolstoy webhook identifier | `Tolstoy-Webhooks/2.1.0` |
| `X-Tolstoy-Event` | Event type | `flow.completed` |
| `X-Tolstoy-Signature` | HMAC signature for verification | `sha256=abc123...` |
| `X-Tolstoy-Delivery` | Unique delivery ID | `delivery_xyz789` |

## Flow Events

### **flow.created**

Triggered when a new flow is created.

<CodeGroup>

```json Flow Created Event
{
  "event": {
    "id": "evt_flow_created_123",
    "type": "flow.created",
    "created_at": "2024-01-15T10:30:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "flow_new123456",
      "name": "customer_onboarding",
      "display_name": "Customer Onboarding Flow",
      "description": "Automated customer onboarding workflow",
      "status": "active",
      "trigger": {
        "type": "webhook",
        "config": {
          "endpoint": "/customer-signup"
        }
      },
      "steps": [
        {
          "id": "step_1",
          "name": "send_welcome_email",
          "action_id": "action_welcome_email",
          "type": "action"
        }
      ],
      "created_by": {
        "id": "user_123456789",
        "email": "admin@acme.com"
      },
      "created_at": "2024-01-15T10:30:00Z"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

---

### **flow.updated**

Triggered when a flow is modified.

<CodeGroup>

```json Flow Updated Event
{
  "event": {
    "id": "evt_flow_updated_456",
    "type": "flow.updated",
    "created_at": "2024-01-15T10:35:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "flow_123456789",
      "name": "customer_onboarding",
      "display_name": "Enhanced Customer Onboarding",
      "description": "Automated customer onboarding with personalization",
      "status": "active",
      "updated_by": {
        "id": "user_987654321",
        "email": "developer@acme.com"
      },
      "updated_at": "2024-01-15T10:35:00Z"
    },
    "previous_attributes": {
      "display_name": "Customer Onboarding Flow",
      "description": "Automated customer onboarding workflow"
    }
  },
  "organization": {
    "id": "org_123456789", 
    "name": "acme-corp"
  }
}
```

</CodeGroup>

---

### **flow.deleted**

Triggered when a flow is deleted.

<CodeGroup>

```json Flow Deleted Event
{
  "event": {
    "id": "evt_flow_deleted_789",
    "type": "flow.deleted",
    "created_at": "2024-01-15T10:40:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "flow_deleted123",
      "name": "old_workflow",
      "display_name": "Old Workflow",
      "status": "deleted",
      "deleted_by": {
        "id": "user_123456789",
        "email": "admin@acme.com"
      },
      "deleted_at": "2024-01-15T10:40:00Z"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

## Execution Events

### **execution.started**

Triggered when a flow execution begins.

<CodeGroup>

```json Execution Started Event
{
  "event": {
    "id": "evt_exec_started_123",
    "type": "execution.started",
    "created_at": "2024-01-15T10:30:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "exec_abc123xyz789",
      "flow_id": "flow_123456789",
      "flow_name": "customer_onboarding",
      "status": "running",
      "trigger": {
        "type": "webhook",
        "source": "customer_signup_form",
        "webhook_id": "webhook_456789123"
      },
      "inputs": {
        "customer_email": "john@example.com",
        "signup_source": "website",
        "plan": "professional"
      },
      "context": {
        "user_agent": "Mozilla/5.0...",
        "ip_address": "192.168.1.100",
        "referrer": "https://acme.com/pricing"
      },
      "started_at": "2024-01-15T10:30:00Z",
      "estimated_duration_ms": 5000
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

---

### **execution.completed**

Triggered when a flow execution completes successfully.

<CodeGroup>

```json Execution Completed Event
{
  "event": {
    "id": "evt_exec_completed_456",
    "type": "execution.completed", 
    "created_at": "2024-01-15T10:35:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "exec_abc123xyz789",
      "flow_id": "flow_123456789",
      "flow_name": "customer_onboarding",
      "status": "success",
      "started_at": "2024-01-15T10:30:00Z",
      "completed_at": "2024-01-15T10:35:00Z",
      "duration_ms": 4520,
      "steps": [
        {
          "step_id": "step_1",
          "step_name": "send_welcome_email",
          "status": "success",
          "duration_ms": 1200,
          "outputs": {
            "email_id": "email_sent_123",
            "delivery_status": "delivered"
          }
        },
        {
          "step_id": "step_2", 
          "step_name": "create_user_profile",
          "status": "success",
          "duration_ms": 800,
          "outputs": {
            "profile_id": "profile_new456",
            "setup_complete": true
          }
        }
      ],
      "outputs": {
        "onboarding_status": "completed",
        "user_profile_id": "profile_new456",
        "welcome_email_sent": true
      },
      "metrics": {
        "total_api_calls": 3,
        "external_requests": 2,
        "cache_hits": 1
      }
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

---

### **execution.failed**

Triggered when a flow execution fails.

<CodeGroup>

```json Execution Failed Event
{
  "event": {
    "id": "evt_exec_failed_789",
    "type": "execution.failed",
    "created_at": "2024-01-15T10:32:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "exec_failed123xyz",
      "flow_id": "flow_123456789",
      "flow_name": "customer_onboarding",
      "status": "failed",
      "started_at": "2024-01-15T10:30:00Z",
      "failed_at": "2024-01-15T10:32:00Z",
      "duration_ms": 120000,
      "error": {
        "code": "EXECUTION_FAILED",
        "message": "Step 'send_welcome_email' failed",
        "details": "External email service returned 500 error",
        "step_id": "step_1",
        "step_name": "send_welcome_email",
        "retry_attempts": 3
      },
      "steps": [
        {
          "step_id": "step_1",
          "step_name": "send_welcome_email", 
          "status": "failed",
          "duration_ms": 120000,
          "error": {
            "message": "Email service timeout",
            "external_status": 500,
            "retry_attempts": 3
          }
        }
      ],
      "retry_recommended": true,
      "next_retry_at": "2024-01-15T10:40:00Z"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

---

### **execution.timeout**

Triggered when a flow execution times out.

<CodeGroup>

```json Execution Timeout Event
{
  "event": {
    "id": "evt_exec_timeout_321",
    "type": "execution.timeout",
    "created_at": "2024-01-15T10:35:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "exec_timeout123",
      "flow_id": "flow_987654321",
      "flow_name": "data_processing",
      "status": "timeout",
      "started_at": "2024-01-15T10:30:00Z",
      "timeout_at": "2024-01-15T10:35:00Z",
      "duration_ms": 300000,
      "timeout_seconds": 300,
      "current_step": {
        "step_id": "step_3",
        "step_name": "process_large_dataset",
        "elapsed_ms": 280000
      },
      "completed_steps": ["step_1", "step_2"],
      "suggestion": "Consider breaking large operations into smaller chunks"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

## Action Events

### **action.created**

Triggered when a new action is created.

<CodeGroup>

```json Action Created Event
{
  "event": {
    "id": "evt_action_created_123",
    "type": "action.created",
    "created_at": "2024-01-15T10:30:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "action_new123456",
      "name": "send_slack_notification",
      "display_name": "Send Slack Notification",
      "type": "http",
      "configuration": {
        "endpoint": {
          "url": "https://hooks.slack.com/services/...",
          "method": "POST"
        },
        "inputs": [
          {
            "name": "message",
            "type": "string",
            "required": true
          }
        ]
      },
      "tags": ["notification", "slack"],
      "created_by": {
        "id": "user_123456789",
        "email": "developer@acme.com"
      },
      "created_at": "2024-01-15T10:30:00Z"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

---

### **action.executed**

Triggered when an action is executed (either standalone or as part of a flow).

<CodeGroup>

```json Action Executed Event
{
  "event": {
    "id": "evt_action_executed_456",
    "type": "action.executed",
    "created_at": "2024-01-15T10:35:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "execution_id": "exec_action123",
      "action_id": "action_123456789",
      "action_name": "send_slack_notification",
      "status": "success",
      "inputs": {
        "message": "Customer john@example.com completed onboarding",
        "channel": "#customer-success"
      },
      "outputs": {
        "message_id": "slack_msg_456789",
        "delivery_status": "delivered",
        "timestamp": "2024-01-15T10:35:00Z"
      },
      "duration_ms": 850,
      "context": {
        "flow_execution_id": "exec_flow_abc123",
        "step_id": "step_2",
        "triggered_by": "flow"
      },
      "started_at": "2024-01-15T10:34:59Z",
      "completed_at": "2024-01-15T10:35:00Z"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

## User Events

### **user.created**

Triggered when a new user is added to the organization.

<CodeGroup>

```json User Created Event
{
  "event": {
    "id": "evt_user_created_123",
    "type": "user.created",
    "created_at": "2024-01-15T10:30:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "user_new123456",
      "email": "newuser@acme.com",
      "name": "Jane Developer",
      "role": "developer",
      "status": "active",
      "permissions": ["read", "write"],
      "invited_by": {
        "id": "user_admin123",
        "email": "admin@acme.com"
      },
      "invitation": {
        "sent_at": "2024-01-15T10:25:00Z",
        "accepted_at": "2024-01-15T10:30:00Z",
        "expires_at": "2024-01-22T10:25:00Z"
      },
      "created_at": "2024-01-15T10:30:00Z"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

---

### **user.role_changed**

Triggered when a user's role or permissions change.

<CodeGroup>

```json User Role Changed Event
{
  "event": {
    "id": "evt_user_role_changed_456",
    "type": "user.role_changed",
    "created_at": "2024-01-15T10:45:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "user_123456789",
      "email": "developer@acme.com",
      "name": "Jane Developer",
      "role": "admin",
      "permissions": ["read", "write", "delete", "admin"],
      "changed_by": {
        "id": "user_admin123",
        "email": "admin@acme.com"
      },
      "updated_at": "2024-01-15T10:45:00Z"
    },
    "previous_attributes": {
      "role": "developer",
      "permissions": ["read", "write"]
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

## Organization Events

### **organization.updated**

Triggered when organization settings are modified.

<CodeGroup>

```json Organization Updated Event
{
  "event": {
    "id": "evt_org_updated_123",
    "type": "organization.updated",
    "created_at": "2024-01-15T10:30:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "org_123456789",
      "name": "acme-corp",
      "display_name": "Acme Corporation",
      "settings": {
        "timezone": "America/New_York",
        "rate_limits": {
          "api_requests_per_minute": 5000,
          "executions_per_hour": 2000
        }
      },
      "updated_by": {
        "id": "user_admin123",
        "email": "admin@acme.com"
      },
      "updated_at": "2024-01-15T10:30:00Z"
    },
    "previous_attributes": {
      "settings": {
        "rate_limits": {
          "api_requests_per_minute": 2000,
          "executions_per_hour": 1000
        }
      }
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

---

### **organization.plan_changed**

Triggered when organization subscription plan changes.

<CodeGroup>

```json Plan Changed Event
{
  "event": {
    "id": "evt_plan_changed_456",
    "type": "organization.plan_changed",
    "created_at": "2024-01-15T10:30:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "org_123456789",
      "plan": "professional",
      "billing": {
        "subscription_status": "active",
        "current_period_start": "2024-01-15T10:30:00Z",
        "current_period_end": "2024-02-15T10:30:00Z",
        "amount": 99.00,
        "currency": "USD"
      },
      "features_enabled": [
        "advanced_analytics",
        "priority_support", 
        "custom_rate_limits"
      ],
      "changed_by": {
        "id": "user_admin123",
        "email": "admin@acme.com"
      }
    },
    "previous_attributes": {
      "plan": "starter",
      "features_enabled": ["basic_analytics"]
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

## API Key Events

### **api_key.created**

Triggered when a new API key is generated.

<CodeGroup>

```json API Key Created Event
{
  "event": {
    "id": "evt_key_created_123",
    "type": "api_key.created",
    "created_at": "2024-01-15T10:30:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "key_new123456",
      "name": "Production API Key",
      "key_prefix": "sk_live_abc123...",
      "permissions": ["read", "write", "execute"],
      "restrictions": {
        "ip_whitelist": ["192.168.1.0/24"],
        "environment": "production"
      },
      "expires_at": "2025-01-15T10:30:00Z",
      "created_by": {
        "id": "user_admin123",
        "email": "admin@acme.com"
      },
      "created_at": "2024-01-15T10:30:00Z"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

---

### **api_key.revoked**

Triggered when an API key is revoked.

<CodeGroup>

```json API Key Revoked Event
{
  "event": {
    "id": "evt_key_revoked_456",
    "type": "api_key.revoked",
    "created_at": "2024-01-15T10:45:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "key_revoked123",
      "name": "Compromised Key",
      "key_prefix": "sk_live_xyz789...",
      "status": "revoked",
      "revoked_reason": "security_breach",
      "revoked_by": {
        "id": "user_admin123",
        "email": "admin@acme.com"
      },
      "revoked_at": "2024-01-15T10:45:00Z",
      "last_used_at": "2024-01-15T10:40:00Z",
      "usage_stats": {
        "total_requests": 15420,
        "last_30_days": 1200
      }
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

## System Events

### **system.maintenance_started**

Triggered when system maintenance begins.

<CodeGroup>

```json Maintenance Started Event
{
  "event": {
    "id": "evt_maintenance_start_123",
    "type": "system.maintenance_started",
    "created_at": "2024-01-15T10:00:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "maintenance_id": "maint_2024_01_15",
      "type": "scheduled",
      "description": "Database performance optimization",
      "impact": "partial",
      "affected_services": ["executions", "webhooks"],
      "unaffected_services": ["api_read_operations"],
      "scheduled_start": "2024-01-15T10:00:00Z",
      "estimated_end": "2024-01-15T11:00:00Z",
      "status_page": "https://status.tolstoy.dev/maintenance/maint_2024_01_15"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

---

### **system.maintenance_completed**

Triggered when system maintenance is complete.

<CodeGroup>

```json Maintenance Completed Event
{
  "event": {
    "id": "evt_maintenance_end_456",
    "type": "system.maintenance_completed",
    "created_at": "2024-01-15T10:45:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "maintenance_id": "maint_2024_01_15",
      "type": "scheduled",
      "description": "Database performance optimization",
      "scheduled_start": "2024-01-15T10:00:00Z",
      "actual_start": "2024-01-15T10:00:00Z",
      "estimated_end": "2024-01-15T11:00:00Z",
      "actual_end": "2024-01-15T10:45:00Z",
      "duration_minutes": 45,
      "status": "completed",
      "improvements": [
        "25% faster query performance",
        "Reduced webhook latency",
        "Enhanced error handling"
      ]
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

## Webhook Events

### **webhook.delivery_failed**

Triggered when webhook delivery fails.

<CodeGroup>

```json Webhook Delivery Failed Event
{
  "event": {
    "id": "evt_webhook_failed_123",
    "type": "webhook.delivery_failed",
    "created_at": "2024-01-15T10:30:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "webhook_id": "webhook_123456789",
      "delivery_id": "delivery_failed123",
      "endpoint": "https://your-app.com/webhooks/tolstoy",
      "event_type": "flow.completed",
      "original_event_id": "evt_flow_completed_789",
      "attempt_number": 3,
      "max_attempts": 5,
      "error": {
        "code": "WEBHOOK_DELIVERY_FAILED",
        "message": "Webhook endpoint returned 500 error",
        "http_status": 500,
        "response_body": "Internal server error",
        "timeout": false
      },
      "next_retry_at": "2024-01-15T10:35:00Z",
      "backoff_seconds": 300,
      "failed_at": "2024-01-15T10:30:00Z"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

---

### **webhook.max_retries_exceeded**

Triggered when webhook delivery fails after all retry attempts.

<CodeGroup>

```json Max Retries Exceeded Event
{
  "event": {
    "id": "evt_webhook_max_retries_456",
    "type": "webhook.max_retries_exceeded",
    "created_at": "2024-01-15T11:30:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "webhook_id": "webhook_123456789",
      "delivery_id": "delivery_exhausted123",
      "endpoint": "https://your-app.com/webhooks/tolstoy",
      "event_type": "flow.completed",
      "original_event_id": "evt_flow_completed_789",
      "total_attempts": 5,
      "max_attempts": 5,
      "first_attempt": "2024-01-15T10:30:00Z",
      "last_attempt": "2024-01-15T11:30:00Z",
      "final_error": {
        "code": "WEBHOOK_TIMEOUT",
        "message": "Endpoint timeout after 30 seconds",
        "http_status": null,
        "timeout": true
      },
      "status": "permanently_failed",
      "action_required": "Check webhook endpoint health and configuration"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

## Tool Events

### **tool.connected**

Triggered when a new tool integration is established.

<CodeGroup>

```json Tool Connected Event
{
  "event": {
    "id": "evt_tool_connected_123",
    "type": "tool.connected",
    "created_at": "2024-01-15T10:30:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "tool_slack_123456",
      "name": "Slack Integration",
      "type": "slack",
      "category": "communication",
      "configuration": {
        "workspace": "acme-corp.slack.com",
        "bot_user_id": "B01234567",
        "scopes": ["chat:write", "channels:read"]
      },
      "health_status": "healthy",
      "connected_by": {
        "id": "user_admin123",
        "email": "admin@acme.com"
      },
      "connected_at": "2024-01-15T10:30:00Z"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

---

### **tool.health_check_failed**

Triggered when a tool integration health check fails.

<CodeGroup>

```json Tool Health Check Failed Event
{
  "event": {
    "id": "evt_tool_health_failed_456",
    "type": "tool.health_check_failed",
    "created_at": "2024-01-15T10:30:00Z",
    "api_version": "2024-01-15"
  },
  "data": {
    "object": {
      "id": "tool_database_789",
      "name": "Customer Database",
      "type": "database",
      "health_status": "unhealthy",
      "error": {
        "code": "CONNECTION_FAILED",
        "message": "Unable to connect to database",
        "details": "Connection timeout after 30 seconds",
        "last_successful_check": "2024-01-15T09:30:00Z"
      },
      "impact": {
        "affected_actions": 15,
        "affected_flows": 8,
        "severity": "high"
      },
      "check_interval_seconds": 300,
      "next_check_at": "2024-01-15T10:35:00Z"
    }
  },
  "organization": {
    "id": "org_123456789",
    "name": "acme-corp"
  }
}
```

</CodeGroup>

## Event Filtering

### **Webhook Configuration**

Configure which events to receive:

<CodeGroup>

```json Webhook Event Subscription
{
  "webhook": {
    "url": "https://your-app.com/webhooks/tolstoy",
    "events": [
      "flow.completed",
      "flow.failed", 
      "execution.failed",
      "user.created",
      "organization.plan_changed"
    ],
    "filters": {
      "flow_tags": ["production", "critical"],
      "user_roles": ["admin", "developer"],
      "error_severity": ["high", "critical"]
    },
    "signature": {
      "algorithm": "sha256",
      "header": "X-Tolstoy-Signature"
    }
  }
}
```

</CodeGroup>

### **Event Pattern Matching**

<CodeGroup>

```javascript Event Router
class WebhookEventRouter {
  constructor() {
    this.handlers = new Map();
  }
  
  on(eventPattern, handler) {
    this.handlers.set(eventPattern, handler);
  }
  
  async route(webhookPayload) {
    const eventType = webhookPayload.event.type;
    const eventData = webhookPayload.data.object;
    
    // Try exact match first
    if (this.handlers.has(eventType)) {
      await this.handlers.get(eventType)(eventData, webhookPayload);
      return;
    }
    
    // Try pattern matching
    for (const [pattern, handler] of this.handlers.entries()) {
      if (this.matchesPattern(eventType, pattern)) {
        await handler(eventData, webhookPayload);
        return;
      }
    }
    
    console.warn(`No handler for event type: ${eventType}`);
  }
  
  matchesPattern(eventType, pattern) {
    // Support wildcards: flow.* matches flow.created, flow.updated, etc.
    const regex = new RegExp(pattern.replace('*', '.*'));
    return regex.test(eventType);
  }
}

// Usage
const router = new WebhookEventRouter();

// Handle all flow events
router.on('flow.*', async (flow, webhook) => {
  console.log(`Flow event: ${webhook.event.type} for ${flow.name}`);
  await updateFlowDashboard(flow);
});

// Handle specific execution events
router.on('execution.failed', async (execution, webhook) => {
  console.error(`Execution failed: ${execution.id}`);
  await alertOnCallTeam(execution);
});

// Handle user events
router.on('user.created', async (user, webhook) => {
  console.log(`New user joined: ${user.email}`);
  await sendWelcomeEmail(user);
});

// Handle organization events
router.on('organization.plan_changed', async (org, webhook) => {
  console.log(`Plan changed to: ${org.plan}`);
  await updateBillingDashboard(org);
});

// Process incoming webhook
app.post('/webhooks/tolstoy', async (req, res) => {
  try {
    await router.route(req.body);
    res.json({ received: true });
  } catch (error) {
    console.error('Webhook processing failed:', error);
    res.status(500).json({ error: error.message });
  }
});
```

</CodeGroup>

## Event Verification

### **Signature Verification**

<CodeGroup>

```javascript Verify Webhook Signature
const crypto = require('crypto');

function verifyWebhookSignature(payload, signature, secret) {
  // Calculate expected signature
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload, 'utf8')
    .digest('hex');
  
  // Extract signature from header (format: "sha256=abc123...")
  const providedSignature = signature.replace('sha256=', '');
  
  // Timing-safe comparison
  return crypto.timingSafeEqual(
    Buffer.from(expectedSignature, 'hex'),
    Buffer.from(providedSignature, 'hex')
  );
}

// Express middleware
function webhookSignatureMiddleware(secret) {
  return (req, res, next) => {
    const signature = req.headers['x-tolstoy-signature'];
    const payload = JSON.stringify(req.body);
    
    if (!signature) {
      return res.status(401).json({ 
        error: 'Missing X-Tolstoy-Signature header' 
      });
    }
    
    if (!verifyWebhookSignature(payload, signature, secret)) {
      return res.status(401).json({ 
        error: 'Invalid webhook signature' 
      });
    }
    
    next();
  };
}

// Usage
app.use('/webhooks/tolstoy', 
  express.raw({ type: 'application/json' }),
  webhookSignatureMiddleware(process.env.TOLSTOY_WEBHOOK_SECRET),
  (req, res) => {
    const event = JSON.parse(req.body);
    console.log('Verified webhook event:', event.event.type);
    res.json({ received: true });
  }
);
```

</CodeGroup>

## Event Processing Examples

### **Flow Completion Handler**

<CodeGroup>

```javascript Flow Completion Processing
async function handleFlowCompletion(event) {
  const execution = event.data.object;
  const flowName = execution.flow_name;
  
  console.log(`‚úÖ Flow "${flowName}" completed in ${execution.duration_ms}ms`);
  
  // Update metrics
  await updateExecutionMetrics({
    flowId: execution.flow_id,
    duration: execution.duration_ms,
    status: 'success',
    stepCount: execution.steps.length
  });
  
  // Send notifications based on flow type
  switch (flowName) {
    case 'customer_onboarding':
      await notifyCustomerSuccess({
        customerId: execution.outputs.customer_id,
        onboardingComplete: true
      });
      break;
      
    case 'order_processing':
      await notifyFulfillment({
        orderId: execution.outputs.order_id,
        status: 'processed'
      });
      break;
      
    case 'data_backup':
      await notifyOpsTeam({
        backupId: execution.outputs.backup_id,
        size: execution.outputs.backup_size_mb
      });
      break;
  }
  
  // Update dashboard
  await updateRealTimeDashboard({
    type: 'execution_completed',
    flowName,
    duration: execution.duration_ms,
    timestamp: execution.completed_at
  });
}
```

</CodeGroup>

### **Error Alerting System**

<CodeGroup>

```javascript Error Alert System
class ErrorAlertSystem {
  constructor() {
    this.alertThresholds = {
      'execution.failed': { count: 5, window: 300 }, // 5 failures in 5 minutes
      'webhook.delivery_failed': { count: 3, window: 180 },
      'tool.health_check_failed': { count: 1, window: 0 } // Immediate alert
    };
    
    this.recentEvents = [];
  }
  
  async processEvent(event) {
    const eventType = event.event.type;
    
    // Record event
    this.recentEvents.push({
      type: eventType,
      timestamp: new Date(event.event.created_at),
      data: event.data.object
    });
    
    // Clean old events
    this.cleanupOldEvents();
    
    // Check alert thresholds
    if (this.shouldAlert(eventType)) {
      await this.sendAlert(eventType, event);
    }
  }
  
  shouldAlert(eventType) {
    const threshold = this.alertThresholds[eventType];
    if (!threshold) return false;
    
    const cutoff = new Date(Date.now() - threshold.window * 1000);
    const recentEvents = this.recentEvents.filter(e => 
      e.type === eventType && e.timestamp > cutoff
    );
    
    return recentEvents.length >= threshold.count;
  }
  
  async sendAlert(eventType, event) {
    const severity = this.getAlertSeverity(eventType);
    const message = this.formatAlertMessage(eventType, event);
    
    // Send to multiple channels
    await Promise.all([
      this.sendSlackAlert(message, severity),
      this.sendEmailAlert(message, severity),
      this.createIncident(eventType, event)
    ]);
  }
  
  getAlertSeverity(eventType) {
    const severityMap = {
      'execution.failed': 'medium',
      'webhook.delivery_failed': 'low',
      'tool.health_check_failed': 'high',
      'system.maintenance_started': 'info'
    };
    
    return severityMap[eventType] || 'medium';
  }
  
  formatAlertMessage(eventType, event) {
    switch (eventType) {
      case 'execution.failed':
        return `üö® Flow execution failed: ${event.data.object.flow_name} (${event.data.object.error.message})`;
      case 'webhook.delivery_failed':
        return `‚ö†Ô∏è Webhook delivery failed: ${event.data.object.endpoint} (attempt ${event.data.object.attempt_number})`;
      case 'tool.health_check_failed':
        return `üí• Tool health check failed: ${event.data.object.name} (${event.data.object.error.message})`;
      default:
        return `Event: ${eventType}`;
    }
  }
}

// Usage
const alertSystem = new ErrorAlertSystem();

app.post('/webhooks/tolstoy', async (req, res) => {
  try {
    await alertSystem.processEvent(req.body);
    res.json({ received: true });
  } catch (error) {
    console.error('Alert processing failed:', error);
    res.status(200).json({ received: true, processing_error: true });
  }
});
```

</CodeGroup>

## Event Replay

### **Missed Event Recovery**

<CodeGroup>

```javascript Event Replay System
class EventReplayManager {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.tolstoy.dev';
  }
  
  async replayEvents(webhookId, fromTimestamp, toTimestamp = null) {
    const params = new URLSearchParams({
      webhook_id: webhookId,
      from: fromTimestamp,
      limit: '100'
    });
    
    if (toTimestamp) {
      params.set('to', toTimestamp);
    }
    
    const response = await fetch(`${this.baseUrl}/webhooks/events?${params}`, {
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    const data = await response.json();
    
    console.log(`Found ${data.events.length} events to replay`);
    
    // Replay events to your endpoint
    for (const event of data.events) {
      await this.redeliverEvent(event);
    }
  }
  
  async redeliverEvent(event) {
    try {
      const response = await fetch('https://your-app.com/webhooks/tolstoy', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Tolstoy-Event': event.event.type,
          'X-Tolstoy-Delivery': `replay_${Date.now()}`,
          'X-Tolstoy-Original-Delivery': event.original_delivery_id
        },
        body: JSON.stringify(event)
      });
      
      if (response.ok) {
        console.log(`‚úÖ Replayed event: ${event.event.id}`);
      } else {
        console.error(`‚ùå Replay failed for event: ${event.event.id}`);
      }
    } catch (error) {
      console.error(`üí• Replay error for event ${event.event.id}:`, error.message);
    }
  }
}

// Usage: Replay missed events from last hour
const replayManager = new EventReplayManager(apiKey);
const oneHourAgo = new Date(Date.now() - 3600000).toISOString();

await replayManager.replayEvents('webhook_123456789', oneHourAgo);
```

</CodeGroup>

## Event Analytics

### **Event Metrics Dashboard**

<CodeGroup>

```javascript Event Analytics
class WebhookAnalytics {
  constructor() {
    this.events = [];
    this.metrics = {
      totalEvents: 0,
      eventsByType: new Map(),
      eventsByHour: new Map(),
      processingTimes: [],
      errorCounts: new Map()
    };
  }
  
  recordEvent(event, processingTime = 0, error = null) {
    this.events.push({
      id: event.event.id,
      type: event.event.type,
      timestamp: new Date(event.event.created_at),
      processingTime,
      error
    });
    
    this.updateMetrics(event, processingTime, error);
  }
  
  updateMetrics(event, processingTime, error) {
    this.metrics.totalEvents++;
    
    // Count by type
    const type = event.event.type;
    this.metrics.eventsByType.set(type, (this.metrics.eventsByType.get(type) || 0) + 1);
    
    // Count by hour
    const hour = new Date(event.event.created_at).toISOString().slice(0, 13);
    this.metrics.eventsByHour.set(hour, (this.metrics.eventsByHour.get(hour) || 0) + 1);
    
    // Processing time
    if (processingTime > 0) {
      this.metrics.processingTimes.push(processingTime);
    }
    
    // Error tracking
    if (error) {
      this.metrics.errorCounts.set(type, (this.metrics.errorCounts.get(type) || 0) + 1);
    }
  }
  
  getReport() {
    const avgProcessingTime = this.metrics.processingTimes.length > 0 
      ? this.metrics.processingTimes.reduce((a, b) => a + b) / this.metrics.processingTimes.length
      : 0;
    
    return {
      summary: {
        totalEvents: this.metrics.totalEvents,
        avgProcessingTimeMs: Math.round(avgProcessingTime),
        errorRate: this.calculateErrorRate()
      },
      eventsByType: Object.fromEntries(this.metrics.eventsByType),
      eventsByHour: Object.fromEntries(this.metrics.eventsByHour),
      topErrors: this.getTopErrors(),
      performanceStats: {
        p50: this.getPercentile(50),
        p95: this.getPercentile(95),
        p99: this.getPercentile(99)
      }
    };
  }
  
  calculateErrorRate() {
    const totalErrors = Array.from(this.metrics.errorCounts.values())
      .reduce((sum, count) => sum + count, 0);
    
    return this.metrics.totalEvents > 0 
      ? (totalErrors / this.metrics.totalEvents * 100).toFixed(2)
      : 0;
  }
  
  getPercentile(percentile) {
    if (this.metrics.processingTimes.length === 0) return 0;
    
    const sorted = [...this.metrics.processingTimes].sort((a, b) => a - b);
    const index = Math.ceil(sorted.length * percentile / 100) - 1;
    
    return sorted[index] || 0;
  }
}

// Usage
const analytics = new WebhookAnalytics();

app.post('/webhooks/tolstoy', async (req, res) => {
  const startTime = Date.now();
  let error = null;
  
  try {
    await processWebhookEvent(req.body);
    res.json({ received: true });
  } catch (err) {
    error = err;
    res.status(500).json({ error: err.message });
  } finally {
    const processingTime = Date.now() - startTime;
    analytics.recordEvent(req.body, processingTime, error);
  }
});

// Generate daily report
setInterval(() => {
  const report = analytics.getReport();
  console.log('Webhook Analytics Report:', report);
}, 24 * 60 * 60 * 1000); // Daily
```

</CodeGroup>

## Testing Webhooks

### **Webhook Testing Suite**

<CodeGroup>

```javascript Webhook Test Suite
class WebhookTester {
  constructor(webhookSecret) {
    this.secret = webhookSecret;
    this.testEvents = [];
  }
  
  createTestEvent(type, data) {
    return {
      event: {
        id: `evt_test_${Date.now()}`,
        type,
        created_at: new Date().toISOString(),
        api_version: '2024-01-15'
      },
      data: {
        object: data
      },
      organization: {
        id: 'org_test123',
        name: 'test-org'
      }
    };
  }
  
  generateSignature(payload) {
    const crypto = require('crypto');
    return 'sha256=' + crypto
      .createHmac('sha256', this.secret)
      .update(payload, 'utf8')
      .digest('hex');
  }
  
  async sendTestEvent(endpoint, eventType, data) {
    const event = this.createTestEvent(eventType, data);
    const payload = JSON.stringify(event);
    const signature = this.generateSignature(payload);
    
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Tolstoy-Event': eventType,
        'X-Tolstoy-Signature': signature,
        'X-Tolstoy-Delivery': `test_${Date.now()}`
      },
      body: payload
    });
    
    this.testEvents.push({
      event,
      response: {
        status: response.status,
        ok: response.ok,
        timestamp: new Date()
      }
    });
    
    return response;
  }
  
  async runTestSuite(endpoint) {
    console.log('üß™ Running webhook test suite...');
    
    const tests = [
      {
        name: 'Flow Completed',
        type: 'flow.completed',
        data: {
          id: 'exec_test123',
          flow_id: 'flow_test456',
          flow_name: 'test_flow',
          status: 'success',
          duration_ms: 1500
        }
      },
      {
        name: 'Flow Failed',
        type: 'flow.failed',
        data: {
          id: 'exec_test124',
          flow_id: 'flow_test456',
          flow_name: 'test_flow',
          status: 'failed',
          error: {
            code: 'EXECUTION_FAILED',
            message: 'Test failure'
          }
        }
      },
      {
        name: 'User Created',
        type: 'user.created',
        data: {
          id: 'user_test123',
          email: 'test@example.com',
          name: 'Test User',
          role: 'developer'
        }
      }
    ];
    
    const results = [];
    
    for (const test of tests) {
      try {
        console.log(`Testing: ${test.name}`);
        const response = await this.sendTestEvent(endpoint, test.type, test.data);
        
        results.push({
          name: test.name,
          type: test.type,
          success: response.ok,
          status: response.status,
          duration: Date.now() - this.testEvents[this.testEvents.length - 1].response.timestamp
        });
        
        console.log(`  ${response.ok ? '‚úÖ' : '‚ùå'} ${response.status}`);
        
      } catch (error) {
        results.push({
          name: test.name,
          type: test.type,
          success: false,
          error: error.message
        });
        
        console.log(`  üí• Error: ${error.message}`);
      }
      
      // Small delay between tests
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    console.log('\nüìä Test Results:');
    console.table(results);
    
    return results;
  }
}

// Usage
const tester = new WebhookTester(process.env.TOLSTOY_WEBHOOK_SECRET);
await tester.runTestSuite('https://your-app.com/webhooks/tolstoy');
```

</CodeGroup>

## API Playground

Test webhook event handling:

<ApiPlayground
  method="POST"
  endpoint="/webhooks"
  baseUrl="https://your-app.com"
  headers={[
    {
      name: "X-Tolstoy-Event",
      value: "flow.completed",
      description: "Event type",
      required: true
    },
    {
      name: "X-Tolstoy-Signature", 
      value: "sha256=abc123...",
      description: "HMAC signature for verification",
      required: true
    },
    {
      name: "X-Tolstoy-Delivery",
      value: "delivery_xyz789",
      description: "Unique delivery ID",
      required: true
    }
  ]}
  body={{
    type: "json",
    schema: {
      event: {
        type: "object",
        defaultValue: {
          id: "evt_test123",
          type: "flow.completed",
          created_at: "2024-01-15T10:30:00Z",
          api_version: "2024-01-15"
        },
        description: "Event metadata",
        required: true
      },
      data: {
        type: "object", 
        defaultValue: {
          object: {
            id: "exec_test123",
            flow_id: "flow_test456",
            flow_name: "test_workflow",
            status: "success",
            duration_ms: 2500
          }
        },
        description: "Event data",
        required: true
      },
      organization: {
        type: "object",
        defaultValue: {
          id: "org_test123",
          name: "test-org"
        },
        description: "Organization context",
        required: true
      }
    }
  }}
  testScenarios={[
    {
      name: "Flow Completed",
      description: "Successful flow execution",
      headers: { "X-Tolstoy-Event": "flow.completed" },
      body: {
        event: { type: "flow.completed" },
        data: { object: { status: "success" } }
      }
    },
    {
      name: "Flow Failed", 
      description: "Failed flow execution",
      headers: { "X-Tolstoy-Event": "flow.failed" },
      body: {
        event: { type: "flow.failed" },
        data: { object: { status: "failed", error: { message: "Test error" } } }
      }
    },
    {
      name: "User Created",
      description: "New user added",
      headers: { "X-Tolstoy-Event": "user.created" },
      body: {
        event: { type: "user.created" },
        data: { object: { email: "newuser@test.com", role: "developer" } }
      }
    }
  ]}
  sampleResponse={{
    "received": true,
    "processed_at": "2024-01-15T10:30:01Z"
  }}
/>

## Event Types Reference

### **Complete Event List**

<Tabs>
  <Tab title="Flow Events">
    | Event Type | Description | Frequency |
    |------------|-------------|-----------|
    | `flow.created` | New flow created | Low |
    | `flow.updated` | Flow configuration changed | Low |
    | `flow.deleted` | Flow removed | Low |
    | `flow.published` | Flow published to production | Low |
    | `flow.archived` | Flow archived/deactivated | Low |
  </Tab>
  
  <Tab title="Execution Events">
    | Event Type | Description | Frequency |
    |------------|-------------|-----------|
    | `execution.started` | Flow execution began | High |
    | `execution.completed` | Flow execution succeeded | High |
    | `execution.failed` | Flow execution failed | Medium |
    | `execution.timeout` | Flow execution timed out | Low |
    | `execution.cancelled` | Flow execution cancelled | Low |
  </Tab>
  
  <Tab title="Action Events">
    | Event Type | Description | Frequency |
    |------------|-------------|-----------|
    | `action.created` | New action created | Low |
    | `action.updated` | Action configuration changed | Low |
    | `action.deleted` | Action removed | Low |
    | `action.executed` | Action executed | High |
    | `action.health_check_failed` | Action health check failed | Low |
  </Tab>
  
  <Tab title="User Events">
    | Event Type | Description | Frequency |
    |------------|-------------|-----------|
    | `user.created` | New user added | Low |
    | `user.updated` | User profile changed | Low |
    | `user.role_changed` | User role/permissions changed | Low |
    | `user.deactivated` | User deactivated | Low |
    | `user.login` | User logged in | Medium |
  </Tab>
  
  <Tab title="System Events">
    | Event Type | Description | Frequency |
    |------------|-------------|-----------|
    | `system.maintenance_started` | Maintenance began | Very Low |
    | `system.maintenance_completed` | Maintenance finished | Very Low |
    | `system.alert` | System alert triggered | Low |
    | `system.performance_degraded` | Performance issues detected | Low |
  </Tab>
</Tabs>

## Related Documentation

<CardGroup cols={2}>
  <Card title="Webhook Setup Guide" icon="link" href="/api/guides/webhooks">
    Complete webhook setup guide
  </Card>
  <Card title="Authentication Guide" icon="key" href="/api/guides/authentication">
    Webhook signature verification
  </Card>
  <Card title="Error Handling" icon="shield" href="/api/guides/error-handling">
    Handle webhook delivery failures
  </Card>
  <Card title="Testing Guide" icon="flask" href="/api/guides/testing">
    Test webhook integrations
  </Card>
</CardGroup>