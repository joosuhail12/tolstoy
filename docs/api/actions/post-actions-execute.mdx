---
title: "Execute Action"
openapi: "POST /actions/{id}/execute"
---

# Execute Action

Execute a single action directly with automatic credential injection and comprehensive monitoring. This endpoint provides standalone action execution with full authentication support, input validation, and Prometheus metrics collection.

<RequestExample>

```bash cURL
curl -X POST "https://tolstoy.getpullse.com/actions/email-action-id/execute" \
  -H "X-Org-ID: org_1234567890abcdef" \
  -H "X-User-ID: user_abcdef1234567890" \
  -H "Content-Type: application/json" \
  -d '{
    "inputs": {
      "to": "john@company.com",
      "subject": "Welcome to our platform!",
      "body": "Thanks for signing up. We are excited to have you!",
      "template": "welcome-template"
    }
  }'
```

```typescript TypeScript
interface ExecuteActionRequest {
  inputs: Record<string, any>;
}

const executeRequest: ExecuteActionRequest = {
  inputs: {
    to: "john@company.com",
    subject: "Welcome to our platform!",
    body: "Thanks for signing up. We are excited to have you!",
    template: "welcome-template"
  }
};

const response = await fetch('https://tolstoy.getpullse.com/actions/email-action-id/execute', {
  method: 'POST',
  headers: {
    'X-Org-ID': 'org_1234567890abcdef',
    'X-User-ID': 'user_abcdef1234567890',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(executeRequest)
});

const result = await response.json();
if (result.success) {
  console.log('Action executed:', result);
  console.log('Output:', result.output);
} else {
  console.error('Execution failed:', result.error);
}
```

```python Python
import requests
import json

action_data = {
    "action_id": "slack-message",
    "inputs": {
        "channel": "#general",
        "message": "Hello team! üëã",
        "username": "Tolstoy Bot",
        "icon_emoji": ":robot_face:"
    },
    "mode": "sync",
    "auth_config": {
        "provider": "oauth2",
        "token": "xoxb-your-slack-token"
    }
}

headers = {
    'x-org-id': 'org_1234567890abcdef',
    'x-user-id': 'user_abcdef1234567890',
    'Content-Type': 'application/json'
}

response = requests.post(
    'https://tolstoy.getpullse.com/actions/execute',
    headers=headers,
    json=action_data
)

if response.status_code == 200:
    result = response.json()
    print(f"Action executed successfully: {result['data']['output']}")
else:
    error = response.json()
    print(f"Error: {error['error']['message']}")
```

```javascript Node.js
const axios = require('axios');

async function executeAction(actionId, inputs) {
  const requestData = {
    action_id: actionId,
    inputs: inputs,
    mode: "sync"
  };

  try {
    const response = await axios.post(
      'https://tolstoy.getpullse.com/actions/execute',
      requestData,
      {
        headers: {
          'x-org-id': 'org_1234567890abcdef',
          'x-user-id': 'user_abcdef1234567890',
          'Content-Type': 'application/json'
        }
      }
    );

    if (response.data.success) {
      console.log('Action completed:', response.data.data.status);
      return response.data.data.output;
    }
  } catch (error) {
    console.error('Execution failed:', error.response?.data || error.message);
    throw error;
  }
}

// Execute HTTP request action
const httpResult = await executeAction('http-request', {
  method: 'GET',
  url: 'https://api.example.com/users/123',
  headers: {
    'Authorization': 'Bearer your-token',
    'Content-Type': 'application/json'
  }
});

console.log('API Response:', httpResult);
```

</RequestExample>

## Key Features

### üîê Automatic Auth Injection
Credentials are automatically injected based on the action's tool configuration:
- **OAuth2 Tokens**: Automatically refreshed and injected for supported providers
- **API Keys**: Securely retrieved from organization configuration
- **Multi-tenant Isolation**: Credentials scoped per organization
- **Audit Trails**: All auth operations logged for compliance

### üìä Prometheus Metrics
Every action execution is automatically tracked:
- `action_executions_total{orgId,toolKey,actionKey,status}` - Execution counter
- `action_execution_duration_seconds{orgId,toolKey,actionKey}` - Duration histogram
- `action_auth_injection_total{orgId,toolKey,authType,status}` - Auth injection metrics

### ‚úÖ Input Validation
All inputs are validated against the action's schema:
- Type checking and format validation
- Required field enforcement
- Custom validation rules
- Clear error messages with field-level details

## Path Parameters

<ParamField path="id" type="string" required>
The ID of the action to execute. Use the [List Actions](/api/actions/get-actions) endpoint to discover available actions.

**Examples:**
- `action_email_send_123` - Send email action
- `action_slack_message_456` - Send Slack message action  
- `action_http_request_789` - Make HTTP request action
- `action_github_create_issue_012` - Create GitHub issue action
</ParamField>

## Request Body

<ParamField body="inputs" type="object" required>
Input parameters for the action. The structure depends on the specific action being executed.

**Validation:** All inputs are validated against the action's input schema before execution.

**Examples:**
```json
// Email action inputs
{
  "to": "user@example.com",
  "subject": "Hello",
  "body": "Message content"
}

// HTTP request inputs
{
  "method": "POST",
  "url": "https://api.example.com/endpoint",
  "body": {"key": "value"}
}
```
</ParamField>

<ParamField body="mode" type="string" default="sync">
Execution mode determining how the request is processed.

**Available modes:**
- `sync` - Wait for completion and return results (blocking)
- `async` - Start execution and return immediately (non-blocking)

**Recommendations:**
- Use `sync` for quick actions (<30 seconds)
- Use `async` for long-running actions or high-throughput scenarios
</ParamField>

<ParamField body="timeout_ms" type="integer">
Optional timeout for action execution in milliseconds.

**Constraints:**
- Minimum: 1000ms (1 second)
- Maximum: 300000ms (5 minutes) for sync mode
- Maximum: 3600000ms (1 hour) for async mode
- Default: 30000ms (30 seconds) for sync, 300000ms for async
</ParamField>

<ParamField body="auth_config" type="object">
Authentication configuration for actions that require external service access.

<Expandable title="Auth Config Fields">
  <ParamField body="provider" type="string" required>
    Authentication provider type: `oauth2`, `api_key`, `basic_auth`, `bearer_token`
  </ParamField>
  <ParamField body="token" type="string">
    Authentication token (for oauth2, bearer_token)
  </ParamField>
  <ParamField body="api_key" type="string">
    API key for service authentication
  </ParamField>
  <ParamField body="username" type="string">
    Username for basic authentication
  </ParamField>
  <ParamField body="password" type="string">
    Password for basic authentication
  </ParamField>
  <ParamField body="headers" type="object">
    Additional authentication headers
  </ParamField>
</Expandable>
</ParamField>

<ParamField body="metadata" type="object">
Optional metadata to associate with the execution for tracking and debugging.

**Examples:**
```json
{
  "execution_id": "custom-id-123",
  "source": "api-integration",
  "tags": ["testing", "automation"]
}
```
</ParamField>

<ParamField body="dry_run" type="boolean" default="false">
When true, validates inputs and returns execution plan without actually executing the action.

**Use cases:**
- Testing action configurations
- Validating input data
- Debugging action setup
</ParamField>

## Response

<ResponseExample>

```json Sync Execution Success
{
  "success": true,
  "data": {
    "execution_id": "exec_action_abc123def456",
    "action_id": "email-send",
    "status": "completed",
    "mode": "sync",
    "inputs": {
      "to": "john@company.com",
      "subject": "Welcome to our platform!",
      "body": "Thanks for signing up. We are excited to have you!",
      "template": "welcome-template"
    },
    "output": {
      "message_id": "msg_xyz789abc123",
      "sent_at": "2024-01-15T14:30:15Z",
      "status": "delivered",
      "provider": "sendgrid",
      "recipient": "john@company.com"
    },
    "performance": {
      "duration_ms": 1245,
      "provider_response_time_ms": 892
    },
    "executed_at": "2024-01-15T14:30:00Z",
    "completed_at": "2024-01-15T14:30:01Z"
  },
  "metadata": {
    "request_id": "req_abc123def456",
    "timestamp": "2024-01-15T14:30:01Z"
  }
}
```

```json Async Execution Started
{
  "success": true,
  "data": {
    "execution_id": "exec_action_xyz789ghi012",
    "action_id": "http-request",
    "status": "running",
    "mode": "async",
    "inputs": {
      "method": "POST",
      "url": "https://api.external.com/process",
      "body": {"data": "large-dataset"}
    },
    "progress": {
      "percentage": 0,
      "current_stage": "initializing",
      "estimated_completion": "2024-01-15T14:35:00Z"
    },
    "executed_at": "2024-01-15T14:30:00Z"
  },
  "metadata": {
    "request_id": "req_async123",
    "timestamp": "2024-01-15T14:30:00Z"
  }
}
```

```json Execution Failure
{
  "success": true,
  "data": {
    "execution_id": "exec_action_failed123",
    "action_id": "slack-message",
    "status": "failed",
    "mode": "sync",
    "inputs": {
      "channel": "#nonexistent",
      "message": "Hello team!"
    },
    "error": {
      "code": "CHANNEL_NOT_FOUND",
      "message": "Slack channel '#nonexistent' not found",
      "provider": "slack",
      "details": {
        "channel": "#nonexistent",
        "available_channels": ["#general", "#dev", "#marketing"]
      }
    },
    "executed_at": "2024-01-15T14:30:00Z",
    "failed_at": "2024-01-15T14:30:02Z"
  },
  "metadata": {
    "request_id": "req_failed123",
    "timestamp": "2024-01-15T14:30:02Z"
  }
}
```

```json Input Validation Error
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Action input validation failed",
    "details": {
      "action_id": "email-send",
      "field": "to",
      "value": "invalid-email",
      "reason": "Must be a valid email address format"
    }
  },
  "metadata": {
    "request_id": "req_validation_error",
    "timestamp": "2024-01-15T14:30:00Z"
  }
}
```

```json Dry Run Response
{
  "success": true,
  "data": {
    "dry_run": true,
    "action_id": "http-request",
    "validation": {
      "inputs_valid": true,
      "auth_valid": true,
      "action_available": true
    },
    "execution_plan": {
      "resolved_inputs": {
        "method": "GET",
        "url": "https://api.example.com/users",
        "headers": {
          "Authorization": "Bearer resolved-token",
          "Content-Type": "application/json"
        }
      },
      "estimated_duration_ms": 2000,
      "provider": "built-in",
      "requirements": ["internet_access"]
    }
  },
  "metadata": {
    "request_id": "req_dryrun123",
    "timestamp": "2024-01-15T14:30:00Z"
  }
}
```

```json Action Not Found Error
{
  "success": false,
  "error": {
    "code": "ACTION_NOT_FOUND",
    "message": "Action not found or not accessible",
    "details": {
      "action_id": "nonexistent-action",
      "available_actions": ["email-send", "slack-message", "http-request"]
    }
  },
  "metadata": {
    "request_id": "req_not_found",
    "timestamp": "2024-01-15T14:30:00Z"
  }
}
```

</ResponseExample>

## Response Fields

### Execution Object

<ResponseField name="execution_id" type="string">
Unique identifier for this action execution
</ResponseField>

<ResponseField name="action_id" type="string">
The ID of the action that was executed
</ResponseField>

<ResponseField name="status" type="string">
Current execution status:
- `running` - Action is currently executing (async mode)
- `completed` - Action completed successfully
- `failed` - Action execution failed
- `timeout` - Action exceeded timeout limit
</ResponseField>

<ResponseField name="mode" type="string">
Execution mode: `sync` or `async`
</ResponseField>

<ResponseField name="inputs" type="object">
The input parameters that were provided for execution
</ResponseField>

<ResponseField name="output" type="object">
Action output data (available when status is `completed`)
  <Expandable title="Common Output Fields">
    <ResponseField name="*" type="any">Action-specific output data varies by action type</ResponseField>
    <ResponseField name="status" type="string">Provider-specific status information</ResponseField>
    <ResponseField name="message_id" type="string">Unique identifier from external service (if applicable)</ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="error" type="object">
Error information (available when status is `failed`)
  <Expandable title="Error Fields">
    <ResponseField name="code" type="string">Error code identifying the failure type</ResponseField>
    <ResponseField name="message" type="string">Human-readable error description</ResponseField>
    <ResponseField name="provider" type="string">Service provider that generated the error</ResponseField>
    <ResponseField name="details" type="object">Additional error context and debugging information</ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="progress" type="object">
Execution progress (async mode only)
  <Expandable title="Progress Fields">
    <ResponseField name="percentage" type="number">Completion percentage (0-100)</ResponseField>
    <ResponseField name="current_stage" type="string">Current execution stage description</ResponseField>
    <ResponseField name="estimated_completion" type="string">Estimated completion timestamp</ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="performance" type="object">
Performance metrics (completed executions only)
  <Expandable title="Performance Fields">
    <ResponseField name="duration_ms" type="integer">Total execution time in milliseconds</ResponseField>
    <ResponseField name="provider_response_time_ms" type="integer">External service response time</ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="executed_at" type="string">
ISO 8601 timestamp when execution started
</ResponseField>

<ResponseField name="completed_at" type="string">
ISO 8601 timestamp when execution completed (if completed)
</ResponseField>

<ResponseField name="failed_at" type="string">
ISO 8601 timestamp when execution failed (if failed)
</ResponseField>

## Status Codes

<ResponseField name="200" type="Success - Sync Mode">
Synchronous execution completed (success or failure)
</ResponseField>

<ResponseField name="202" type="Accepted - Async Mode">
Asynchronous execution started successfully
</ResponseField>

<ResponseField name="400" type="Bad Request">
Invalid request format, missing required fields, or malformed JSON
</ResponseField>

<ResponseField name="401" type="Unauthorized">
Missing or invalid authentication headers
</ResponseField>

<ResponseField name="403" type="Forbidden">
Insufficient permissions to execute actions
</ResponseField>

<ResponseField name="404" type="Not Found">
Action not found or not accessible
</ResponseField>

<ResponseField name="422" type="Unprocessable Entity">
Input validation failed or action configuration errors
</ResponseField>

<ResponseField name="429" type="Too Many Requests">
Rate limit exceeded
</ResponseField>

<ResponseField name="500" type="Internal Server Error">
Server error during action execution
</ResponseField>

## Examples

### Email Actions

<CodeGroup>

```bash Simple Email
curl -X POST "https://tolstoy.getpullse.com/actions/execute" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890" \
  -H "Content-Type: application/json" \
  -d '{
    "action_id": "email-send",
    "inputs": {
      "to": "customer@example.com",
      "subject": "Order Confirmation",
      "body": "Your order has been confirmed and will ship soon!"
    }
  }'
```

```typescript Template Email
const result = await fetch('/actions/execute', {
  method: 'POST',
  headers: {
    'x-org-id': 'org_1234567890abcdef',
    'x-user-id': 'user_abcdef1234567890',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    action_id: "email-send",
    inputs: {
      to: "user@example.com",
      template: "welcome-template",
      variables: {
        customer_name: "John Smith",
        plan_type: "Premium"
      }
    }
  })
});
```

</CodeGroup>

### HTTP Requests

<CodeGroup>

```bash API Call
curl -X POST "https://tolstoy.getpullse.com/actions/execute" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890" \
  -H "Content-Type: application/json" \
  -d '{
    "action_id": "http-request",
    "inputs": {
      "method": "POST",
      "url": "https://api.crm.com/contacts",
      "headers": {
        "Authorization": "Bearer api-token",
        "Content-Type": "application/json"
      },
      "body": {
        "name": "John Smith",
        "email": "john@company.com",
        "source": "website"
      }
    }
  }'
```

```python Webhook
import requests

webhook_data = {
    "action_id": "http-request",
    "inputs": {
        "method": "POST",
        "url": "https://hooks.slack.com/services/webhook-url",
        "body": {
            "text": "New user registered!",
            "username": "Registration Bot",
            "channel": "#marketing"
        }
    },
    "mode": "sync"
}

response = requests.post(
    'https://tolstoy.getpullse.com/actions/execute',
    headers={
        'x-org-id': 'org_1234567890abcdef',
        'x-user-id': 'user_abcdef1234567890',
        'Content-Type': 'application/json'
    },
    json=webhook_data
)
```

</CodeGroup>

### Messaging Actions

<CodeGroup>

```typescript Slack Message
const slackResult = await fetch('/actions/execute', {
  method: 'POST',
  headers: {
    'x-org-id': 'org_1234567890abcdef',
    'x-user-id': 'user_abcdef1234567890',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    action_id: "slack-message",
    inputs: {
      channel: "#alerts",
      message: "üö® High CPU usage detected on server-01",
      attachments: [
        {
          color: "danger",
          title: "Server Alert",
          fields: [
            {
              title: "CPU Usage",
              value: "95%",
              short: true
            },
            {
              title: "Server",
              value: "server-01",
              short: true
            }
          ]
        }
      ]
    },
    auth_config: {
      provider: "oauth2",
      token: "xoxb-slack-bot-token"
    }
  })
});
```

```python SMS Message
sms_data = {
    "action_id": "sms-send",
    "inputs": {
        "to": "+1234567890",
        "message": "Your verification code is: 123456"
    },
    "auth_config": {
        "provider": "api_key",
        "api_key": "twilio-api-key"
    }
}

result = requests.post(
    'https://tolstoy.getpullse.com/actions/execute',
    headers=headers,
    json=sms_data
)
```

</CodeGroup>

### Batch Execution Pattern

<CodeGroup>

```javascript Batch Processing
async function executeBatchActions(actions) {
  const executions = await Promise.all(
    actions.map(async (actionConfig) => {
      try {
        const response = await fetch('/actions/execute', {
          method: 'POST',
          headers: {
            'x-org-id': 'org_1234567890abcdef',
            'x-user-id': 'user_abcdef1234567890',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            ...actionConfig,
            mode: 'async'
          })
        });
        
        return await response.json();
      } catch (error) {
        return { 
          success: false, 
          error: { message: error.message },
          action_config: actionConfig
        };
      }
    })
  );
  
  return executions;
}

// Execute multiple notifications
const notifications = [
  {
    action_id: "email-send",
    inputs: { to: "admin@company.com", subject: "Alert", body: "Issue detected" }
  },
  {
    action_id: "slack-message", 
    inputs: { channel: "#alerts", message: "Issue detected" }
  },
  {
    action_id: "sms-send",
    inputs: { to: "+1234567890", message: "Issue detected" }
  }
];

const results = await executeBatchActions(notifications);
console.log(`Executed ${results.length} notifications`);
```

</CodeGroup>

## Error Handling

### Common Error Patterns

<Accordion title="Input Validation Errors">
```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input parameter",
    "details": {
      "field": "email",
      "value": "not-an-email",
      "reason": "Must be a valid email address"
    }
  }
}
```

**Resolution:** Validate input data client-side and ensure it matches the action's input schema.
</Accordion>

<Accordion title="Authentication Errors">
```json
{
  "success": false,
  "error": {
    "code": "AUTH_ERROR",
    "message": "Authentication failed",
    "details": {
      "provider": "slack",
      "auth_type": "oauth2",
      "reason": "Invalid or expired token"
    }
  }
}
```

**Resolution:** Verify authentication credentials and refresh tokens if necessary.
</Accordion>

<Accordion title="Provider Service Errors">
```json
{
  "success": true,
  "data": {
    "status": "failed",
    "error": {
      "code": "PROVIDER_ERROR",
      "message": "External service returned error",
      "provider": "sendgrid",
      "details": {
        "status_code": 429,
        "provider_message": "Rate limit exceeded"
      }
    }
  }
}
```

**Resolution:** Implement retry logic with exponential backoff for transient provider errors.
</Accordion>

## Best Practices

### Input Validation

<Accordion title="Client-Side Validation">
- Always validate inputs before sending requests
- Use the action's input schema for validation rules
- Provide clear error messages for invalid inputs
- Consider input size limits and data type requirements
</Accordion>

<Accordion title="Error Handling">
- Implement comprehensive error handling for all execution scenarios
- Use dry_run mode to test configurations before actual execution
- Log execution failures with sufficient context for debugging
- Have fallback strategies for critical actions
</Accordion>

### Performance Optimization

<Accordion title="Execution Mode Selection">
- Use `sync` mode for quick actions requiring immediate results
- Use `async` mode for long-running actions or high-throughput scenarios
- Consider timeout settings based on expected action duration
- Monitor execution performance and adjust timeouts accordingly
</Accordion>

<Accordion title="Authentication Management">
- Cache and reuse authentication tokens when possible
- Implement token refresh logic for OAuth2 providers
- Use secure storage for authentication credentials
- Monitor authentication failures and implement retry logic
</Accordion>

## Related Endpoints

<CardGroup cols={2}>
  <Card title="List Actions" icon="list" href="/api/actions/get-actions">
    Discover available actions and their schemas
  </Card>
  <Card title="Get Action Details" icon="info" href="/api/actions/get-actions-1">
    View detailed action specifications
  </Card>
</CardGroup>

<CardGroup cols={2}>
  <Card title="Create Custom Action" icon="plus" href="/api/actions/post-actions">
    Build your own custom actions
  </Card>
  <Card title="Execute in Flow" icon="workflow" href="/api/flows/post-flows-execute">
    Use actions within workflow executions
  </Card>
</CardGroup>

---

<Info>
**Tip**: Use dry_run mode to validate your action configuration and inputs before actual execution. This helps catch issues early and saves on execution costs.
</Info>