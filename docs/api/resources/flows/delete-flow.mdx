---
title: "Delete Flow"
description: "Permanently delete a workflow with safety checks, execution impact analysis, and optional backup creation."
---

# Delete Flow

Permanently delete a workflow from your organization with comprehensive safety checks, execution impact analysis, and optional backup creation for recovery.

## Endpoint

<CodeGroup>
```http HTTP
DELETE /flows/{id}
```

```bash cURL
curl -X DELETE "https://tolstoy.getpullse.com/flows/flow_abc123def456" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890"
```
</CodeGroup>

## Path Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `id` | string | **Required.** The unique identifier of the flow to delete |

## Query Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `force` | boolean | false | Force deletion even with active dependencies |
| `backup` | boolean | true | Create backup before deletion |
| `cancel_executions` | boolean | false | Cancel running executions before deletion |

## Request Examples

### Basic Deletion

<CodeGroup>
```bash cURL - Safe Deletion
curl -X DELETE "https://tolstoy.getpullse.com/flows/flow_abc123def456" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890"
```

```bash cURL - Force Deletion with Backup
curl -X DELETE "https://tolstoy.getpullse.com/flows/flow_abc123def456?force=true&backup=true&cancel_executions=true" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890"
```

```typescript TypeScript/Node.js
import { TolstoyClient } from '@joosuhail/tolstoy-sdk';

const client = new TolstoyClient({
  orgId: 'org_1234567890abcdef',
  userId: 'user_abcdef1234567890'
});

async function safeDeleteFlow(flowId: string) {
  try {
    // First, check the flow status and dependencies
    const flow = await client.flows.get(flowId);
    
    console.log(`Preparing to delete flow: ${flow.name}`);
    console.log(`Current status: ${flow.status}`);
    console.log(`Total executions: ${flow.stats.total_executions}`);
    
    // Check for active executions
    const activeExecutions = await client.flows.listExecutions(flowId, {
      status: ['pending', 'running']
    });
    
    if (activeExecutions.length > 0) {
      console.warn(`‚ö†Ô∏è  Found ${activeExecutions.length} active executions`);
      
      // Ask user for confirmation
      const shouldCancel = await confirmCancellation();
      if (!shouldCancel) {
        console.log('Deletion cancelled by user');
        return null;
      }
    }
    
    // Perform deletion with safety options
    const result = await client.flows.delete(flowId, {
      backup: true,
      cancel_executions: activeExecutions.length > 0,
      force: false
    });
    
    console.log('‚úÖ Flow deleted successfully');
    console.log(`Backup created: ${result.backup_id}`);
    
    return result;
    
  } catch (error) {
    if (error.code === 'FLOW_HAS_DEPENDENCIES') {
      console.error('‚ùå Cannot delete flow - it has active dependencies:');
      error.details.dependencies.forEach((dep: any) => {
        console.error(`  - ${dep.type}: ${dep.name} (${dep.id})`);
      });
      console.log('Use force=true to override, or remove dependencies first');
    } else {
      console.error('Failed to delete flow:', error);
    }
    throw error;
  }
}

async function confirmCancellation(): Promise<boolean> {
  // In a real application, you'd prompt the user
  // For this example, we'll assume confirmation
  return true;
}

// Usage
safeDeleteFlow('flow_abc123def456');
```

```python Python
import tolstoy

client = tolstoy.Client(
    org_id='org_1234567890abcdef',
    user_id='user_abcdef1234567890'
)

def delete_flow_with_confirmation(flow_id: str):
    try:
        # Get flow information first
        flow = client.flows.get(flow_id)
        
        print(f"Planning to delete: {flow['name']}")
        print(f"Total executions: {flow['stats']['total_executions']:,}")
        print(f"Success rate: {flow['stats']['success_rate'] * 100:.1f}%")
        
        # Check for recent executions
        recent_executions = client.flows.list_executions(flow_id, {
            'limit': 10,
            'status': 'all'
        })
        
        if recent_executions:
            print(f"‚ö†Ô∏è  Flow has {len(recent_executions)} recent executions")
            last_execution = recent_executions[0]['started_at']
            print(f"Last execution: {last_execution}")
        
        # Confirm deletion
        confirm = input("Are you sure you want to delete this flow? (yes/no): ")
        if confirm.lower() != 'yes':
            print("Deletion cancelled")
            return None
        
        # Check for active executions
        active_executions = [
            exec for exec in recent_executions 
            if exec['status'] in ['pending', 'running']
        ]
        
        delete_options = {
            'backup': True,
            'force': False
        }
        
        if active_executions:
            print(f"Found {len(active_executions)} active executions")
            cancel = input("Cancel active executions? (yes/no): ")
            delete_options['cancel_executions'] = cancel.lower() == 'yes'
        
        # Perform deletion
        result = client.flows.delete(flow_id, delete_options)
        
        print("‚úÖ Flow deleted successfully")
        if result.get('backup_id'):
            print(f"Backup created: {result['backup_id']}")
        
        return result
        
    except Exception as error:
        print(f"Failed to delete flow: {error}")
        raise error

# Usage
delete_flow_with_confirmation('flow_abc123def456')
```
</CodeGroup>

### Bulk Deletion with Safety Checks

```typescript
async function bulkDeleteFlows(flowIds: string[], options: {
  dryRun?: boolean;
  maxConcurrent?: number;
} = {}) {
  const { dryRun = false, maxConcurrent = 3 } = options;
  
  console.log(`${dryRun ? 'Simulating' : 'Performing'} bulk deletion of ${flowIds.length} flows`);
  
  // Analyze flows first
  const flowAnalysis = await Promise.all(
    flowIds.map(async (flowId) => {
      try {
        const flow = await client.flows.get(flowId);
        const activeExecutions = await client.flows.listExecutions(flowId, {
          status: ['pending', 'running'],
          limit: 1
        });
        
        return {
          flowId,
          name: flow.name,
          status: flow.status,
          totalExecutions: flow.stats.total_executions,
          hasActiveExecutions: activeExecutions.length > 0,
          canDelete: flow.status !== 'active' && activeExecutions.length === 0,
          dependencies: [] // Would be populated from dependency check
        };
      } catch (error) {
        return {
          flowId,
          error: error.message,
          canDelete: false
        };
      }
    })
  );
  
  // Report analysis
  const canDelete = flowAnalysis.filter(f => f.canDelete);
  const cannotDelete = flowAnalysis.filter(f => !f.canDelete);
  
  console.log(`\nüìä Analysis Results:`);
  console.log(`  ‚úÖ Can delete safely: ${canDelete.length}`);
  console.log(`  ‚ö†Ô∏è  Need attention: ${cannotDelete.length}`);
  
  if (cannotDelete.length > 0) {
    console.log(`\n‚ö†Ô∏è  Flows that need attention:`);
    cannotDelete.forEach(flow => {
      if (flow.error) {
        console.log(`  - ${flow.flowId}: Error - ${flow.error}`);
      } else {
        console.log(`  - ${flow.name} (${flow.flowId}): ${
          flow.hasActiveExecutions ? 'Has active executions' : 
          flow.status === 'active' ? 'Still active' : 'Unknown issue'
        }`);
      }
    });
  }
  
  if (dryRun) {
    return { analysis: flowAnalysis, wouldDelete: canDelete.length };
  }
  
  // Perform deletions in batches
  const results = [];
  const semaphore = new Semaphore(maxConcurrent);
  
  const deletionPromises = canDelete.map(async (flow) => {
    await semaphore.acquire();
    
    try {
      const result = await client.flows.delete(flow.flowId, {
        backup: true,
        force: false
      });
      
      return {
        flowId: flow.flowId,
        name: flow.name,
        success: true,
        backupId: result.backup_id
      };
    } catch (error) {
      return {
        flowId: flow.flowId,
        name: flow.name,
        success: false,
        error: error.message
      };
    } finally {
      semaphore.release();
    }
  });
  
  const deletionResults = await Promise.all(deletionPromises);
  
  const successful = deletionResults.filter(r => r.success);
  const failed = deletionResults.filter(r => !r.success);
  
  console.log(`\n‚úÖ Deletion complete:`);
  console.log(`  Successful: ${successful.length}`);
  console.log(`  Failed: ${failed.length}`);
  
  if (failed.length > 0) {
    console.log(`\n‚ùå Failed deletions:`);
    failed.forEach(f => {
      console.log(`  - ${f.name}: ${f.error}`);
    });
  }
  
  return {
    successful,
    failed,
    analysis: flowAnalysis
  };
}

class Semaphore {
  private permits: number;
  private waiting: Array<() => void> = [];
  
  constructor(permits: number) {
    this.permits = permits;
  }
  
  async acquire(): Promise<void> {
    if (this.permits > 0) {
      this.permits--;
      return Promise.resolve();
    }
    
    return new Promise<void>((resolve) => {
      this.waiting.push(resolve);
    });
  }
  
  release(): void {
    this.permits++;
    if (this.waiting.length > 0) {
      const next = this.waiting.shift()!;
      this.permits--;
      next();
    }
  }
}
```

## Response Format

### Success Response

```json
{
  "success": true,
  "data": {
    "deleted_flow": {
      "id": "flow_abc123def456",
      "name": "User Onboarding Flow",
      "version": 3,
      "deleted_at": "2024-01-20T10:30:00Z",
      "deleted_by": {
        "id": "user_abcdef1234567890",
        "name": "John Doe",
        "email": "john@company.com"
      }
    },
    "impact_summary": {
      "executions_cancelled": 2,
      "dependent_flows_affected": 0,
      "scheduled_triggers_removed": 1,
      "webhook_subscriptions_removed": 3
    },
    "backup_info": {
      "backup_id": "backup_flow_abc123def456_20240120_103000",
      "backup_location": "s3://tolstoy-backups/flows/backup_flow_abc123def456_20240120_103000.json",
      "expires_at": "2024-07-20T10:30:00Z",
      "restore_instructions": "Use POST /flows/restore with backup_id to restore this flow"
    },
    "cleanup_actions": [
      "Cancelled 2 running executions",
      "Removed scheduled trigger 'daily-report'",
      "Deleted 3 webhook subscriptions",
      "Cleared 15 cached flow definitions"
    ]
  },
  "metadata": {
    "request_id": "req_xyz789abc123",
    "timestamp": "2024-01-20T10:30:00Z",
    "processing_time_ms": 1250
  }
}
```

### Success with Warnings

```json
{
  "success": true,
  "warnings": [
    {
      "code": "ACTIVE_EXECUTIONS_CANCELLED",
      "message": "2 active executions were cancelled",
      "details": {
        "cancelled_executions": [
          "exec_abc123",
          "exec_def456"
        ]
      }
    },
    {
      "code": "WEBHOOK_SUBSCRIPTIONS_REMOVED",
      "message": "Flow had webhook subscriptions that were automatically removed",
      "details": {
        "removed_webhooks": [
          "webhook_123",
          "webhook_456",
          "webhook_789"
        ]
      }
    }
  ],
  "data": {
    // ... success response data
  }
}
```

## Error Handling

### Common Error Responses

<CodeGroup>
```json 404 - Flow Not Found
{
  "success": false,
  "error": {
    "code": "FLOW_NOT_FOUND",
    "message": "Flow with ID 'flow_abc123def456' not found",
    "details": {
      "flow_id": "flow_abc123def456",
      "possible_reasons": [
        "Flow has already been deleted",
        "Flow ID is incorrect",
        "You don't have access to this flow"
      ]
    }
  }
}
```

```json 409 - Flow Has Dependencies
{
  "success": false,
  "error": {
    "code": "FLOW_HAS_DEPENDENCIES",
    "message": "Cannot delete flow because it has active dependencies",
    "details": {
      "dependencies": [
        {
          "type": "scheduled_trigger",
          "id": "trigger_daily_report",
          "name": "Daily Report Generator",
          "description": "Automatically runs this flow every day at 9 AM"
        },
        {
          "type": "webhook_subscription",
          "id": "webhook_user_signup", 
          "name": "User Signup Webhook",
          "description": "Triggers this flow when users sign up"
        },
        {
          "type": "parent_flow",
          "id": "flow_parent_xyz789",
          "name": "Master User Workflow",
          "description": "This flow is called as a sub-workflow"
        }
      ],
      "suggested_actions": [
        "Use force=true to delete despite dependencies",
        "Remove dependencies first, then delete",
        "Disable the flow instead of deleting"
      ]
    }
  }
}
```

```json 423 - Active Executions Running
{
  "success": false,
  "error": {
    "code": "ACTIVE_EXECUTIONS_RUNNING",
    "message": "Cannot delete flow while executions are running",
    "details": {
      "active_executions": [
        {
          "execution_id": "exec_abc123",
          "started_at": "2024-01-20T10:28:30Z",
          "current_step": "send-welcome-email",
          "estimated_completion": "2024-01-20T10:31:00Z"
        },
        {
          "execution_id": "exec_def456",
          "started_at": "2024-01-20T10:29:15Z",
          "current_step": "create-crm-contact",
          "estimated_completion": "2024-01-20T10:32:30Z"
        }
      ],
      "total_active": 2,
      "suggested_actions": [
        "Wait for executions to complete",
        "Use cancel_executions=true to force cancellation",
        "Use force=true to delete despite active executions"
      ]
    }
  }
}
```

```json 403 - Insufficient Permissions
{
  "success": false,
  "error": {
    "code": "INSUFFICIENT_PERMISSIONS",
    "message": "You don't have permission to delete this flow",
    "details": {
      "required_permission": "flow:delete",
      "your_permissions": ["flow:read", "flow:execute"],
      "flow_owner": {
        "id": "user_xyz789",
        "name": "Jane Smith",
        "email": "jane@company.com"
      },
      "contact_admin": true
    }
  }
}
```
</CodeGroup>

## Deletion Safety Checks

### Pre-deletion Validation

Before deletion, the system performs these safety checks:

1. **Permission Check**: Verify user has delete permissions
2. **Dependency Analysis**: Check for dependent flows, triggers, and webhooks
3. **Execution Status**: Identify running executions
4. **Impact Assessment**: Calculate deletion impact
5. **Backup Preparation**: Prepare backup if requested

### Dependency Types

| Dependency Type | Description | Auto-cleanup | Force Override |
|-----------------|-------------|--------------|----------------|
| `scheduled_trigger` | Scheduled execution triggers | ‚úÖ Yes | ‚úÖ Yes |
| `webhook_subscription` | Webhook event subscriptions | ‚úÖ Yes | ‚úÖ Yes |
| `parent_flow` | Flows that call this as sub-flow | ‚ùå No | ‚ö†Ô∏è Risky |
| `api_integration` | External API dependencies | ‚ùå No | ‚ö†Ô∏è Risky |
| `shared_action` | Custom actions used by other flows | ‚ùå No | ‚ùå No |

### Force Deletion Behavior

When using `force=true`:

- **Cancels active executions** (if `cancel_executions=true`)
- **Removes scheduled triggers** automatically  
- **Deletes webhook subscriptions** automatically
- **Breaks parent flow references** (may cause failures)
- **Creates backup automatically** (unless `backup=false`)

## Recovery Options

### Backup and Restore

```typescript
async function restoreDeletedFlow(backupId: string) {
  try {
    const restoredFlow = await client.flows.restore({
      backup_id: backupId,
      restore_options: {
        new_name: 'Restored Flow',
        preserve_id: false,
        activate_immediately: false
      }
    });
    
    console.log(`Flow restored as: ${restoredFlow.name} (${restoredFlow.id})`);
    return restoredFlow;
    
  } catch (error) {
    console.error('Failed to restore flow:', error);
    throw error;
  }
}
```

### Soft Deletion Alternative

Instead of permanent deletion, consider deactivation:

```typescript
async function softDeleteFlow(flowId: string) {
  // Disable the flow instead of deleting
  await client.flows.update(flowId, {
    status: 'inactive',
    tags: [...(await client.flows.get(flowId)).tags, 'soft-deleted']
  });
  
  console.log('Flow deactivated (soft deleted)');
}
```

## Best Practices

### Safe Deletion Checklist

1. **Review Dependencies**: Check what depends on this flow
2. **Backup First**: Always create backups of important flows
3. **Check Execution History**: Review execution statistics
4. **Notify Stakeholders**: Inform teams using this flow
5. **Plan Recovery**: Have a restoration plan if needed
6. **Monitor Impact**: Watch for broken integrations after deletion

### Batch Deletion Strategy

1. **Analyze First**: Run with `dryRun=true` to understand impact
2. **Start Small**: Begin with test/development flows
3. **Monitor Progress**: Check for issues during bulk operations
4. **Handle Failures**: Have recovery plans for failed deletions
5. **Clean Dependencies**: Remove dependent resources systematically

## Rate Limits

| Operation | Limit | Window | Notes |
|-----------|-------|---------|-------|
| Flow Deletion | 20 | 1 hour | Per user |
| Force Deletion | 5 | 1 hour | Higher impact operations |
| Bulk Operations | 100 flows | 1 request | Maximum flows per batch |

## Related Endpoints

<CardGroup cols={2}>
  <Card title="List Flows" icon="list" href="/api/resources/flows/list-flows">
    View flows before deciding which to delete
  </Card>
  <Card title="Get Flow" icon="eye" href="/api/resources/flows/get-flow">
    Review flow details before deletion
  </Card>
</CardGroup>

<CardGroup cols={2}>
  <Card title="Update Flow" icon="edit" href="/api/resources/flows/update-flow">
    Consider deactivation instead of deletion
  </Card>
  <Card title="Restore Flow" icon="history" href="/api/resources/flows/restore-flow">
    Restore flows from backups
  </Card>
</CardGroup>

---

*Use the Delete Flow endpoint carefully with comprehensive safety checks and backup creation. Consider deactivation instead of permanent deletion for flows that might be needed again.*