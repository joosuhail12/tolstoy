---
title: "List Flows"
description: "Retrieve a paginated list of workflows in your organization with filtering, sorting, and search capabilities."
---

# List Flows

Retrieve all workflows in your organization with advanced filtering and pagination options.

## Endpoint

<CodeGroup>
```http HTTP
GET /flows
```

```bash cURL
curl -X GET "https://tolstoy.getpullse.com/flows" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890" \
  -H "Content-Type: application/json"
```
</CodeGroup>

## Query Parameters

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `limit` | integer | Number of flows to return (max 100) | 20 |
| `cursor` | string | Pagination cursor for next page | null |
| `status` | string | Filter by flow status: `active`, `inactive`, `draft` | all |
| `search` | string | Search in flow names and descriptions | null |
| `sort` | string | Sort order: `created_at`, `updated_at`, `name` | `updated_at` |
| `order` | string | Sort direction: `asc`, `desc` | `desc` |
| `tags` | array | Filter by tags (comma-separated) | null |
| `created_after` | string | ISO 8601 datetime filter | null |
| `created_before` | string | ISO 8601 datetime filter | null |

## Examples

### Basic Request

<CodeGroup>
```bash cURL
curl -X GET "https://tolstoy.getpullse.com/flows?limit=10" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890"
```

```typescript TypeScript/Node.js
import { TolstoyClient } from '@joosuhail/tolstoy-sdk';

const client = new TolstoyClient({
  orgId: 'org_1234567890abcdef',
  userId: 'user_abcdef1234567890'
});

const flows = await client.flows.list({
  limit: 10
});

console.log(`Found ${flows.length} flows`);
flows.forEach(flow => {
  console.log(`${flow.id}: ${flow.name}`);
});
```

```python Python
import tolstoy
import os

client = tolstoy.Client(
    org_id='org_1234567890abcdef',
    user_id='user_abcdef1234567890'
)

flows = client.flows.list(limit=10)
print(f"Found {len(flows)} flows")

for flow in flows:
    print(f"{flow.id}: {flow.name}")
```
</CodeGroup>

### Filtered Request

<CodeGroup>
```bash cURL - Active Flows Only
curl -X GET "https://tolstoy.getpullse.com/flows?status=active&sort=name&order=asc" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890"
```

```typescript TypeScript - Search and Filter
const flows = await client.flows.list({
  status: 'active',
  search: 'welcome',
  tags: ['onboarding', 'email'],
  limit: 25
});

// Filter flows locally if needed
const recentFlows = flows.filter(flow => {
  const created = new Date(flow.created_at);
  const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
  return created > weekAgo;
});
```

```python Python - Date Range Filter
from datetime import datetime, timedelta

# Get flows created in the last week
week_ago = (datetime.now() - timedelta(days=7)).isoformat()

flows = client.flows.list(
    status='active',
    created_after=week_ago,
    sort='created_at',
    order='desc'
)
```
</CodeGroup>

### Pagination

<CodeGroup>
```typescript TypeScript - Iterate All Pages
async function getAllFlows(client: TolstoyClient) {
  let allFlows = [];
  let cursor = null;
  
  do {
    const response = await client.flows.list({
      limit: 100,
      cursor: cursor
    });
    
    allFlows.push(...response.data);
    cursor = response.pagination?.cursor;
    
  } while (response.pagination?.has_more);
  
  return allFlows;
}

const allFlows = await getAllFlows(client);
console.log(`Total flows: ${allFlows.length}`);
```

```python Python - Manual Pagination
def get_all_flows(client):
    all_flows = []
    cursor = None
    
    while True:
        response = client.flows.list(
            limit=100,
            cursor=cursor
        )
        
        all_flows.extend(response['data'])
        
        if not response.get('pagination', {}).get('has_more'):
            break
            
        cursor = response['pagination']['cursor']
    
    return all_flows

all_flows = get_all_flows(client)
print(f"Total flows: {len(all_flows)}")
```

```bash cURL - Next Page
# First request
curl -X GET "https://tolstoy.getpullse.com/flows?limit=20" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890"

# Use cursor from response for next page
curl -X GET "https://tolstoy.getpullse.com/flows?limit=20&cursor=eyJpZCI6ImZsb3dfYWJjMTIzIn0" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890"
```
</CodeGroup>

## Response Format

### Success Response

```json
{
  "success": true,
  "data": [
    {
      "id": "flow_abc123def456",
      "name": "Welcome New User",
      "description": "Automated welcome email and onboarding process",
      "status": "active",
      "version": 2,
      "tags": ["onboarding", "email", "slack"],
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-20T14:22:00Z",
      "created_by": {
        "id": "user_def456ghi789",
        "name": "John Doe",
        "email": "john@company.com"
      },
      "stats": {
        "total_executions": 1547,
        "successful_executions": 1523,
        "failed_executions": 24,
        "success_rate": 0.9845,
        "avg_duration_ms": 2340,
        "last_execution_at": "2024-01-20T16:45:00Z"
      },
      "steps": [
        {
          "key": "validate-email",
          "name": "Validate Email Address",
          "action": "email-validator"
        },
        {
          "key": "send-welcome-email",
          "name": "Send Welcome Email",
          "action": "sendgrid-send"
        },
        {
          "key": "notify-slack",
          "name": "Notify Team",
          "action": "slack-post"
        }
      ]
    },
    {
      "id": "flow_ghi789jkl012",
      "name": "Payment Processing",
      "description": "Handle payment processing and receipt generation",
      "status": "active",
      "version": 1,
      "tags": ["payments", "billing", "receipts"],
      "created_at": "2024-01-10T08:15:00Z",
      "updated_at": "2024-01-18T11:30:00Z",
      "created_by": {
        "id": "user_mno345pqr678",
        "name": "Jane Smith",
        "email": "jane@company.com"
      },
      "stats": {
        "total_executions": 892,
        "successful_executions": 889,
        "failed_executions": 3,
        "success_rate": 0.9966,
        "avg_duration_ms": 1820,
        "last_execution_at": "2024-01-20T15:20:00Z"
      },
      "steps": [
        {
          "key": "validate-payment",
          "name": "Validate Payment Details",
          "action": "stripe-validate"
        },
        {
          "key": "process-payment",
          "name": "Process Payment",
          "action": "stripe-charge"
        },
        {
          "key": "send-receipt",
          "name": "Send Receipt",
          "action": "email-receipt"
        }
      ]
    }
  ],
  "pagination": {
    "limit": 20,
    "cursor": "eyJpZCI6ImZsb3dfZ2hpNzg5amtsMDEyIn0",
    "has_more": true,
    "total_count": 47
  },
  "metadata": {
    "request_id": "req_xyz789abc123",
    "timestamp": "2024-01-20T16:50:00Z",
    "processing_time_ms": 85
  }
}
```

### Response Fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique flow identifier |
| `name` | string | Flow display name |
| `description` | string | Flow description |
| `status` | string | Current status: `active`, `inactive`, `draft` |
| `version` | integer | Current version number |
| `tags` | array | Associated tags for categorization |
| `created_at` | string | ISO 8601 creation timestamp |
| `updated_at` | string | ISO 8601 last update timestamp |
| `created_by` | object | User who created the flow |
| `stats` | object | Execution statistics and metrics |
| `steps` | array | Summary of flow steps (name and action only) |

## Advanced Filtering

### Complex Queries

<CodeGroup>
```typescript TypeScript - Multi-criteria Filter
interface FlowFilter {
  status?: 'active' | 'inactive' | 'draft';
  search?: string;
  tags?: string[];
  created_after?: string;
  created_before?: string;
  has_failures?: boolean;
  min_executions?: number;
}

async function findFlows(client: TolstoyClient, filter: FlowFilter) {
  let queryParams: any = {
    limit: 100,
    ...filter
  };
  
  // Convert boolean filters to server format
  if (filter.has_failures !== undefined) {
    queryParams.has_failures = filter.has_failures;
  }
  
  const flows = await client.flows.list(queryParams);
  
  // Client-side filtering for unsupported server filters
  let filteredFlows = flows.data;
  
  if (filter.min_executions) {
    filteredFlows = filteredFlows.filter(
      flow => flow.stats.total_executions >= filter.min_executions!
    );
  }
  
  return filteredFlows;
}

// Usage examples
const highVolumeFlows = await findFlows(client, {
  status: 'active',
  min_executions: 1000,
  created_after: '2024-01-01T00:00:00Z'
});

const troubledFlows = await findFlows(client, {
  has_failures: true,
  created_after: '2024-01-15T00:00:00Z'
});
```

```python Python - Custom Filter Class
class FlowFilter:
    def __init__(self, client):
        self.client = client
        self.filters = {}
        
    def status(self, status):
        self.filters['status'] = status
        return self
        
    def search(self, query):
        self.filters['search'] = query
        return self
        
    def tags(self, tags):
        self.filters['tags'] = ','.join(tags) if isinstance(tags, list) else tags
        return self
        
    def date_range(self, start, end=None):
        self.filters['created_after'] = start
        if end:
            self.filters['created_before'] = end
        return self
        
    def success_rate_above(self, rate):
        self._post_filters = getattr(self, '_post_filters', [])
        self._post_filters.append(
            lambda flow: flow['stats']['success_rate'] >= rate
        )
        return self
        
    def execute(self):
        flows = self.client.flows.list(**self.filters)
        
        # Apply post-filters
        if hasattr(self, '_post_filters'):
            for filter_func in self._post_filters:
                flows['data'] = [f for f in flows['data'] if filter_func(f)]
                
        return flows['data']

# Usage
filter = FlowFilter(client)
high_quality_flows = (filter
    .status('active')
    .tags(['production', 'critical'])
    .success_rate_above(0.95)
    .date_range('2024-01-01T00:00:00Z')
    .execute()
)
```
</CodeGroup>

### Performance Optimization

<CodeGroup>
```typescript TypeScript - Efficient Bulk Operations
class FlowManager {
  private client: TolstoyClient;
  private cache = new Map<string, any>();
  
  constructor(client: TolstoyClient) {
    this.client = client;
  }
  
  // Batch load flows with caching
  async loadFlowsBatch(ids: string[]) {
    const uncachedIds = ids.filter(id => !this.cache.has(id));
    
    if (uncachedIds.length > 0) {
      // Note: This would require a batch endpoint
      const flows = await Promise.all(
        uncachedIds.map(id => this.client.flows.get(id))
      );
      
      flows.forEach(flow => {
        this.cache.set(flow.id, flow);
      });
    }
    
    return ids.map(id => this.cache.get(id));
  }
  
  // Get flows with smart caching
  async getFlowsWithCache(options: any = {}) {
    const cacheKey = JSON.stringify(options);
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    
    const flows = await this.client.flows.list(options);
    this.cache.set(cacheKey, flows);
    
    // Auto-expire cache after 5 minutes
    setTimeout(() => {
      this.cache.delete(cacheKey);
    }, 5 * 60 * 1000);
    
    return flows;
  }
}

const manager = new FlowManager(client);
const flows = await manager.getFlowsWithCache({ status: 'active' });
```
</CodeGroup>

## Error Handling

### Common Error Responses

<CodeGroup>
```json 400 - Bad Request
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid query parameters",
    "details": {
      "limit": "Must be between 1 and 100",
      "status": "Must be one of: active, inactive, draft"
    }
  },
  "metadata": {
    "request_id": "req_error123",
    "timestamp": "2024-01-20T16:50:00Z"
  }
}
```

```json 401 - Unauthorized
{
  "success": false,
  "error": {
    "code": "UNAUTHORIZED",
    "message": "Missing or invalid authentication headers",
    "details": {
      "required_headers": ["x-org-id", "x-user-id"]
    }
  }
}
```

```json 429 - Rate Limited
{
  "success": false,
  "error": {
    "code": "RATE_LIMITED", 
    "message": "Too many requests. Please try again later.",
    "details": {
      "retry_after": 60,
      "limit": 1000,
      "window": 3600
    }
  }
}
```
</CodeGroup>

### Error Handling Best Practices

<CodeGroup>
```typescript TypeScript - Robust Error Handling
import { TolstoyApiError, RateLimitError } from '@joosuhail/tolstoy-sdk';

async function getFlowsWithRetry(client: TolstoyClient, options: any, maxRetries = 3) {
  let attempt = 0;
  
  while (attempt < maxRetries) {
    try {
      return await client.flows.list(options);
    } catch (error) {
      attempt++;
      
      if (error instanceof RateLimitError) {
        // Respect rate limit retry-after header
        const retryAfter = error.retryAfter || 60;
        console.log(`Rate limited. Waiting ${retryAfter}s before retry ${attempt}/${maxRetries}`);
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
        continue;
      }
      
      if (error instanceof TolstoyApiError && error.status >= 500) {
        // Server error - retry with exponential backoff
        const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
        console.log(`Server error. Retrying in ${delay}ms (attempt ${attempt}/${maxRetries})`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      
      // Client error or max retries reached - don't retry
      throw error;
    }
  }
}

// Usage
try {
  const flows = await getFlowsWithRetry(client, { status: 'active' });
  console.log(`Retrieved ${flows.data.length} flows`);
} catch (error) {
  console.error('Failed to retrieve flows after retries:', error);
}
```
</CodeGroup>

## Rate Limits

The List Flows endpoint has the following rate limits:

| Limit Type | Requests | Window | Notes |
|------------|----------|---------|--------|
| Per User | 2000 | 1 hour | Individual user limit |
| Per Organization | 10000 | 1 hour | Organization-wide limit |
| Burst Limit | 100 | 1 minute | Short-term burst protection |

**Headers in Response:**
```http
X-RateLimit-Limit: 2000
X-RateLimit-Remaining: 1847
X-RateLimit-Reset: 1642694400
X-RateLimit-Window: 3600
```

## Related Endpoints

<CardGroup cols={2}>
  <Card title="Get Flow" icon="document" href="/api/resources/flows/get-flow">
    Retrieve detailed information about a specific flow
  </Card>
  <Card title="Create Flow" icon="plus" href="/api/resources/flows/create-flow">
    Create a new workflow from a definition
  </Card>
</CardGroup>

<CardGroup cols={2}>
  <Card title="Execute Flow" icon="play" href="/api/resources/flows/execute-flow">
    Execute a workflow with input parameters
  </Card>
  <Card title="Flow Executions" icon="list" href="/api/resources/flows/executions/list-executions">
    List execution history for flows
  </Card>
</CardGroup>

---

*Use the List Flows endpoint to discover, filter, and manage your workflows programmatically. Combine with other endpoints for complete workflow automation.*