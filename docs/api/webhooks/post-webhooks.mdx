---
title: "Create Webhook"
openapi: "POST /webhooks"
---

# Create Webhook

Create a new webhook to receive real-time notifications about events in your Tolstoy workflows. Webhooks enable event-driven integrations, automatic responses to workflow state changes, and seamless connectivity with external systems.

<RequestExample>

```bash cURL
curl -X POST "https://tolstoy.getpullse.com/webhooks" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "GitHub Integration Webhook",
    "description": "Receives workflow completion events for GitHub integrations",
    "url": "https://myapp.com/webhooks/tolstoy-events",
    "method": "POST",
    "events": [
      "flow.completed",
      "flow.failed",
      "flow.step_failed"
    ],
    "headers": {
      "User-Agent": "Tolstoy-Webhook/1.0",
      "X-Source": "tolstoy-platform"
    },
    "authentication": {
      "type": "signature",
      "algorithm": "hmac-sha256",
      "secret": "my_webhook_secret_key_123"
    },
    "retry_policy": {
      "max_attempts": 5,
      "backoff_strategy": "exponential",
      "initial_delay_ms": 1000,
      "max_delay_ms": 30000
    },
    "timeout_ms": 15000,
    "verify_ssl": true,
    "active": true
  }'
```

```typescript TypeScript
interface CreateWebhookRequest {
  name: string;
  description?: string;
  url: string;
  method?: 'POST' | 'PUT' | 'PATCH';
  events: string[];
  headers?: Record<string, string>;
  authentication?: {
    type: 'none' | 'signature' | 'basic' | 'bearer';
    algorithm?: 'hmac-sha256' | 'hmac-sha512';
    secret?: string;
    username?: string;
    password?: string;
    token?: string;
  };
  retry_policy?: {
    max_attempts: number;
    backoff_strategy: 'linear' | 'exponential';
    initial_delay_ms: number;
    max_delay_ms: number;
  };
  timeout_ms?: number;
  verify_ssl?: boolean;
  active?: boolean;
  metadata?: Record<string, any>;
}

const createWebhook = async (webhookData: CreateWebhookRequest) => {
  const response = await fetch('https://tolstoy.getpullse.com/webhooks', {
    method: 'POST',
    headers: {
      'x-org-id': 'org_1234567890abcdef',
      'x-user-id': 'user_abcdef1234567890',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(webhookData)
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(`HTTP ${response.status}: ${error.message}`);
  }

  return response.json();
};

// Create a comprehensive workflow monitoring webhook
const workflowWebhook = await createWebhook({
  name: 'Workflow Status Monitor',
  description: 'Monitors all workflow executions for real-time notifications',
  url: 'https://api.mycompany.com/webhooks/tolstoy/workflows',
  events: [
    'flow.started',
    'flow.completed', 
    'flow.failed',
    'flow.cancelled',
    'flow.step_failed'
  ],
  headers: {
    'X-API-Key': process.env.INTERNAL_API_KEY!,
    'X-Webhook-Source': 'tolstoy-platform',
    'Content-Type': 'application/json'
  },
  authentication: {
    type: 'signature',
    algorithm: 'hmac-sha256',
    secret: process.env.WEBHOOK_SECRET!
  },
  retry_policy: {
    max_attempts: 3,
    backoff_strategy: 'exponential',
    initial_delay_ms: 1000,
    max_delay_ms: 10000
  },
  timeout_ms: 10000,
  verify_ssl: true,
  active: true,
  metadata: {
    team: 'platform',
    purpose: 'workflow_monitoring',
    environment: 'production'
  }
});

console.log('Webhook created:', workflowWebhook.data.id);

// Create user activity tracking webhook
const userWebhook = await createWebhook({
  name: 'User Activity Tracker',
  description: 'Tracks user activities for analytics and compliance',
  url: 'https://analytics.mycompany.com/events/user-activity',
  events: [
    'user.created',
    'user.updated', 
    'user.deleted',
    'org.user_added',
    'org.user_removed'
  ],
  headers: {
    'Authorization': `Bearer ${process.env.ANALYTICS_TOKEN}`,
    'X-Event-Source': 'tolstoy'
  },
  authentication: {
    type: 'signature',
    algorithm: 'hmac-sha256',
    secret: process.env.ANALYTICS_WEBHOOK_SECRET!
  },
  timeout_ms: 5000,
  active: true,
  metadata: {
    purpose: 'analytics',
    data_classification: 'internal'
  }
});

console.log('User tracking webhook created:', userWebhook.data.id);
```

```python Python
import requests
import json
import hmac
import hashlib
import time
from typing import Dict, List, Optional, Any

class WebhookManager:
    def __init__(self, org_id: str, user_id: str, base_url: str = "https://tolstoy.getpullse.com"):
        self.org_id = org_id
        self.user_id = user_id
        self.base_url = base_url
        self.headers = {
            'x-org-id': org_id,
            'x-user-id': user_id,
            'Content-Type': 'application/json'
        }

    def create_webhook(
        self,
        name: str,
        url: str,
        events: List[str],
        description: Optional[str] = None,
        method: str = 'POST',
        headers: Optional[Dict[str, str]] = None,
        authentication: Optional[Dict[str, Any]] = None,
        retry_policy: Optional[Dict[str, Any]] = None,
        timeout_ms: int = 30000,
        verify_ssl: bool = True,
        active: bool = True,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Create a new webhook subscription."""
        
        webhook_data = {
            'name': name,
            'url': url,
            'events': events,
            'method': method,
            'timeout_ms': timeout_ms,
            'verify_ssl': verify_ssl,
            'active': active
        }
        
        if description:
            webhook_data['description'] = description
        if headers:
            webhook_data['headers'] = headers
        if authentication:
            webhook_data['authentication'] = authentication
        if retry_policy:
            webhook_data['retry_policy'] = retry_policy
        if metadata:
            webhook_data['metadata'] = metadata

        response = requests.post(
            f"{self.base_url}/webhooks",
            headers=self.headers,
            json=webhook_data
        )
        response.raise_for_status()
        return response.json()

    def create_workflow_monitoring_webhook(
        self,
        endpoint_url: str,
        secret_key: str,
        include_step_events: bool = True
    ) -> Dict[str, Any]:
        """Create a webhook optimized for workflow monitoring."""
        
        events = ['flow.started', 'flow.completed', 'flow.failed', 'flow.cancelled']
        if include_step_events:
            events.extend(['flow.step_completed', 'flow.step_failed'])
        
        return self.create_webhook(
            name=f"Workflow Monitor - {int(time.time())}",
            description="Comprehensive workflow execution monitoring",
            url=endpoint_url,
            events=events,
            headers={
                'X-Webhook-Type': 'workflow-monitoring',
                'X-Timestamp': str(int(time.time()))
            },
            authentication={
                'type': 'signature',
                'algorithm': 'hmac-sha256',
                'secret': secret_key
            },
            retry_policy={
                'max_attempts': 5,
                'backoff_strategy': 'exponential',
                'initial_delay_ms': 2000,
                'max_delay_ms': 60000
            },
            timeout_ms: 15000,
            metadata={
                'purpose': 'monitoring',
                'created_by': 'workflow_manager',
                'environment': 'production'
            }
        )

    def create_integration_webhook(
        self,
        integration_name: str,
        webhook_url: str,
        api_key: str
    ) -> Dict[str, Any]:
        """Create a webhook for third-party integrations."""
        
        return self.create_webhook(
            name=f"{integration_name} Integration Webhook",
            description=f"Webhook for {integration_name} integration events",
            url=webhook_url,
            events=[
                'tool.connected',
                'tool.failed',
                'tool.updated',
                'flow.completed',
                'flow.failed'
            ],
            headers={
                'Authorization': f'Bearer {api_key}',
                'X-Integration': integration_name.lower(),
                'X-Source': 'tolstoy-platform'
            },
            authentication={
                'type': 'signature',
                'algorithm': 'hmac-sha256',
                'secret': f"{integration_name}_{api_key[:8]}"
            },
            retry_policy={
                'max_attempts': 3,
                'backoff_strategy': 'linear',
                'initial_delay_ms': 5000,
                'max_delay_ms': 15000
            },
            timeout_ms: 20000,
            metadata={
                'integration': integration_name,
                'type': 'third_party'
            }
        )

    def create_analytics_webhook(
        self,
        analytics_endpoint: str,
        tracking_id: str
    ) -> Dict[str, Any]:
        """Create a webhook for analytics and reporting."""
        
        return self.create_webhook(
            name="Analytics Data Webhook",
            description="Sends events to analytics platform for reporting",
            url=analytics_endpoint,
            events=[
                'flow.started',
                'flow.completed',
                'flow.failed',
                'user.created',
                'user.updated',
                'org.user_added'
            ],
            headers={
                'X-Analytics-ID': tracking_id,
                'X-Data-Source': 'tolstoy',
                'X-Event-Version': '1.0'
            },
            authentication={
                'type': 'signature',
                'algorithm': 'hmac-sha256',
                'secret': f"analytics_{tracking_id}"
            },
            timeout_ms: 8000,
            metadata={
                'purpose': 'analytics',
                'data_retention': '2_years',
                'compliance': 'gdpr_compliant'
            }
        )

    def verify_webhook_signature(
        self,
        payload: str,
        signature: str,
        secret: str,
        algorithm: str = 'hmac-sha256'
    ) -> bool:
        """Verify webhook signature for security."""
        
        if algorithm == 'hmac-sha256':
            expected_signature = hmac.new(
                secret.encode('utf-8'),
                payload.encode('utf-8'),
                hashlib.sha256
            ).hexdigest()
        elif algorithm == 'hmac-sha512':
            expected_signature = hmac.new(
                secret.encode('utf-8'),
                payload.encode('utf-8'),
                hashlib.sha512
            ).hexdigest()
        else:
            raise ValueError(f"Unsupported algorithm: {algorithm}")
        
        return hmac.compare_digest(signature, expected_signature)

# Usage examples
webhook_manager = WebhookManager('org_1234567890abcdef', 'user_abcdef1234567890')

# Create workflow monitoring webhook
workflow_webhook = webhook_manager.create_workflow_monitoring_webhook(
    endpoint_url='https://monitoring.company.com/webhooks/tolstoy',
    secret_key='super_secure_secret_key_123',
    include_step_events=True
)
print(f"Workflow webhook created: {workflow_webhook['data']['id']}")

# Create integration webhook for Slack
slack_webhook = webhook_manager.create_integration_webhook(
    integration_name='Slack',
    webhook_url='https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK',
    api_key='xoxb-your-slack-bot-token'
)
print(f"Slack webhook created: {slack_webhook['data']['id']}")

# Create analytics webhook
analytics_webhook = webhook_manager.create_analytics_webhook(
    analytics_endpoint='https://analytics.company.com/events',
    tracking_id='tolstoy_prod_2024'
)
print(f"Analytics webhook created: {analytics_webhook['data']['id']}")

# Example webhook signature verification
payload = '{"event": "flow.completed", "data": {...}}'
signature = 'abc123def456...'
secret = 'your_webhook_secret'

is_valid = webhook_manager.verify_webhook_signature(payload, signature, secret)
print(f"Signature valid: {is_valid}")
```

```javascript Node.js
const axios = require('axios');
const crypto = require('crypto');

class WebhookClient {
  constructor(orgId, userId, baseUrl = 'https://tolstoy.getpullse.com') {
    this.orgId = orgId;
    this.userId = userId;
    this.baseUrl = baseUrl;
    this.headers = {
      'x-org-id': orgId,
      'x-user-id': userId,
      'Content-Type': 'application/json'
    };
  }

  async createWebhook(config) {
    const {
      name,
      description,
      url,
      method = 'POST',
      events,
      headers,
      authentication,
      retry_policy,
      timeout_ms = 30000,
      verify_ssl = true,
      active = true,
      metadata
    } = config;

    const webhookData = {
      name,
      url,
      method,
      events,
      timeout_ms,
      verify_ssl,
      active
    };

    if (description) webhookData.description = description;
    if (headers) webhookData.headers = headers;
    if (authentication) webhookData.authentication = authentication;
    if (retry_policy) webhookData.retry_policy = retry_policy;
    if (metadata) webhookData.metadata = metadata;

    try {
      const response = await axios.post(
        `${this.baseUrl}/webhooks`,
        webhookData,
        { headers: this.headers }
      );
      return response.data;
    } catch (error) {
      if (error.response) {
        throw new Error(`Webhook creation failed: ${error.response.status} - ${error.response.data?.error?.message || error.message}`);
      }
      throw error;
    }
  }

  async createSlackNotificationWebhook(slackWebhookUrl, channelConfig = {}) {
    const config = {
      name: 'Slack Notifications',
      description: 'Send workflow and system notifications to Slack channels',
      url: slackWebhookUrl,
      events: [
        'flow.completed',
        'flow.failed',
        'flow.cancelled',
        'tool.failed'
      ],
      headers: {
        'User-Agent': 'Tolstoy-Slack-Integration/1.0'
      },
      authentication: {
        type: 'none'  // Slack webhooks don't require signature auth
      },
      retry_policy: {
        max_attempts: 3,
        backoff_strategy: 'exponential',
        initial_delay_ms: 2000,
        max_delay_ms: 15000
      },
      timeout_ms: 10000,
      metadata: {
        integration: 'slack',
        channels: channelConfig,
        notification_type: 'team_alerts'
      }
    };

    return this.createWebhook(config);
  }

  async createDataPipelineWebhook(dataWarehouseEndpoint, apiKey) {
    const config = {
      name: 'Data Warehouse Pipeline',
      description: 'Stream workflow execution data to data warehouse',
      url: dataWarehouseEndpoint,
      events: [
        'flow.started',
        'flow.completed',
        'flow.failed',
        'flow.step_completed',
        'user.created',
        'org.updated'
      ],
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'X-Data-Source': 'tolstoy-platform',
        'Content-Type': 'application/json'
      },
      authentication: {
        type: 'signature',
        algorithm: 'hmac-sha256',
        secret: crypto.randomBytes(32).toString('hex')
      },
      retry_policy: {
        max_attempts: 5,
        backoff_strategy: 'exponential',
        initial_delay_ms: 1000,
        max_delay_ms: 30000
      },
      timeout_ms: 20000,
      metadata: {
        purpose: 'data_pipeline',
        retention_policy: 'long_term',
        data_classification: 'internal'
      }
    };

    return this.createWebhook(config);
  }

  async createCICD_IntegrationWebhook(cicdPlatform, endpointUrl, credentials) {
    const webhookEvents = [
      'flow.completed',  // Deployment workflows
      'flow.failed',     // Build failures
      'tool.connected',  // Git integrations
      'tool.failed'      // CI/CD tool failures
    ];

    const config = {
      name: `${cicdPlatform} CI/CD Integration`,
      description: `Integration webhook for ${cicdPlatform} pipeline automation`,
      url: endpointUrl,
      events: webhookEvents,
      headers: {
        'X-CI-Platform': cicdPlatform.toLowerCase(),
        'X-Integration-Version': '2.0',
        ...(credentials.apiKey && { 'X-API-Key': credentials.apiKey })
      },
      authentication: {
        type: 'signature',
        algorithm: 'hmac-sha256',
        secret: credentials.webhookSecret
      },
      retry_policy: {
        max_attempts: 4,
        backoff_strategy: 'exponential',
        initial_delay_ms: 3000,
        max_delay_ms: 25000
      },
      timeout_ms: 15000,
      metadata: {
        integration: cicdPlatform.toLowerCase(),
        environment: process.env.NODE_ENV || 'development',
        automated_deployment: true
      }
    };

    return this.createWebhook(config);
  }

  generateWebhookSecret() {
    return crypto.randomBytes(32).toString('hex');
  }

  verifyWebhookSignature(payload, signature, secret, algorithm = 'sha256') {
    const expectedSignature = crypto
      .createHmac(algorithm, secret)
      .update(payload)
      .digest('hex');

    return crypto.timingSafeEqual(
      Buffer.from(signature, 'hex'),
      Buffer.from(expectedSignature, 'hex')
    );
  }

  createWebhookHandler(secret, eventHandlers = {}) {
    return (req, res) => {
      const signature = req.headers['x-tolstoy-signature'];
      const payload = JSON.stringify(req.body);

      // Verify signature
      if (!this.verifyWebhookSignature(payload, signature, secret)) {
        return res.status(401).json({ error: 'Invalid signature' });
      }

      const { event, data, timestamp } = req.body;

      // Handle specific events
      if (eventHandlers[event]) {
        try {
          eventHandlers[event](data, timestamp);
        } catch (error) {
          console.error(`Error handling ${event}:`, error);
          return res.status(500).json({ error: 'Event handler failed' });
        }
      } else {
        console.log(`Unhandled event type: ${event}`);
      }

      res.status(200).json({ 
        received: true, 
        event,
        processedAt: new Date().toISOString() 
      });
    };
  }
}

// Usage examples
const webhookClient = new WebhookClient('org_1234567890abcdef', 'user_abcdef1234567890');

// Create Slack notification webhook
async function setupSlackNotifications() {
  const webhook = await webhookClient.createSlackNotificationWebhook(
    'https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX',
    {
      alerts: '#dev-alerts',
      general: '#dev-activity',
      errors: '#dev-errors'
    }
  );
  console.log('Slack webhook created:', webhook.data.id);
  return webhook;
}

// Create data warehouse integration
async function setupDataPipeline() {
  const webhook = await webhookClient.createDataPipelineWebhook(
    'https://data-warehouse.company.com/webhooks/tolstoy',
    process.env.DATA_WAREHOUSE_API_KEY
  );
  console.log('Data pipeline webhook created:', webhook.data.id);
  return webhook;
}

// Create CI/CD integration
async function setupCICDIntegration() {
  const webhook = await webhookClient.createCICD_IntegrationWebhook(
    'GitHub Actions',
    'https://api.github.com/repos/company/project/dispatches',
    {
      apiKey: process.env.GITHUB_TOKEN,
      webhookSecret: webhookClient.generateWebhookSecret()
    }
  );
  console.log('CI/CD webhook created:', webhook.data.id);
  return webhook;
}

// Express.js webhook handler example
const express = require('express');
const app = express();

app.use(express.json());

const webhookHandler = webhookClient.createWebhookHandler(
  process.env.WEBHOOK_SECRET,
  {
    'flow.completed': (data, timestamp) => {
      console.log(`Workflow ${data.flowId} completed successfully`);
      // Trigger success notifications, update dashboards, etc.
    },
    'flow.failed': (data, timestamp) => {
      console.error(`Workflow ${data.flowId} failed: ${data.error}`);
      // Send alerts, create incident tickets, etc.
    },
    'user.created': (data, timestamp) => {
      console.log(`New user created: ${data.userId}`);
      // Update analytics, send welcome emails, etc.
    }
  }
);

app.post('/webhooks/tolstoy', webhookHandler);
app.listen(3000, () => console.log('Webhook server running on port 3000'));
```

</RequestExample>

## Request Body

<ParamField body="name" type="string" required>
Human-readable name for the webhook. Must be unique within the organization.
</ParamField>

<ParamField body="description" type="string">
Optional description explaining the webhook's purpose and functionality.
</ParamField>

<ParamField body="url" type="string" required>
HTTPS endpoint URL where webhook payloads will be delivered. Must be a valid HTTPS URL.
</ParamField>

<ParamField body="method" type="string" default="POST">
HTTP method for webhook delivery. Supported values: `POST`, `PUT`, `PATCH`
</ParamField>

<ParamField body="events" type="string[]" required>
Array of event types to subscribe to. See [Available Events](#available-events) section for complete list.
</ParamField>

<ParamField body="headers" type="object">
Custom HTTP headers to include with webhook requests. Useful for authentication or routing.
</ParamField>

<ParamField body="authentication" type="object">
Authentication configuration for webhook security
  <Expandable title="Authentication Options">
    <ParamField body="authentication.type" type="string" required>
      Authentication method: `none`, `signature`, `basic`, or `bearer`
    </ParamField>
    <ParamField body="authentication.algorithm" type="string">
      Signature algorithm when using signature auth: `hmac-sha256` or `hmac-sha512`
    </ParamField>
    <ParamField body="authentication.secret" type="string">
      Secret key for signature generation (required for signature auth)
    </ParamField>
    <ParamField body="authentication.username" type="string">
      Username for basic authentication
    </ParamField>
    <ParamField body="authentication.password" type="string">
      Password for basic authentication
    </ParamField>
    <ParamField body="authentication.token" type="string">
      Bearer token for bearer authentication
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="retry_policy" type="object">
Retry configuration for failed webhook deliveries
  <Expandable title="Retry Policy Settings">
    <ParamField body="retry_policy.max_attempts" type="integer" default="3">
      Maximum number of delivery attempts (1-10)
    </ParamField>
    <ParamField body="retry_policy.backoff_strategy" type="string" default="exponential">
      Retry delay strategy: `linear` or `exponential`
    </ParamField>
    <ParamField body="retry_policy.initial_delay_ms" type="integer" default="1000">
      Initial delay before first retry in milliseconds
    </ParamField>
    <ParamField body="retry_policy.max_delay_ms" type="integer" default="30000">
      Maximum delay between retries in milliseconds
    </ParamField>
  </Expandable>
</ParamField>

<ParamField body="timeout_ms" type="integer" default="30000">
Request timeout in milliseconds (1000-60000)
</ParamField>

<ParamField body="verify_ssl" type="boolean" default="true">
Whether to verify SSL certificates for HTTPS endpoints
</ParamField>

<ParamField body="active" type="boolean" default="true">
Whether the webhook should be active immediately after creation
</ParamField>

<ParamField body="metadata" type="object">
Additional metadata for organizational purposes (key-value pairs)
</ParamField>

## Available Events

### Workflow Events
- `flow.started` - Workflow execution began
- `flow.completed` - Workflow finished successfully
- `flow.failed` - Workflow failed with error
- `flow.cancelled` - Workflow was cancelled by user or system
- `flow.timeout` - Workflow exceeded maximum execution time
- `flow.step_completed` - Individual workflow step completed
- `flow.step_failed` - Individual workflow step failed
- `flow.step_skipped` - Workflow step was skipped due to conditions

### Tool Events  
- `tool.connected` - Tool integration established successfully
- `tool.failed` - Tool integration failed or connection lost
- `tool.updated` - Tool configuration or credentials changed
- `tool.deleted` - Tool integration was removed
- `tool.health_check_failed` - Tool health check failed

### Organization Events
- `org.created` - New organization was created
- `org.updated` - Organization settings or profile changed
- `org.deleted` - Organization was deleted
- `org.user_added` - User was added to organization
- `org.user_removed` - User was removed from organization
- `org.user_role_changed` - User's role within organization changed
- `org.subscription_changed` - Organization's subscription plan changed

### User Events
- `user.created` - New user account created
- `user.updated` - User profile or settings updated
- `user.deleted` - User account was deleted
- `user.login` - User successfully logged in
- `user.logout` - User logged out
- `user.password_changed` - User changed their password

### Execution Events
- `execution.queued` - Workflow execution queued for processing
- `execution.dequeued` - Workflow execution removed from queue
- `execution.retry` - Workflow execution is being retried
- `execution.progress` - Progress update during long-running execution

## Response

<ResponseExample>

```json Success Response
{
  "success": true,
  "data": {
    "id": "webhook_1234567890abcdef",
    "name": "GitHub Integration Webhook",
    "description": "Receives workflow completion events for GitHub integrations",
    "url": "https://myapp.com/webhooks/tolstoy-events",
    "method": "POST",
    "status": "active",
    "events": [
      "flow.completed",
      "flow.failed",
      "flow.step_failed"
    ],
    "headers": {
      "User-Agent": "Tolstoy-Webhook/1.0",
      "X-Source": "tolstoy-platform"
    },
    "authentication": {
      "type": "signature",
      "algorithm": "hmac-sha256"
    },
    "retry_policy": {
      "max_attempts": 5,
      "backoff_strategy": "exponential",
      "initial_delay_ms": 1000,
      "max_delay_ms": 30000
    },
    "timeout_ms": 15000,
    "verify_ssl": true,
    "active": true,
    "metadata": {
      "team": "platform",
      "purpose": "workflow_monitoring",
      "environment": "production"
    },
    "created_by": {
      "id": "user_abcdef1234567890",
      "name": "John Doe",
      "email": "john@company.com"
    },
    "created_at": "2024-01-15T10:30:00Z",
    "updated_at": "2024-01-15T10:30:00Z"
  },
  "metadata": {
    "request_id": "req_webhook_create_123",
    "timestamp": "2024-01-15T10:30:00Z",
    "execution_time_ms": 245
  }
}
```

```json Validation Error Response
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid webhook configuration",
    "details": [
      {
        "field": "url",
        "message": "URL must be a valid HTTPS endpoint"
      },
      {
        "field": "events",
        "message": "At least one event type must be specified"
      },
      {
        "field": "authentication.secret",
        "message": "Secret is required when using signature authentication"
      }
    ]
  },
  "metadata": {
    "request_id": "req_webhook_error_456",
    "timestamp": "2024-01-15T10:30:00Z"
  }
}
```

</ResponseExample>

## Status Codes

<ResponseField name="201" type="Created">
Webhook created successfully
</ResponseField>

<ResponseField name="400" type="Bad Request">
Invalid request data or validation errors
</ResponseField>

<ResponseField name="401" type="Unauthorized">
Missing or invalid authentication credentials
</ResponseField>

<ResponseField name="403" type="Forbidden">
Insufficient permissions to create webhooks
</ResponseField>

<ResponseField name="409" type="Conflict">
Webhook with the same name already exists
</ResponseField>

<ResponseField name="429" type="Too Many Requests">
Rate limit exceeded
</ResponseField>

<ResponseField name="500" type="Internal Server Error">
Server error occurred while creating webhook
</ResponseField>

## Webhook Payload Structure

When events occur, Tolstoy sends HTTP requests to your webhook URL with the following payload structure:

### Standard Payload Format

```json
{
  "webhook_id": "webhook_1234567890abcdef",
  "event": "flow.completed",
  "event_id": "evt_unique_identifier_123",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": {
    // Event-specific data (varies by event type)
  },
  "metadata": {
    "org_id": "org_1234567890abcdef",
    "user_id": "user_abcdef1234567890",
    "source": "tolstoy-platform",
    "version": "1.0"
  }
}
```

### Workflow Event Payload Example

```json
{
  "webhook_id": "webhook_1234567890abcdef",
  "event": "flow.completed",
  "event_id": "evt_flow_comp_789",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": {
    "flow_id": "flow_abc123def456",
    "execution_id": "exec_789xyz012",
    "flow_name": "Customer Onboarding",
    "status": "completed",
    "duration_ms": 45000,
    "steps_completed": 5,
    "steps_total": 5,
    "inputs": {
      "customer_email": "customer@example.com",
      "plan": "premium"
    },
    "outputs": {
      "account_id": "acc_new123",
      "welcome_email_sent": true,
      "subscription_created": true
    }
  },
  "metadata": {
    "org_id": "org_1234567890abcdef",
    "user_id": "user_abcdef1234567890",
    "source": "tolstoy-platform",
    "version": "1.0"
  }
}
```

### Tool Event Payload Example

```json
{
  "webhook_id": "webhook_1234567890abcdef",
  "event": "tool.connected",
  "event_id": "evt_tool_conn_456",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": {
    "tool_id": "tool_github_789",
    "tool_name": "GitHub API",
    "tool_type": "github",
    "connection_status": "active",
    "last_tested_at": "2024-01-15T10:29:45Z",
    "configuration": {
      "repository": "company/project",
      "permissions": ["read", "write"]
    }
  },
  "metadata": {
    "org_id": "org_1234567890abcdef",
    "user_id": "user_abcdef1234567890",
    "source": "tolstoy-platform",
    "version": "1.0"
  }
}
```

## Security Best Practices

### Signature Verification

Always verify webhook signatures to ensure requests come from Tolstoy:

```javascript
const crypto = require('crypto');

function verifyTolstoySignature(payload, signature, secret) {
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload, 'utf8')
    .digest('hex');
  
  const signatureBuffer = Buffer.from(signature, 'hex');
  const expectedBuffer = Buffer.from(expectedSignature, 'hex');
  
  return crypto.timingSafeEqual(signatureBuffer, expectedBuffer);
}

// Express middleware example
function validateWebhook(secret) {
  return (req, res, next) => {
    const signature = req.headers['x-tolstoy-signature'];
    const payload = JSON.stringify(req.body);
    
    if (!signature || !verifyTolstoySignature(payload, signature, secret)) {
      return res.status(401).json({ error: 'Invalid signature' });
    }
    
    next();
  };
}
```

### HTTPS Endpoints

- Always use HTTPS endpoints for webhook URLs
- Ensure your SSL certificate is valid and trusted
- Consider using certificate pinning for additional security

### Rate Limiting

Implement rate limiting on your webhook endpoints to prevent abuse:

```javascript
const rateLimit = require('express-rate-limit');

const webhookLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 1000, // Limit to 1000 requests per windowMs
  message: 'Too many webhook requests',
  standardHeaders: true,
  legacyHeaders: false
});

app.use('/webhooks/tolstoy', webhookLimiter);
```

### Idempotency

Implement idempotency to handle duplicate webhook deliveries:

```javascript
const processedEvents = new Set();

app.post('/webhooks/tolstoy', (req, res) => {
  const eventId = req.body.event_id;
  
  if (processedEvents.has(eventId)) {
    return res.status(200).json({ message: 'Event already processed' });
  }
  
  // Process the webhook
  processWebhookEvent(req.body);
  
  // Remember this event ID
  processedEvents.add(eventId);
  
  res.status(200).json({ message: 'Event processed successfully' });
});
```

## Examples

### Team Notification Setup

<CodeGroup>

```bash Create Slack Webhook
curl -X POST "https://tolstoy.getpullse.com/webhooks" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Team Slack Notifications",
    "description": "Send workflow status updates to #dev-alerts channel",
    "url": "https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX",
    "events": ["flow.completed", "flow.failed", "tool.failed"],
    "active": true
  }'
```

```python Monitoring Integration
webhook_manager = WebhookManager('org_1234567890abcdef', 'user_abcdef1234567890')

monitoring_webhook = webhook_manager.create_webhook(
    name='System Monitoring',
    description='Send events to monitoring dashboard',
    url='https://monitoring.company.com/webhooks/tolstoy',
    events=[
        'flow.started',
        'flow.completed',
        'flow.failed',
        'tool.health_check_failed'
    ],
    headers={
        'X-Monitor-Source': 'tolstoy',
        'Authorization': f'Bearer {os.environ["MONITORING_TOKEN"]}'
    },
    authentication={
        'type': 'signature',
        'algorithm': 'hmac-sha256',
        'secret': os.environ['WEBHOOK_SECRET']
    },
    retry_policy={
        'max_attempts': 5,
        'backoff_strategy': 'exponential',
        'initial_delay_ms': 2000,
        'max_delay_ms': 60000
    },
    timeout_ms: 15000
)
```

</CodeGroup>

### Analytics Pipeline

<CodeGroup>

```typescript Data Warehouse Integration
const analyticsWebhook = await createWebhook({
  name: 'Analytics Data Pipeline',
  description: 'Stream workflow and user events to data warehouse',
  url: 'https://data-warehouse.company.com/api/events',
  events: [
    'flow.started',
    'flow.completed',
    'flow.failed',
    'user.created',
    'user.updated',
    'org.user_added',
    'org.subscription_changed'
  ],
  headers: {
    'Authorization': `Bearer ${process.env.ANALYTICS_API_KEY}`,
    'X-Data-Source': 'tolstoy-platform',
    'X-Environment': process.env.NODE_ENV
  },
  authentication: {
    type: 'signature',
    algorithm: 'hmac-sha256',
    secret: process.env.ANALYTICS_WEBHOOK_SECRET
  },
  timeout_ms: 10000,
  metadata: {
    purpose: 'analytics',
    retention_period: '7_years',
    compliance: 'sox_gdpr'
  }
});
```

```javascript Event Processing Handler
const express = require('express');
const app = express();

app.use(express.json());

app.post('/webhooks/tolstoy/analytics', validateWebhook(process.env.WEBHOOK_SECRET), (req, res) => {
  const { event, data, timestamp } = req.body;

  switch (event) {
    case 'flow.completed':
      // Track workflow completion metrics
      analytics.track('workflow_completed', {
        flow_id: data.flow_id,
        duration_ms: data.duration_ms,
        steps_total: data.steps_total,
        timestamp
      });
      break;

    case 'user.created':
      // Track new user registration
      analytics.identify(data.user_id, {
        email: data.email,
        org_id: data.org_id,
        created_at: timestamp
      });
      break;

    case 'org.subscription_changed':
      // Track subscription changes for revenue analytics
      analytics.track('subscription_changed', {
        org_id: data.org_id,
        old_plan: data.old_plan,
        new_plan: data.new_plan,
        mrr_change: data.mrr_change,
        timestamp
      });
      break;
  }

  res.status(200).json({ processed: true });
});
```

</CodeGroup>

## Best Practices

### Webhook Design

<Accordion title="Event Selection">
- Subscribe only to events you actually need to reduce noise
- Use specific event types rather than broad categories
- Monitor webhook delivery volume and adjust subscriptions as needed
- Consider creating separate webhooks for different purposes (monitoring vs analytics)
</Accordion>

<Accordion title="Error Handling">
- Return HTTP 2xx status codes for successful processing
- Return appropriate error codes (4xx for client errors, 5xx for server errors)
- Implement graceful degradation when external dependencies fail
- Log webhook failures for debugging and monitoring
</Accordion>

### Performance Optimization

<Accordion title="Response Times">
- Process webhooks asynchronously to avoid timeouts
- Return success responses quickly (under 5 seconds)
- Use queuing systems for complex processing
- Implement health checks for webhook endpoints
</Accordion>

<Accordion title="Scalability">
- Design webhook handlers to be stateless
- Use database transactions for critical operations
- Implement horizontal scaling for high-volume webhooks
- Consider webhook batching for bulk operations
</Accordion>

## Common Use Cases

### CI/CD Pipeline Integration

Monitor deployment workflows and trigger downstream processes based on completion status.

### Real-time Notifications

Send instant alerts to team communication channels when critical workflows fail.

### Data Synchronization

Keep external systems synchronized with workflow execution results and user changes.

### Compliance Auditing

Track all system events for compliance reporting and audit trail maintenance.

## Related Endpoints

<CardGroup cols={2}>
  <Card title="List Webhooks" icon="list" href="/api/webhooks/get-webhooks">
    View all configured webhooks
  </Card>
  <Card title="Get Webhook" icon="info" href="/api/webhooks/get-webhooks-1">
    Get detailed webhook information
  </Card>
</CardGroup>

<CardGroup cols={2}>
  <Card title="Test Webhook" icon="test-tube" href="/api/webhooks/post-webhooks-test">
    Test webhook delivery and connectivity
  </Card>
  <Card title="Available Events" icon="calendar" href="/api/webhooks/get-webhooksevent-types">
    View all available event types
  </Card>
</CardGroup>

---

<Info>
**Pro Tip**: Start with a simple webhook that logs all events, then gradually add specific event handlers as you identify useful automation opportunities.
</Info>

## Common Use Cases

### Workflow Completion Notifications
```json
{
  "name": "Workflow Monitor",
  "url": "https://your-app.com/webhooks/workflow-events",
  "events": ["flow.completed", "flow.failed"],
  "active": true,
  "metadata": {
    "purpose": "workflow_monitoring",
    "team": "operations"
  }
}
```

### User Activity Tracking
```json
{
  "name": "User Activity Tracker", 
  "url": "https://analytics.company.com/tolstoy/events",
  "events": ["user.created", "user.updated", "org.user_added"],
  "active": true,
  "headers": {
    "X-Analytics-Key": "your-analytics-key"
  }
}
```

### Integration Monitoring
```json
{
  "name": "Tool Health Monitor",
  "url": "https://monitoring.company.com/webhooks/tools",
  "events": ["tool.connected", "tool.failed"],
  "active": true,
  "timeout": 15000,
  "retries": 3
}
```

## Webhook Security

### Signature Verification
Enable signature verification to ensure webhook authenticity:

```json
{
  "name": "Secure Webhook",
  "url": "https://your-app.com/webhooks/secure",
  "events": ["flow.completed"],
  "secret": "your_webhook_secret_key",
  "active": true
}
```

### HTTPS Enforcement
```json
{
  "name": "HTTPS Only Webhook",
  "url": "https://secure.company.com/webhooks",
  "events": ["flow.started"],
  "verifySSL": true,
  "active": true
}
```

## Webhook Payload Structure

### Workflow Completion Event
```json
{
  "event": "flow.completed",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": {
    "flowId": "flow_abc123",
    "executionId": "exec_def456",
    "status": "completed",
    "duration": 45000,
    "variables": {
      "userId": "user_123",
      "email": "user@example.com"
    },
    "result": {
      "success": true,
      "outputs": {
        "emailSent": true,
        "accountCreated": "acc_789"
      }
    }
  },
  "metadata": {
    "orgId": "org_abc123",
    "userId": "user_123"
  }
}
```

### Tool Connection Event
```json
{
  "event": "tool.connected",
  "timestamp": "2024-01-15T10:30:00Z", 
  "data": {
    "toolId": "tool_ghi789",
    "toolName": "GitHub API",
    "connectionStatus": "active",
    "lastTested": "2024-01-15T10:30:00Z"
  },
  "metadata": {
    "orgId": "org_abc123",
    "userId": "user_123"
  }
}
```

## Response Handling

### Expected Response
Your webhook endpoint should return HTTP 200-299 for successful processing:

```json
{
  "received": true,
  "processedAt": "2024-01-15T10:30:00Z"
}
```

### Error Responses
Non-2xx responses trigger retry attempts:

```json
{
  "error": "Temporary processing error",
  "retryAfter": 300
}
```

## Retry Logic

Tolstoy automatically retries failed webhook deliveries:
- **Initial retry**: After 1 second
- **Subsequent retries**: Exponential backoff (2s, 4s, 8s, 16s, 32s)
- **Maximum attempts**: 5 retries over 24 hours
- **Timeout**: Configurable (default 10 seconds)

## Testing Webhooks

### Test Webhook Delivery
```bash
# Test webhook endpoint
curl -X POST "https://tolstoy.getpullse.com/webhooks/{webhookId}/test" \
  -H "x-org-id: your-org-id" \
  -H "x-user-id: your-user-id"
```

### Webhook Development Tips

1. **Use ngrok for local testing**:
   ```bash
   ngrok http 3000
   # Use the HTTPS URL for webhook endpoint
   ```

2. **Implement idempotency**:
   ```javascript
   app.post('/webhooks/tolstoy', (req, res) => {
     const eventId = req.headers['x-tolstoy-event-id'];
     if (processedEvents.has(eventId)) {
       return res.status(200).send('Already processed');
     }
     
     // Process event
     processedEvents.add(eventId);
     res.status(200).send('OK');
   });
   ```

3. **Verify signatures**:
   ```javascript
   const crypto = require('crypto');
   
   function verifySignature(payload, signature, secret) {
     const expectedSignature = crypto
       .createHmac('sha256', secret)
       .update(payload)
       .digest('hex');
     return crypto.timingSafeEqual(
       Buffer.from(signature),
       Buffer.from(expectedSignature)
     );
   }
   ```

## SDK Integration

Use the TypeScript SDK for webhook management:

```typescript
import { TolstoyClient } from '@joosuhail/tolstoy-sdk';

const client = new TolstoyClient(
  'https://tolstoy.getpullse.com',
  'your-org-id', 
  'your-user-id'
);

// Create webhook
const webhook = await client.createWebhook({
  name: 'Workflow Monitor',
  url: 'https://your-app.com/webhooks/tolstoy',
  events: ['flow.completed', 'flow.failed'],
  active: true,
  secret: process.env.WEBHOOK_SECRET
});

console.log(`Webhook created: ${webhook.data.id}`);

// Test webhook delivery
const testResult = await client.raw.webhooks.webhooksControllerTest(webhook.data.id);
console.log(`Test result: ${testResult.data.success}`);
```

## Related Endpoints

- **[List Webhooks](/api/webhooks/get-webhooks)** - View all webhook configurations
- **[Get Webhook](/api/webhooks/get-webhooks-1)** - Retrieve specific webhook details
- **[Update Webhook](/api/webhooks/put-webhooks)** - Modify webhook settings
- **[Toggle Webhook](/api/webhooks/patch-webhooks-toggle)** - Enable/disable webhook
- **[Test Webhook](/api/webhooks/post-webhooks-test)** - Test webhook delivery
- **[List Event Types](/api/webhooks/get-webhooksevent-types)** - Get available event types

---

*This endpoint supports the interactive playground below with live testing and auto-generated code samples.*