---
title: "List Flow Executions"
openapi: "GET /flows/{id}/executions"
---

# List Flow Executions

Get the execution history for a specific flow. This endpoint provides detailed information about all execution instances of a workflow, including their status, inputs, outputs, and performance metrics.

<RequestExample>

```bash cURL
curl -X GET "https://tolstoy.getpullse.com/flows/flow_abc123def456/executions?limit=50&status=completed" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890" \
  -H "Content-Type: application/json"
```

```typescript TypeScript
interface ListExecutionsParams {
  limit?: number;
  cursor?: string;
  status?: 'queued' | 'running' | 'completed' | 'failed' | 'cancelled' | 'timeout';
  created_after?: string;
  created_before?: string;
  sort_by?: 'created_at' | 'completed_at' | 'duration';
  sort_order?: 'asc' | 'desc';
}

const getFlowExecutions = async (
  flowId: string, 
  params: ListExecutionsParams = {}
) => {
  const searchParams = new URLSearchParams();
  
  Object.entries(params).forEach(([key, value]) => {
    if (value !== undefined) {
      searchParams.set(key, value.toString());
    }
  });

  const response = await fetch(
    `https://tolstoy.getpullse.com/flows/${flowId}/executions?${searchParams}`,
    {
      method: 'GET',
      headers: {
        'x-org-id': 'org_1234567890abcdef',
        'x-user-id': 'user_abcdef1234567890',
        'Content-Type': 'application/json'
      }
    }
  );

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  return response.json();
};

// Get recent executions for a flow
const recentExecutions = await getFlowExecutions('flow_abc123def456', {
  limit: 20,
  sort_by: 'created_at',
  sort_order: 'desc'
});

console.log(`Found ${recentExecutions.data.length} executions`);

// Get failed executions for debugging
const failedExecutions = await getFlowExecutions('flow_abc123def456', {
  status: 'failed',
  limit: 10,
  created_after: '2024-01-01T00:00:00Z'
});

console.log('Failed executions:', failedExecutions.data);
```

```python Python
import requests
from typing import Optional, List, Dict, Any
from datetime import datetime, timezone

class ExecutionsClient:
    def __init__(self, org_id: str, user_id: str, base_url: str = "https://tolstoy.getpullse.com"):
        self.org_id = org_id
        self.user_id = user_id
        self.base_url = base_url
        self.headers = {
            'x-org-id': org_id,
            'x-user-id': user_id,
            'Content-Type': 'application/json'
        }

    def get_flow_executions(
        self,
        flow_id: str,
        limit: int = 20,
        cursor: Optional[str] = None,
        status: Optional[str] = None,
        created_after: Optional[str] = None,
        created_before: Optional[str] = None,
        sort_by: str = 'created_at',
        sort_order: str = 'desc'
    ) -> Dict[str, Any]:
        """Get executions for a specific flow."""
        
        params = {
            'limit': limit,
            'sort_by': sort_by,
            'sort_order': sort_order
        }
        
        if cursor:
            params['cursor'] = cursor
        if status:
            params['status'] = status
        if created_after:
            params['created_after'] = created_after
        if created_before:
            params['created_before'] = created_before

        response = requests.get(
            f"{self.base_url}/flows/{flow_id}/executions",
            headers=self.headers,
            params=params
        )
        response.raise_for_status()
        return response.json()

    def get_all_executions(self, flow_id: str, **filters) -> List[Dict[str, Any]]:
        """Get all executions for a flow using pagination."""
        all_executions = []
        cursor = None

        while True:
            response = self.get_flow_executions(
                flow_id, cursor=cursor, **filters
            )
            
            all_executions.extend(response['data'])
            
            pagination = response.get('pagination', {})
            if not pagination.get('has_more', False):
                break
                
            cursor = pagination.get('cursor')

        return all_executions

    def get_execution_metrics(self, flow_id: str) -> Dict[str, Any]:
        """Get execution metrics and statistics for a flow."""
        executions = self.get_all_executions(flow_id)
        
        if not executions:
            return {'total': 0}

        total = len(executions)
        completed = len([e for e in executions if e['status'] == 'completed'])
        failed = len([e for e in executions if e['status'] == 'failed'])
        
        durations = [
            e['performance']['duration_ms'] 
            for e in executions 
            if e.get('performance', {}).get('duration_ms')
        ]

        return {
            'total_executions': total,
            'completed': completed,
            'failed': failed,
            'success_rate': completed / total if total > 0 else 0,
            'avg_duration_ms': sum(durations) / len(durations) if durations else 0,
            'min_duration_ms': min(durations) if durations else 0,
            'max_duration_ms': max(durations) if durations else 0,
        }

# Usage examples
client = ExecutionsClient('org_1234567890abcdef', 'user_abcdef1234567890')

# Get recent executions
recent = client.get_flow_executions('flow_abc123def456', limit=10)
print(f"Recent executions: {len(recent['data'])}")

# Get failed executions from last week
from datetime import datetime, timedelta
last_week = (datetime.now(timezone.utc) - timedelta(days=7)).isoformat()
failed = client.get_flow_executions(
    'flow_abc123def456',
    status='failed',
    created_after=last_week
)

print(f"Failed executions in last week: {len(failed['data'])}")

# Get execution metrics
metrics = client.get_execution_metrics('flow_abc123def456')
print(f"Success rate: {metrics['success_rate']:.2%}")
print(f"Average duration: {metrics['avg_duration_ms']:.0f}ms")
```

```javascript Node.js
const axios = require('axios');

class FlowExecutionsClient {
  constructor(orgId, userId, baseUrl = 'https://tolstoy.getpullse.com') {
    this.orgId = orgId;
    this.userId = userId;
    this.baseUrl = baseUrl;
    this.headers = {
      'x-org-id': orgId,
      'x-user-id': userId,
      'Content-Type': 'application/json'
    };
  }

  async getFlowExecutions(flowId, options = {}) {
    const {
      limit = 20,
      cursor,
      status,
      created_after,
      created_before,
      sort_by = 'created_at',
      sort_order = 'desc'
    } = options;

    const params = new URLSearchParams({
      limit: limit.toString(),
      sort_by,
      sort_order
    });

    if (cursor) params.set('cursor', cursor);
    if (status) params.set('status', status);
    if (created_after) params.set('created_after', created_after);
    if (created_before) params.set('created_before', created_before);

    try {
      const response = await axios.get(
        `${this.baseUrl}/flows/${flowId}/executions`,
        {
          headers: this.headers,
          params: Object.fromEntries(params)
        }
      );

      return response.data;
    } catch (error) {
      if (error.response) {
        throw new Error(`API Error: ${error.response.status} - ${error.response.data?.error?.message || error.message}`);
      }
      throw error;
    }
  }

  async getAllExecutions(flowId, filters = {}) {
    const allExecutions = [];
    let cursor = null;

    do {
      const response = await this.getFlowExecutions(flowId, {
        ...filters,
        cursor,
        limit: 100
      });

      allExecutions.push(...response.data);
      cursor = response.pagination?.has_more ? response.pagination.cursor : null;
    } while (cursor);

    return allExecutions;
  }

  async getExecutionSummary(flowId) {
    const executions = await this.getAllExecutions(flowId);
    
    const summary = {
      total: executions.length,
      by_status: {},
      performance: {
        avg_duration_ms: 0,
        min_duration_ms: Infinity,
        max_duration_ms: 0
      },
      recent_activity: executions.slice(0, 5)
    };

    // Group by status
    executions.forEach(execution => {
      const status = execution.status;
      summary.by_status[status] = (summary.by_status[status] || 0) + 1;

      if (execution.performance?.duration_ms) {
        const duration = execution.performance.duration_ms;
        summary.performance.avg_duration_ms += duration;
        summary.performance.min_duration_ms = Math.min(summary.performance.min_duration_ms, duration);
        summary.performance.max_duration_ms = Math.max(summary.performance.max_duration_ms, duration);
      }
    });

    if (executions.length > 0) {
      summary.performance.avg_duration_ms /= executions.length;
      summary.success_rate = (summary.by_status.completed || 0) / executions.length;
    }

    return summary;
  }

  async monitorRecentExecutions(flowId, callback, intervalMs = 30000) {
    let lastChecked = new Date().toISOString();
    
    const check = async () => {
      try {
        const executions = await this.getFlowExecutions(flowId, {
          created_after: lastChecked,
          limit: 100
        });

        if (executions.data.length > 0) {
          callback(executions.data);
          lastChecked = new Date().toISOString();
        }
      } catch (error) {
        console.error('Error monitoring executions:', error.message);
      }
    };

    // Initial check
    await check();
    
    // Set up interval
    return setInterval(check, intervalMs);
  }
}

// Usage examples
const client = new FlowExecutionsClient('org_1234567890abcdef', 'user_abcdef1234567890');

async function analyzeFlowPerformance(flowId) {
  console.log(`Analyzing performance for flow: ${flowId}`);

  // Get execution summary
  const summary = await client.getExecutionSummary(flowId);
  console.log('Execution Summary:');
  console.log(`- Total executions: ${summary.total}`);
  console.log(`- Success rate: ${(summary.success_rate * 100).toFixed(1)}%`);
  console.log(`- Average duration: ${summary.performance.avg_duration_ms.toFixed(0)}ms`);
  console.log('- Status breakdown:', summary.by_status);

  // Get recent failures for debugging
  const failedExecutions = await client.getFlowExecutions(flowId, {
    status: 'failed',
    limit: 5
  });

  if (failedExecutions.data.length > 0) {
    console.log('\nRecent Failures:');
    failedExecutions.data.forEach((execution, index) => {
      console.log(`${index + 1}. ${execution.id}: ${execution.error?.message || 'Unknown error'}`);
    });
  }

  return summary;
}

// Monitor for new executions
const stopMonitoring = await client.monitorRecentExecutions(
  'flow_abc123def456',
  (newExecutions) => {
    console.log(`Found ${newExecutions.length} new execution(s):`);
    newExecutions.forEach(execution => {
      console.log(`- ${execution.id}: ${execution.status}`);
    });
  },
  60000 // Check every minute
);

// Analyze performance
analyzeFlowPerformance('flow_abc123def456')
  .then(summary => {
    console.log('Analysis complete');
  })
  .catch(error => {
    console.error('Analysis failed:', error.message);
  });
```

</RequestExample>

## Path Parameters

<ParamField path="id" type="string" required>
Unique flow identifier (format: `flow_` + 15 alphanumeric characters)
</ParamField>

## Query Parameters

<ParamField query="limit" type="integer" default="20">
Number of executions to return per page. Maximum value is 100.
</ParamField>

<ParamField query="cursor" type="string">
Pagination cursor for retrieving the next page of results.
</ParamField>

<ParamField query="status" type="string">
Filter executions by status. Available values:
- `queued` - Waiting to start execution
- `running` - Currently executing
- `completed` - Finished successfully
- `failed` - Failed with errors
- `cancelled` - Cancelled by user
- `timeout` - Exceeded time limit
</ParamField>

<ParamField query="created_after" type="string">
Return executions created after this ISO 8601 timestamp.

**Example:** `2024-01-15T00:00:00Z`
</ParamField>

<ParamField query="created_before" type="string">
Return executions created before this ISO 8601 timestamp.

**Example:** `2024-01-15T23:59:59Z`
</ParamField>

<ParamField query="sort_by" type="string" default="created_at">
Sort field. Available options:
- `created_at` - Sort by execution start time
- `completed_at` - Sort by completion time
- `duration` - Sort by execution duration
- `status` - Sort by execution status
</ParamField>

<ParamField query="sort_order" type="string" default="desc">
Sort direction: `asc` (ascending) or `desc` (descending)
</ParamField>

<ParamField query="tags" type="string">
Filter by execution tags. Comma-separated list.
</ParamField>

<ParamField query="user_id" type="string">
Filter executions started by a specific user.
</ParamField>

## Response

<ResponseExample>

```json Success Response
{
  "success": true,
  "data": [
    {
      "id": "exec_abc123def456ghi789",
      "flow_id": "flow_abc123def456",
      "status": "completed",
      "mode": "async",
      "priority": "normal",
      "inputs": {
        "customer_email": "john@company.com",
        "plan_type": "premium",
        "customer_name": "John Smith"
      },
      "outputs": {
        "send_welcome_email": {
          "status": "completed",
          "message_id": "msg_abc123",
          "delivered_at": "2024-01-15T14:30:15Z"
        },
        "create_account": {
          "status": "completed",
          "account_id": "acc_xyz789",
          "created_at": "2024-01-15T14:30:30Z"
        },
        "send_confirmation": {
          "status": "completed",
          "confirmation_sent": true,
          "tracking_id": "track_def456"
        }
      },
      "execution_summary": {
        "total_steps": 3,
        "completed_steps": 3,
        "failed_steps": 0,
        "skipped_steps": 0,
        "success_rate": 1.0
      },
      "performance": {
        "duration_ms": 4580,
        "queue_wait_ms": 123,
        "steps_duration_ms": {
          "send_welcome_email": 1200,
          "create_account": 2100,
          "send_confirmation": 800
        },
        "memory_peak_mb": 45,
        "cpu_time_ms": 1250
      },
      "progress": {
        "current_step": null,
        "completed_steps": 3,
        "total_steps": 3,
        "percentage": 100
      },
      "tags": ["customer-onboarding", "priority"],
      "webhook_url": "https://your-app.com/webhooks/flow-completion",
      "created_by": {
        "id": "user_abcdef1234567890",
        "name": "John Smith",
        "email": "john@company.com"
      },
      "started_at": "2024-01-15T14:30:00Z",
      "completed_at": "2024-01-15T14:30:04Z",
      "estimated_completion": null
    },
    {
      "id": "exec_def456ghi789abc123",
      "flow_id": "flow_abc123def456",
      "status": "failed",
      "mode": "sync",
      "priority": "normal",
      "inputs": {
        "customer_email": "invalid-email",
        "plan_type": "premium",
        "customer_name": "Jane Doe"
      },
      "error": {
        "code": "VALIDATION_ERROR",
        "message": "Email validation failed in step 'send_welcome_email'",
        "step_key": "send_welcome_email",
        "details": {
          "field": "to",
          "value": "invalid-email",
          "reason": "Invalid email format"
        },
        "retry_count": 2,
        "last_retry_at": "2024-01-15T13:45:10Z"
      },
      "outputs": {
        "send_welcome_email": {
          "status": "failed",
          "error": "Invalid email format: invalid-email",
          "attempted_at": "2024-01-15T13:45:05Z"
        }
      },
      "execution_summary": {
        "total_steps": 3,
        "completed_steps": 0,
        "failed_steps": 1,
        "skipped_steps": 2,
        "success_rate": 0.0
      },
      "performance": {
        "duration_ms": 156,
        "queue_wait_ms": 67,
        "steps_duration_ms": {
          "send_welcome_email": 89
        },
        "memory_peak_mb": 12,
        "cpu_time_ms": 45
      },
      "tags": ["customer-onboarding"],
      "created_by": {
        "id": "user_abcdef1234567890",
        "name": "John Smith",
        "email": "john@company.com"
      },
      "started_at": "2024-01-15T13:45:00Z",
      "failed_at": "2024-01-15T13:45:00Z",
      "retry_after": null
    },
    {
      "id": "exec_ghi789abc123def456",
      "flow_id": "flow_abc123def456",
      "status": "running",
      "mode": "async",
      "priority": "high",
      "inputs": {
        "customer_email": "customer@example.com",
        "plan_type": "enterprise",
        "customer_name": "Enterprise Client"
      },
      "progress": {
        "current_step": "create_account",
        "completed_steps": 1,
        "total_steps": 3,
        "percentage": 33,
        "step_progress": {
          "send_welcome_email": "completed",
          "create_account": "running",
          "send_confirmation": "pending"
        }
      },
      "performance": {
        "duration_ms": 2340,
        "queue_wait_ms": 45,
        "steps_duration_ms": {
          "send_welcome_email": 1100
        },
        "memory_peak_mb": 38
      },
      "tags": ["customer-onboarding", "enterprise"],
      "webhook_url": "https://your-app.com/webhooks/flow-completion",
      "created_by": {
        "id": "user_fedcba0987654321",
        "name": "Sarah Johnson",
        "email": "sarah@company.com"
      },
      "started_at": "2024-01-15T14:45:00Z",
      "estimated_completion": "2024-01-15T14:47:00Z"
    }
  ],
  "pagination": {
    "limit": 20,
    "cursor": "eyJpZCI6ImV4ZWNfZ2hpNzg5IiwiY3JlYXRlZF9hdCI6IjIwMjQtMDEtMTVUMTQ6NDU6MDBaIn0",
    "has_more": true,
    "total_count": 147
  },
  "metadata": {
    "request_id": "req_abc123def456",
    "timestamp": "2024-01-15T15:00:00Z",
    "execution_time_ms": 89
  }
}
```

```json Empty Response
{
  "success": true,
  "data": [],
  "pagination": {
    "limit": 20,
    "cursor": null,
    "has_more": false,
    "total_count": 0
  },
  "metadata": {
    "request_id": "req_empty123",
    "timestamp": "2024-01-15T15:00:00Z",
    "execution_time_ms": 23
  }
}
```

```json Error Response
{
  "success": false,
  "error": {
    "code": "FLOW_NOT_FOUND",
    "message": "Flow not found or not accessible",
    "details": {
      "flow_id": "flow_nonexistent123"
    }
  },
  "metadata": {
    "request_id": "req_error123",
    "timestamp": "2024-01-15T15:00:00Z"
  }
}
```

</ResponseExample>

## Response Fields

### Execution Object

<ResponseField name="id" type="string">
Unique execution identifier (format: `exec_` + 24 alphanumeric characters)
</ResponseField>

<ResponseField name="flow_id" type="string">
ID of the flow that was executed
</ResponseField>

<ResponseField name="status" type="string">
Current execution status:
- `queued` - Waiting to start
- `running` - Currently executing
- `completed` - Finished successfully
- `failed` - Failed with errors
- `cancelled` - Cancelled by user
- `timeout` - Exceeded time limit
</ResponseField>

<ResponseField name="mode" type="string">
Execution mode: `sync` or `async`
</ResponseField>

<ResponseField name="priority" type="string">
Execution priority: `low`, `normal`, `high`, or `critical`
</ResponseField>

<ResponseField name="inputs" type="object">
Input data provided for the execution
</ResponseField>

<ResponseField name="outputs" type="object">
Results from completed steps (keyed by step key)
  <Expandable title="Step Output Fields">
    <ResponseField name="{step_key}.status" type="string">Status of individual step</ResponseField>
    <ResponseField name="{step_key}.*" type="any">Step-specific output data</ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="error" type="object">
Error information (present when status is `failed`)
  <Expandable title="Error Fields">
    <ResponseField name="code" type="string">Error code</ResponseField>
    <ResponseField name="message" type="string">Error description</ResponseField>
    <ResponseField name="step_key" type="string">Step where error occurred</ResponseField>
    <ResponseField name="details" type="object">Additional error context</ResponseField>
    <ResponseField name="retry_count" type="integer">Number of retry attempts made</ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="execution_summary" type="object">
Summary statistics about the execution
  <Expandable title="Summary Fields">
    <ResponseField name="total_steps" type="integer">Total number of steps</ResponseField>
    <ResponseField name="completed_steps" type="integer">Successfully completed steps</ResponseField>
    <ResponseField name="failed_steps" type="integer">Failed steps</ResponseField>
    <ResponseField name="skipped_steps" type="integer">Skipped steps</ResponseField>
    <ResponseField name="success_rate" type="number">Success rate (0.0 to 1.0)</ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="performance" type="object">
Performance metrics
  <Expandable title="Performance Fields">
    <ResponseField name="duration_ms" type="integer">Total execution duration</ResponseField>
    <ResponseField name="queue_wait_ms" type="integer">Time spent waiting in queue</ResponseField>
    <ResponseField name="steps_duration_ms" type="object">Duration breakdown by step</ResponseField>
    <ResponseField name="memory_peak_mb" type="number">Peak memory usage</ResponseField>
    <ResponseField name="cpu_time_ms" type="integer">CPU time consumed</ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="progress" type="object">
Current execution progress (running executions only)
  <Expandable title="Progress Fields">
    <ResponseField name="current_step" type="string">Currently executing step</ResponseField>
    <ResponseField name="completed_steps" type="integer">Number of completed steps</ResponseField>
    <ResponseField name="total_steps" type="integer">Total steps in flow</ResponseField>
    <ResponseField name="percentage" type="number">Completion percentage</ResponseField>
    <ResponseField name="step_progress" type="object">Progress status for each step</ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="tags" type="string[]">
Tags associated with this execution
</ResponseField>

<ResponseField name="webhook_url" type="string">
Webhook URL for completion notifications (if provided)
</ResponseField>

<ResponseField name="created_by" type="object">
User who started the execution
</ResponseField>

<ResponseField name="started_at" type="string">
ISO 8601 timestamp when execution started
</ResponseField>

<ResponseField name="completed_at" type="string">
ISO 8601 timestamp when execution completed (if completed)
</ResponseField>

<ResponseField name="failed_at" type="string">
ISO 8601 timestamp when execution failed (if failed)
</ResponseField>

<ResponseField name="estimated_completion" type="string">
Estimated completion time (running executions only)
</ResponseField>

## Status Codes

<ResponseField name="200" type="Success">
Executions retrieved successfully
</ResponseField>

<ResponseField name="400" type="Bad Request">
Invalid query parameters
</ResponseField>

<ResponseField name="401" type="Unauthorized">
Missing or invalid authentication
</ResponseField>

<ResponseField name="403" type="Forbidden">
Insufficient permissions to access flow executions
</ResponseField>

<ResponseField name="404" type="Not Found">
Flow not found or not accessible
</ResponseField>

<ResponseField name="429" type="Too Many Requests">
Rate limit exceeded
</ResponseField>

<ResponseField name="500" type="Internal Server Error">
Server error occurred
</ResponseField>

## Examples

### Recent Executions

<CodeGroup>

```bash Get Recent Executions
curl -X GET "https://tolstoy.getpullse.com/flows/flow_abc123/executions?limit=10&sort_order=desc" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890"
```

```typescript Recent Executions
const recentExecutions = await getFlowExecutions('flow_abc123', {
  limit: 10,
  sort_by: 'created_at',
  sort_order: 'desc'
});

console.log('Recent executions:');
recentExecutions.data.forEach((execution, index) => {
  console.log(`${index + 1}. ${execution.id}: ${execution.status} (${execution.started_at})`);
});
```

</CodeGroup>

### Filter by Status

<CodeGroup>

```bash Failed Executions
curl -X GET "https://tolstoy.getpullse.com/flows/flow_abc123/executions?status=failed&limit=20" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890"
```

```python Failed Executions Analysis
client = ExecutionsClient('org_1234567890abcdef', 'user_abcdef1234567890')

# Get failed executions from last 24 hours
from datetime import datetime, timedelta
yesterday = (datetime.now() - timedelta(days=1)).isoformat()

failed_executions = client.get_flow_executions(
    'flow_abc123',
    status='failed',
    created_after=yesterday,
    limit=50
)

print(f"Found {len(failed_executions['data'])} failed executions")

# Analyze failure patterns
error_types = {}
for execution in failed_executions['data']:
    error_code = execution.get('error', {}).get('code', 'UNKNOWN')
    error_types[error_code] = error_types.get(error_code, 0) + 1

print("Failure breakdown:")
for error_code, count in error_types.items():
    print(f"  {error_code}: {count}")
```

</CodeGroup>

### Performance Analysis

<CodeGroup>

```javascript Performance Metrics
async function analyzeExecutionPerformance(flowId) {
  const executions = await client.getFlowExecutions(flowId, {
    status: 'completed',
    limit: 100,
    sort_by: 'created_at',
    sort_order: 'desc'
  });

  const durations = executions.data
    .map(e => e.performance?.duration_ms)
    .filter(d => d != null);

  if (durations.length === 0) {
    return { message: 'No performance data available' };
  }

  const avg = durations.reduce((a, b) => a + b, 0) / durations.length;
  const min = Math.min(...durations);
  const max = Math.max(...durations);
  
  // Calculate percentiles
  const sorted = durations.sort((a, b) => a - b);
  const p50 = sorted[Math.floor(sorted.length * 0.5)];
  const p90 = sorted[Math.floor(sorted.length * 0.9)];
  const p99 = sorted[Math.floor(sorted.length * 0.99)];

  return {
    total_executions: durations.length,
    avg_duration_ms: Math.round(avg),
    min_duration_ms: min,
    max_duration_ms: max,
    p50_duration_ms: p50,
    p90_duration_ms: p90,
    p99_duration_ms: p99
  };
}

// Usage
analyzeExecutionPerformance('flow_abc123')
  .then(metrics => {
    console.log('Performance Analysis:');
    console.log(`Average: ${metrics.avg_duration_ms}ms`);
    console.log(`P50: ${metrics.p50_duration_ms}ms`);
    console.log(`P90: ${metrics.p90_duration_ms}ms`);
    console.log(`P99: ${metrics.p99_duration_ms}ms`);
  });
```

</CodeGroup>

### Time-based Filtering

<CodeGroup>

```bash Last 24 Hours
# Get executions from last 24 hours
YESTERDAY=$(date -u -d '24 hours ago' '+%Y-%m-%dT%H:%M:%SZ')
curl -X GET "https://tolstoy.getpullse.com/flows/flow_abc123/executions?created_after=${YESTERDAY}" \
  -H "x-org-id: org_1234567890abcdef" \
  -H "x-user-id: user_abcdef1234567890"
```

```typescript Time-based Analysis
async function getDailyExecutionStats(flowId: string, days: number = 7) {
  const stats = [];
  
  for (let i = 0; i < days; i++) {
    const date = new Date();
    date.setDate(date.getDate() - i);
    
    const dayStart = new Date(date);
    dayStart.setHours(0, 0, 0, 0);
    
    const dayEnd = new Date(date);
    dayEnd.setHours(23, 59, 59, 999);
    
    const executions = await getFlowExecutions(flowId, {
      created_after: dayStart.toISOString(),
      created_before: dayEnd.toISOString(),
      limit: 100
    });
    
    const completed = executions.data.filter(e => e.status === 'completed').length;
    const failed = executions.data.filter(e => e.status === 'failed').length;
    
    stats.push({
      date: dayStart.toISOString().split('T')[0],
      total: executions.data.length,
      completed,
      failed,
      success_rate: executions.data.length > 0 ? completed / executions.data.length : 0
    });
  }
  
  return stats.reverse();
}

// Get 7-day execution history
const weeklyStats = await getDailyExecutionStats('flow_abc123', 7);
console.log('Daily execution stats:');
weeklyStats.forEach(day => {
  console.log(`${day.date}: ${day.total} executions, ${(day.success_rate * 100).toFixed(1)}% success`);
});
```

</CodeGroup>

## Common Use Cases

### Monitoring and Alerting

Monitor execution health and set up alerts for failures or performance degradation.

### Debugging Failed Executions  

Identify patterns in failed executions to improve workflow reliability.

### Performance Optimization

Analyze execution durations and resource usage to optimize workflow performance.

### Audit and Compliance

Maintain execution history for audit trails and compliance requirements.

## Related Endpoints

<CardGroup cols={2}>
  <Card title="Get Execution Details" icon="info" href="/api/flows/get-flows-executions-1">
    View detailed information about a specific execution
  </Card>
  <Card title="Execute Flow" icon="play" href="/api/flows/post-flows-execute">
    Start a new flow execution
  </Card>
</CardGroup>

<CardGroup cols={2}>
  <Card title="Cancel Execution" icon="stop" href="/api/flows/post-flows-executions-cancel">
    Cancel a running execution
  </Card>
  <Card title="Retry Execution" icon="refresh" href="/api/flows/post-flows-executions-retry">
    Retry a failed execution
  </Card>
</CardGroup>

---

<Info>
**Tip**: Use time-based filtering and status filtering together to identify trends in execution failures and performance over time.
</Info>