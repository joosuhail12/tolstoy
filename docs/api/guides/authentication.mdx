---
title: "Authentication Guide"
description: "Complete guide to API authentication, token management, and security"
---

# Authentication Guide

This comprehensive guide covers all aspects of authenticating with the Tolstoy API, from basic API keys to advanced token management patterns.

## Authentication Methods

The Tolstoy API supports multiple authentication methods depending on your use case:

| Method | Use Case | Security Level | Complexity |
|--------|----------|----------------|------------|
| **API Keys** | Server-to-server, automation | High | Low |
| **User Tokens** | User-facing applications | Very High | Medium |
| **Webhook Signatures** | Webhook verification | High | Medium |
| **OAuth 2.0** | Third-party integrations | Very High | High |

## API Keys

### **Getting Your API Key**

1. Log in to the [Tolstoy Dashboard](https://app.tolstoy.dev)
2. Navigate to **Settings** → **API Keys**
3. Click **Create New API Key**
4. Choose your key type and permissions
5. Copy and securely store your key

### **API Key Types**

<Tabs>
  <Tab title="Live Keys">
    ```
    sk_live_1234567890abcdef...
    ```
    - **Environment**: Production
    - **Data Access**: Real production data
    - **Rate Limits**: Full production limits
    - **Usage**: Production applications only
  </Tab>
  
  <Tab title="Test Keys">
    ```
    sk_test_1234567890abcdef...
    ```
    - **Environment**: Staging/Development
    - **Data Access**: Test data only
    - **Rate Limits**: Same as production
    - **Usage**: Development and testing
  </Tab>
  
  <Tab title="Sandbox Keys">
    ```
    sk_sandbox_1234567890abcdef...
    ```
    - **Environment**: Sandbox
    - **Data Access**: Simulated responses
    - **Rate Limits**: Relaxed for testing
    - **Usage**: Initial development and demos
  </Tab>
</Tabs>

### **Using API Keys**

<CodeGroup>

```bash cURL
curl -X GET 'https://api.tolstoy.dev/actions' \
  -H 'Authorization: Bearer sk_live_1234567890abcdef...' \
  -H 'Content-Type: application/json'
```

```javascript JavaScript
const apiKey = 'sk_live_1234567890abcdef...';

const response = await fetch('https://api.tolstoy.dev/actions', {
  headers: {
    'Authorization': `Bearer ${apiKey}`,
    'Content-Type': 'application/json'
  }
});
```

```python Python
import requests

api_key = 'sk_live_1234567890abcdef...'

headers = {
    'Authorization': f'Bearer {api_key}',
    'Content-Type': 'application/json'
}

response = requests.get(
    'https://api.tolstoy.dev/actions',
    headers=headers
)
```

</CodeGroup>

## User Authentication

For user-facing applications, use the login flow to obtain user-scoped tokens:

### **Login Flow**

<CodeGroup>

```javascript Complete Login Flow
class TolstoyAuth {
  constructor(baseUrl = 'https://api.tolstoy.dev') {
    this.baseUrl = baseUrl;
    this.accessToken = null;
    this.refreshToken = null;
    this.user = null;
  }
  
  async login(email, password, mfaCode = null) {
    const loginData = {
      email,
      password
    };
    
    if (mfaCode) {
      loginData.mfa_code = mfaCode;
    }
    
    const response = await fetch(`${this.baseUrl}/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(loginData)
    });
    
    const data = await response.json();
    
    if (data.mfa_required) {
      // Handle MFA requirement
      return {
        requiresMFA: true,
        mfaToken: data.mfa_token,
        mfaMethods: data.mfa_methods
      };
    }
    
    if (response.ok) {
      this.accessToken = data.auth.access_token;
      this.refreshToken = data.auth.refresh_token;
      this.user = data.user;
      
      // Store tokens securely
      this.storeTokens(data.auth);
      
      return {
        success: true,
        user: this.user
      };
    }
    
    throw new Error(data.error.message);
  }
  
  storeTokens(auth) {
    // In production, use secure storage
    if (typeof window !== 'undefined') {
      sessionStorage.setItem('access_token', auth.access_token);
      localStorage.setItem('refresh_token', auth.refresh_token);
      localStorage.setItem('token_expiry', 
        (Date.now() + auth.expires_in * 1000).toString()
      );
    }
  }
  
  async refreshAccessToken() {
    if (!this.refreshToken) {
      throw new Error('No refresh token available');
    }
    
    const response = await fetch(`${this.baseUrl}/auth/refresh`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        refresh_token: this.refreshToken
      })
    });
    
    if (response.ok) {
      const data = await response.json();
      this.accessToken = data.auth.access_token;
      this.storeTokens(data.auth);
      return this.accessToken;
    }
    
    // Refresh failed, need to login again
    this.logout();
    throw new Error('Token refresh failed - please login again');
  }
  
  async makeAuthenticatedRequest(endpoint, options = {}) {
    // Auto-refresh token if needed
    if (this.isTokenExpired()) {
      await this.refreshAccessToken();
    }
    
    return fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        'Authorization': `Bearer ${this.accessToken}`,
        'Content-Type': 'application/json',
        ...options.headers
      }
    });
  }
  
  isTokenExpired() {
    const expiry = localStorage.getItem('token_expiry');
    return !expiry || Date.now() >= parseInt(expiry);
  }
  
  async logout() {
    if (this.accessToken) {
      await fetch(`${this.baseUrl}/auth/logout`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.accessToken}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          refresh_token: this.refreshToken
        })
      });
    }
    
    // Clear stored tokens
    this.accessToken = null;
    this.refreshToken = null;
    this.user = null;
    
    if (typeof window !== 'undefined') {
      sessionStorage.removeItem('access_token');
      localStorage.removeItem('refresh_token');
      localStorage.removeItem('token_expiry');
    }
  }
}

// Usage
const auth = new TolstoyAuth();

// Login
try {
  const result = await auth.login('user@example.com', 'password123');
  
  if (result.requiresMFA) {
    const mfaCode = await promptUserForMFA();
    await auth.login('user@example.com', 'password123', mfaCode);
  }
  
  console.log('Logged in as:', auth.user.name);
  
  // Make authenticated requests
  const flows = await auth.makeAuthenticatedRequest('/flows');
  
} catch (error) {
  console.error('Authentication failed:', error.message);
}
```

</CodeGroup>

## Webhook Authentication

### **Signature Verification**

Verify webhook authenticity using HMAC signatures:

<CodeGroup>

```javascript Verify Webhook Signature
const crypto = require('crypto');

function verifyWebhookSignature(payload, signature, secret) {
  // Tolstoy uses SHA-256 HMAC
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payload, 'utf8')
    .digest('hex');
  
  // Signature format: "sha256=abc123..."
  const providedSignature = signature.replace('sha256=', '');
  
  // Use timing-safe comparison
  return crypto.timingSafeEqual(
    Buffer.from(expectedSignature, 'hex'),
    Buffer.from(providedSignature, 'hex')
  );
}

// Express.js middleware
function webhookAuth(secret) {
  return (req, res, next) => {
    const signature = req.headers['x-tolstoy-signature'];
    const payload = JSON.stringify(req.body);
    
    if (!signature) {
      return res.status(401).json({ error: 'Missing signature' });
    }
    
    if (!verifyWebhookSignature(payload, signature, secret)) {
      return res.status(401).json({ error: 'Invalid signature' });
    }
    
    next();
  };
}

// Usage
app.post('/webhooks/tolstoy', 
  webhookAuth(process.env.TOLSTOY_WEBHOOK_SECRET),
  (req, res) => {
    console.log('Verified webhook:', req.body);
    res.json({ received: true });
  }
);
```

```python Python Webhook Verification
import hmac
import hashlib
from flask import Flask, request, jsonify

def verify_webhook_signature(payload: str, signature: str, secret: str) -> bool:
    """Verify Tolstoy webhook signature"""
    expected_signature = hmac.new(
        secret.encode('utf-8'),
        payload.encode('utf-8'),
        hashlib.sha256
    ).hexdigest()
    
    # Remove 'sha256=' prefix if present
    provided_signature = signature.replace('sha256=', '')
    
    # Timing-safe comparison
    return hmac.compare_digest(expected_signature, provided_signature)

app = Flask(__name__)

@app.route('/webhooks/tolstoy', methods=['POST'])
def handle_webhook():
    signature = request.headers.get('X-Tolstoy-Signature')
    payload = request.get_data(as_text=True)
    secret = os.environ['TOLSTOY_WEBHOOK_SECRET']
    
    if not signature:
        return jsonify({'error': 'Missing signature'}), 401
    
    if not verify_webhook_signature(payload, signature, secret):
        return jsonify({'error': 'Invalid signature'}), 401
    
    # Process webhook
    webhook_data = request.json
    print(f"Verified webhook: {webhook_data}")
    
    return jsonify({'received': True})
```

</CodeGroup>

## Security Best Practices

### **API Key Security**

<Warning>
Never expose API keys in client-side code, version control, or logs. Always use environment variables or secure key management systems.
</Warning>

#### **✅ Do This:**

```javascript
// Use environment variables
const apiKey = process.env.TOLSTOY_API_KEY;

// Use secure key management
const apiKey = await secretManager.getSecret('tolstoy-api-key');

// Use server-side proxy
const response = await fetch('/api/proxy/tolstoy/actions');
```

#### **❌ Don't Do This:**

```javascript
// Never hardcode keys
const apiKey = 'sk_live_1234567890abcdef...'; // ❌

// Never expose in client-side code
window.tolstoyApiKey = 'sk_live_...'; // ❌

// Never commit to version control
git add config.js  // containing API keys ❌
```

### **Token Management**

#### **Best Practices:**

1. **Store Securely**: Use secure storage mechanisms
2. **Auto-Refresh**: Implement automatic token refresh
3. **Handle Expiry**: Gracefully handle expired tokens
4. **Logout Cleanup**: Clear tokens on logout
5. **Rotation**: Regularly rotate long-lived tokens

#### **Secure Storage Options:**

<CodeGroup>

```javascript Browser Secure Storage
// Use sessionStorage for access tokens (cleared on tab close)
sessionStorage.setItem('access_token', accessToken);

// Use localStorage for refresh tokens (persistent)
localStorage.setItem('refresh_token', refreshToken);

// For sensitive applications, consider:
// - IndexedDB with encryption
// - Secure cookies (httpOnly, secure, sameSite)
// - Web Crypto API for client-side encryption
```

```python Server-Side Storage
import os
from cryptography.fernet import Fernet

class SecureTokenStorage:
    def __init__(self):
        # Use environment variable for encryption key
        key = os.environ.get('TOKEN_ENCRYPTION_KEY')
        if not key:
            key = Fernet.generate_key()
            print(f"Generated key: {key.decode()}")
        
        self.cipher = Fernet(key if isinstance(key, bytes) else key.encode())
    
    def store_token(self, user_id: str, token: str) -> None:
        encrypted_token = self.cipher.encrypt(token.encode())
        # Store in database or secure cache
        redis_client.set(f"token:{user_id}", encrypted_token, ex=3600)
    
    def get_token(self, user_id: str) -> str:
        encrypted_token = redis_client.get(f"token:{user_id}")
        if not encrypted_token:
            return None
        
        return self.cipher.decrypt(encrypted_token).decode()
    
    def delete_token(self, user_id: str) -> None:
        redis_client.delete(f"token:{user_id}")

# Usage
storage = SecureTokenStorage()
storage.store_token('user_123', access_token)
```

</CodeGroup>

### **Environment-Specific Keys**

<Info>
Always use different API keys for different environments. This prevents accidental production access from development code.
</Info>

<CodeGroup>

```bash Environment Variables
# .env.production
TOLSTOY_API_KEY=sk_live_prod_key_here
TOLSTOY_BASE_URL=https://api.tolstoy.dev

# .env.staging  
TOLSTOY_API_KEY=sk_test_staging_key_here
TOLSTOY_BASE_URL=https://api-staging.tolstoy.dev

# .env.development
TOLSTOY_API_KEY=sk_dev_development_key_here
TOLSTOY_BASE_URL=https://api-dev.tolstoy.dev
```

```yaml Kubernetes Secrets
apiVersion: v1
kind: Secret
metadata:
  name: tolstoy-api-keys
type: Opaque
data:
  prod-api-key: c2tfbGl2ZV9wcm9kX2tleV9oZXJl  # base64 encoded
  staging-api-key: c2tfdGVzdF9zdGFnaW5nX2tleV9oZXJl
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  template:
    spec:
      containers:
      - name: app
        env:
        - name: TOLSTOY_API_KEY
          valueFrom:
            secretKeyRef:
              name: tolstoy-api-keys
              key: prod-api-key
```

</CodeGroup>

## Error Handling

### **Authentication Errors**

Handle authentication errors gracefully:

<CodeGroup>

```javascript Error Handling
class AuthenticatedClient {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.tolstoy.dev';
  }
  
  async request(endpoint, options = {}) {
    const response = await fetch(`${this.baseUrl}${endpoint}`, {
      ...options,
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json',
        ...options.headers
      }
    });
    
    // Handle authentication errors
    if (response.status === 401) {
      const error = await response.json();
      
      switch (error.error.code) {
        case 'INVALID_API_KEY':
          throw new AuthError('Invalid API key - check your key and permissions');
        case 'EXPIRED_TOKEN':
          throw new AuthError('Token expired - please refresh');
        case 'REVOKED_TOKEN':
          throw new AuthError('Token revoked - please login again');
        default:
          throw new AuthError(error.error.message);
      }
    }
    
    if (response.status === 403) {
      const error = await response.json();
      throw new PermissionError(
        `Insufficient permissions: ${error.error.required_scopes?.join(', ')}`
      );
    }
    
    if (!response.ok) {
      const error = await response.json();
      throw new APIError(error.error.message);
    }
    
    return response.json();
  }
}

class AuthError extends Error {
  constructor(message) {
    super(message);
    this.name = 'AuthError';
  }
}

class PermissionError extends Error {
  constructor(message) {
    super(message);
    this.name = 'PermissionError';
  }
}

// Usage
const client = new AuthenticatedClient(apiKey);

try {
  const actions = await client.request('/actions');
} catch (error) {
  if (error instanceof AuthError) {
    console.error('Authentication failed:', error.message);
    // Redirect to login or refresh token
  } else if (error instanceof PermissionError) {
    console.error('Permission denied:', error.message);
    // Show permission error to user
  } else {
    console.error('API error:', error.message);
  }
}
```

</CodeGroup>

### **Automatic Retry with Backoff**

<CodeGroup>

```javascript Retry Logic
class RetryableClient {
  constructor(apiKey, maxRetries = 3) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.tolstoy.dev';
    this.maxRetries = maxRetries;
  }
  
  async requestWithRetry(endpoint, options = {}, attempt = 1) {
    try {
      const response = await fetch(`${this.baseUrl}${endpoint}`, {
        ...options,
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
          ...options.headers
        }
      });
      
      // Don't retry client errors (4xx) except 401, 429
      if (response.status >= 400 && response.status < 500) {
        if (response.status !== 401 && response.status !== 429) {
          throw new Error(`Client error: ${response.status}`);
        }
      }
      
      // Handle rate limiting
      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After') || 60;
        console.log(`Rate limited, waiting ${retryAfter}s...`);
        await this.delay(retryAfter * 1000);
        
        if (attempt <= this.maxRetries) {
          return this.requestWithRetry(endpoint, options, attempt + 1);
        }
      }
      
      // Retry server errors (5xx)
      if (response.status >= 500) {
        if (attempt <= this.maxRetries) {
          const backoffMs = Math.min(1000 * Math.pow(2, attempt), 30000);
          console.log(`Server error, retrying in ${backoffMs}ms...`);
          await this.delay(backoffMs);
          return this.requestWithRetry(endpoint, options, attempt + 1);
        }
      }
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error.message);
      }
      
      return response.json();
      
    } catch (error) {
      if (attempt <= this.maxRetries && this.isRetryableError(error)) {
        const backoffMs = Math.min(1000 * Math.pow(2, attempt), 30000);
        console.log(`Network error, retrying in ${backoffMs}ms...`);
        await this.delay(backoffMs);
        return this.requestWithRetry(endpoint, options, attempt + 1);
      }
      
      throw error;
    }
  }
  
  isRetryableError(error) {
    return error.name === 'NetworkError' || 
           error.message.includes('timeout') ||
           error.message.includes('ECONNRESET');
  }
  
  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Usage
const client = new RetryableClient(apiKey);
const actions = await client.requestWithRetry('/actions');
```

</CodeGroup>

## Multi-Factor Authentication

### **TOTP Setup**

<CodeGroup>

```javascript TOTP Integration
async function setupMFA(apiKey) {
  // Get MFA setup info
  const setupResponse = await fetch('https://api.tolstoy.dev/auth/mfa/setup', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      method: 'totp'
    })
  });
  
  const setup = await setupResponse.json();
  
  console.log('MFA Setup:');
  console.log('1. Scan this QR code with your authenticator app:');
  console.log(setup.qr_code_url);
  console.log('');
  console.log('2. Or manually enter this secret:');
  console.log(setup.secret);
  console.log('');
  console.log('3. Enter the 6-digit code from your app to verify setup');
  
  return setup;
}

async function verifyMFASetup(apiKey, setupToken, verificationCode) {
  const response = await fetch('https://api.tolstoy.dev/auth/mfa/verify-setup', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      setup_token: setupToken,
      code: verificationCode
    })
  });
  
  if (response.ok) {
    console.log('✅ MFA setup completed');
    return true;
  } else {
    const error = await response.json();
    console.error('❌ MFA setup failed:', error.error.message);
    return false;
  }
}

// Usage
const setup = await setupMFA(apiKey);
const userCode = '123456'; // Get from user input
await verifyMFASetup(apiKey, setup.setup_token, userCode);
```

</CodeGroup>

## OAuth 2.0 Integration

For third-party applications that need to access user data:

<CodeGroup>

```javascript OAuth Flow
class TolstoyOAuth {
  constructor(clientId, clientSecret, redirectUri) {
    this.clientId = clientId;
    this.clientSecret = clientSecret;
    this.redirectUri = redirectUri;
    this.baseUrl = 'https://api.tolstoy.dev';
  }
  
  getAuthorizationUrl(scopes = ['actions:read', 'flows:read']) {
    const params = new URLSearchParams({
      response_type: 'code',
      client_id: this.clientId,
      redirect_uri: this.redirectUri,
      scope: scopes.join(' '),
      state: this.generateState() // CSRF protection
    });
    
    return `${this.baseUrl}/oauth/authorize?${params}`;
  }
  
  async exchangeCodeForTokens(authorizationCode, state) {
    // Verify state parameter (CSRF protection)
    if (!this.verifyState(state)) {
      throw new Error('Invalid state parameter');
    }
    
    const response = await fetch(`${this.baseUrl}/oauth/token`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        grant_type: 'authorization_code',
        code: authorizationCode,
        client_id: this.clientId,
        client_secret: this.clientSecret,
        redirect_uri: this.redirectUri
      })
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(`Token exchange failed: ${error.error.message}`);
    }
    
    const tokens = await response.json();
    return tokens;
  }
  
  generateState() {
    const state = Math.random().toString(36).substring(2, 15);
    sessionStorage.setItem('oauth_state', state);
    return state;
  }
  
  verifyState(state) {
    const storedState = sessionStorage.getItem('oauth_state');
    sessionStorage.removeItem('oauth_state');
    return storedState === state;
  }
}

// Usage
const oauth = new TolstoyOAuth(
  'your_client_id',
  'your_client_secret', 
  'https://yourapp.com/callback'
);

// Step 1: Redirect user to authorization URL
window.location.href = oauth.getAuthorizationUrl(['actions:read', 'flows:write']);

// Step 2: Handle callback (on your callback page)
const urlParams = new URLSearchParams(window.location.search);
const code = urlParams.get('code');
const state = urlParams.get('state');

if (code) {
  const tokens = await oauth.exchangeCodeForTokens(code, state);
  console.log('OAuth tokens received:', tokens);
  
  // Store tokens and make authenticated requests
  const userClient = new TolstoyClient({
    accessToken: tokens.access_token,
    refreshToken: tokens.refresh_token
  });
}
```

</CodeGroup>

## Testing Authentication

### **Authentication Test Suite**

<CodeGroup>

```javascript Test Suite
describe('Tolstoy Authentication', () => {
  const apiKey = process.env.TOLSTOY_TEST_API_KEY;
  const baseUrl = 'https://api-dev.tolstoy.dev';
  
  test('API key authentication works', async () => {
    const response = await fetch(`${baseUrl}/health`, {
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      }
    });
    
    expect(response.status).toBe(200);
    
    const health = await response.json();
    expect(health.status).toBe('healthy');
  });
  
  test('Invalid API key returns 401', async () => {
    const response = await fetch(`${baseUrl}/actions`, {
      headers: {
        'Authorization': 'Bearer invalid_key',
        'Content-Type': 'application/json'
      }
    });
    
    expect(response.status).toBe(401);
    
    const error = await response.json();
    expect(error.error.code).toBe('UNAUTHORIZED');
  });
  
  test('Missing authorization header returns 401', async () => {
    const response = await fetch(`${baseUrl}/actions`, {
      headers: {
        'Content-Type': 'application/json'
      }
    });
    
    expect(response.status).toBe(401);
  });
  
  test('User login flow works', async () => {
    const loginResponse = await fetch(`${baseUrl}/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        email: 'test@example.com',
        password: 'TestPassword123!'
      })
    });
    
    expect(loginResponse.status).toBe(200);
    
    const auth = await loginResponse.json();
    expect(auth.auth.access_token).toBeDefined();
    expect(auth.user.email).toBe('test@example.com');
  });
});
```

</CodeGroup>

## API Playground

Test authentication methods:

<ApiPlayground
  method="POST"
  endpoint="/auth/login"
  baseUrl="https://api.tolstoy.dev"
  body={{
    type: "json",
    schema: {
      email: {
        type: "string",
        placeholder: "john.doe@example.com",
        description: "User email address",
        required: true
      },
      password: {
        type: "password",
        placeholder: "SecurePassword123!",
        description: "User password",
        required: true
      },
      mfa_code: {
        type: "string",
        placeholder: "123456",
        description: "6-digit MFA code (if enabled)"
      },
      remember_me: {
        type: "boolean",
        defaultValue: false,
        description: "Extend refresh token expiry"
      }
    }
  }}
  sampleResponse={{
    "auth": {
      "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "token_type": "Bearer",
      "expires_in": 3600
    },
    "user": {
      "id": "user_123456789",
      "email": "john.doe@example.com",
      "name": "John Doe",
      "role": "admin"
    }
  }}
/>

## Common Issues

<Accordion>
  <AccordionItem title="401 Unauthorized">
    **Causes:**
    - Invalid API key
    - Expired access token  
    - Missing Authorization header
    - Wrong token format
    
    **Solutions:**
    - Verify API key is correct and active
    - Refresh expired tokens
    - Ensure header format: `Authorization: Bearer sk_live_...`
    - Check for typos in token
  </AccordionItem>
  
  <AccordionItem title="403 Forbidden">
    **Causes:**
    - Insufficient permissions
    - API key lacks required scopes
    - Organization access restrictions
    
    **Solutions:**
    - Check required scopes in error response
    - Request additional permissions from admin
    - Verify organization membership
  </AccordionItem>
  
  <AccordionItem title="429 Rate Limited">
    **Causes:**
    - Too many requests in time window
    - Burst limit exceeded
    - Organization limits reached
    
    **Solutions:**
    - Implement exponential backoff
    - Respect Retry-After header
    - Upgrade plan for higher limits
  </AccordionItem>
</Accordion>

## Related Pages

<CardGroup cols={2}>
  <Card title="Base URLs" icon="globe" href="/api/base-urls">
    API endpoints and environments
  </Card>
  <Card title="Rate Limiting" icon="gauge" href="/api/rate-limiting">
    Understanding API rate limits
  </Card>
  <Card title="Error Codes" icon="triangle-exclamation" href="/api/error-codes">
    Complete error code reference
  </Card>
  <Card title="Security Best Practices" icon="shield" href="/api/guides/security">
    Advanced security patterns
  </Card>
</CardGroup>